/********************************************
 * DDS type specific source file.           *
 * Autogenerated by CoreDX DDL compiler.    *
 * Do no edit - edits may be overwritten.   *
 ********************************************/
#include <string.h>
#include <dds/dds.hh>
#ifdef _MSC_VER
#pragma warning(disable:4996)
#pragma warning(disable:4100)
#endif
#include "OpenFMB.hh"
#define s_offsetof(TYPE,field) ((size_t)((char *)&(((TYPE *)0x10)->field) - (char*)0x10))

/******************************************************************
 * openfmb::commonmodule::AnalogueValue Default Constructor
 ******************************************************************/
openfmb::commonmodule::AnalogueValue::AnalogueValue()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValue Copy Constructor
 ******************************************************************/
openfmb::commonmodule::AnalogueValue::AnalogueValue( const AnalogueValue & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValue Destructor
 ******************************************************************/
openfmb::commonmodule::AnalogueValue::~AnalogueValue()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValue Assignment Operator
 ******************************************************************/
openfmb::commonmodule::AnalogueValue& openfmb::commonmodule::AnalogueValue::operator=( const openfmb::commonmodule::AnalogueValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::AnalogueValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::AnalogueValue init()
 ******************************************************************/
void openfmb::commonmodule::AnalogueValue::init()
{
  this->i = NULL;
  this->f = NULL;
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValue clear()
 ******************************************************************/
void openfmb::commonmodule::AnalogueValue::clear()
{
  if (this->i != NULL) {
    delete this->i;
    this->i = NULL;
  }
  if (this->f != NULL) {
    delete this->f;
    this->f = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValue copy()
 ******************************************************************/
void openfmb::commonmodule::AnalogueValue::copy( const AnalogueValue * copy_from )
{

  AnalogueValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy i */
  if (copy_from->i) {
    copy_to->i = (openfmb::commonmodule::INT32*)new openfmb::commonmodule::INT32();
    (*copy_to->i) = (*copy_from->i);
  }
  else
    copy_to->i = NULL;

  /* copy f */
  if (copy_from->f) {
    copy_to->f = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
    (*copy_to->f) = (*copy_from->f);
  }
  else
    copy_to->f = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValue::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (i != NULL) {
          /* (*i) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (f != NULL) {
          /* (*f) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValue::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (i != NULL) {
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, (*i));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (f != NULL) {
              DDS_MARSH_PUT_FLOAT_AND_REORDER(buf, offset, (*f));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (i != NULL) {
              DDS_MARSH_PUT_LONG(buf, offset, (*i));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (f != NULL) {
              DDS_MARSH_PUT_FLOAT(buf, offset, (*f));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValue::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                i = (openfmb::commonmodule::INT32*)new openfmb::commonmodule::INT32();
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, (*i), stream_len);
              }
              else {
                i = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                f = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
                DDS_MARSH_GET_FLOAT_AND_REORDER(buf, offset, (*f), stream_len);
              }
              else {
                f = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                i = (openfmb::commonmodule::INT32*)new openfmb::commonmodule::INT32();
                DDS_MARSH_GET_LONG(buf, offset, (*i), stream_len);
              }
              else {
                i = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                f = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
                DDS_MARSH_GET_FLOAT(buf, offset, (*f), stream_len);
              }
              else {
                f = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::AnalogueValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("i", fieldname)==0) {
    field_def->kind       = 66;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::AnalogueValue,i);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::AnalogueValue,i);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("f", fieldname)==0) {
    field_def->kind       = 69;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::AnalogueValue,f);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::AnalogueValue,f);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValueCtl Default Constructor
 ******************************************************************/
openfmb::commonmodule::AnalogueValueCtl::AnalogueValueCtl()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValueCtl Copy Constructor
 ******************************************************************/
openfmb::commonmodule::AnalogueValueCtl::AnalogueValueCtl( const AnalogueValueCtl & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValueCtl Destructor
 ******************************************************************/
openfmb::commonmodule::AnalogueValueCtl::~AnalogueValueCtl()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValueCtl Assignment Operator
 ******************************************************************/
openfmb::commonmodule::AnalogueValueCtl& openfmb::commonmodule::AnalogueValueCtl::operator=( const openfmb::commonmodule::AnalogueValueCtl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::AnalogueValueCtl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::AnalogueValueCtl init()
 ******************************************************************/
void openfmb::commonmodule::AnalogueValueCtl::init()
{
  this->i = NULL;
  this->f = NULL;
}

/******************************************************************
 * openfmb::commonmodule::AnalogueValueCtl clear()
 ******************************************************************/
void openfmb::commonmodule::AnalogueValueCtl::clear()
{
  if (this->i != NULL) {
    delete this->i;
    this->i = NULL;
  }
  if (this->f != NULL) {
    delete this->f;
    this->f = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValueCtl copy()
 ******************************************************************/
void openfmb::commonmodule::AnalogueValueCtl::copy( const AnalogueValueCtl * copy_from )
{

  AnalogueValueCtl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy i */
  if (copy_from->i) {
    copy_to->i = (openfmb::commonmodule::INT32*)new openfmb::commonmodule::INT32();
    (*copy_to->i) = (*copy_from->i);
  }
  else
    copy_to->i = NULL;

  /* copy f */
  if (copy_from->f) {
    copy_to->f = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
    (*copy_to->f) = (*copy_from->f);
  }
  else
    copy_to->f = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValueCtl::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValueCtl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (i != NULL) {
          /* (*i) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (f != NULL) {
          /* (*f) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValueCtl::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValueCtl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (i != NULL) {
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, (*i));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (f != NULL) {
              DDS_MARSH_PUT_FLOAT_AND_REORDER(buf, offset, (*f));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (i != NULL) {
              DDS_MARSH_PUT_LONG(buf, offset, (*i));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (f != NULL) {
              DDS_MARSH_PUT_FLOAT(buf, offset, (*f));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValueCtl::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValueCtl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValueCtl::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValueCtl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                i = (openfmb::commonmodule::INT32*)new openfmb::commonmodule::INT32();
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, (*i), stream_len);
              }
              else {
                i = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                f = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
                DDS_MARSH_GET_FLOAT_AND_REORDER(buf, offset, (*f), stream_len);
              }
              else {
                f = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                i = (openfmb::commonmodule::INT32*)new openfmb::commonmodule::INT32();
                DDS_MARSH_GET_LONG(buf, offset, (*i), stream_len);
              }
              else {
                i = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                f = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
                DDS_MARSH_GET_FLOAT(buf, offset, (*f), stream_len);
              }
              else {
                f = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValueCtl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::AnalogueValueCtl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::AnalogueValueCtl get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::AnalogueValueCtl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("i", fieldname)==0) {
    field_def->kind       = 66;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::AnalogueValueCtl,i);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::AnalogueValueCtl,i);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("f", fieldname)==0) {
    field_def->kind       = 69;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::AnalogueValueCtl,f);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::AnalogueValueCtl,f);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::BCR Default Constructor
 ******************************************************************/
openfmb::commonmodule::BCR::BCR()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::BCR Copy Constructor
 ******************************************************************/
openfmb::commonmodule::BCR::BCR( const BCR & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::BCR Destructor
 ******************************************************************/
openfmb::commonmodule::BCR::~BCR()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::BCR Assignment Operator
 ******************************************************************/
openfmb::commonmodule::BCR& openfmb::commonmodule::BCR::operator=( const openfmb::commonmodule::BCR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::BCR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::BCR init()
 ******************************************************************/
void openfmb::commonmodule::BCR::init()
{
  this->actVal = NULL;
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  this->t = NULL;
  this->units = NULL;
}

/******************************************************************
 * openfmb::commonmodule::BCR clear()
 ******************************************************************/
void openfmb::commonmodule::BCR::clear()
{
  if (this->actVal != NULL) {
    delete this->actVal;
    this->actVal = NULL;
  }
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  if (this->t != NULL) {
    delete[] this->t;
    this->t = NULL;
  }
  if (this->units != NULL) {
    delete this->units;
    this->units = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::BCR copy()
 ******************************************************************/
void openfmb::commonmodule::BCR::copy( const BCR * copy_from )
{

  BCR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy actVal */
  if (copy_from->actVal) {
    copy_to->actVal = (openfmb::commonmodule::INT64*)new openfmb::commonmodule::INT64();
    (*copy_to->actVal) = (*copy_from->actVal);
  }
  else
    copy_to->actVal = NULL;

  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  if (copy_from->t) {
    copy_to->t = (openfmb::commonmodule::Timestamp*)new openfmb::commonmodule::Timestamp();
    {
      int i_1;
      for (i_1 = 0; i_1 < 8; i_1++)
        {
          (*copy_to->t)[i_1] = (*copy_from->t)[i_1];
        }
    }
  }
  else
    copy_to->t = NULL;

  /* copy units */
  if (copy_from->units) {
    copy_to->units = (enum openfmb::commonmodule::UnitSymbolKind *)new enum openfmb::commonmodule::UnitSymbolKind ();
    (*copy_to->units) = (*copy_from->units);
  }
  else
    copy_to->units = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::BCR::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::BCR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (actVal != NULL) {
          /* (*actVal) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      /* q */
      offset += 2;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (t != NULL) {
          /* (*t) */
          offset += 8;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (units != NULL) {
          /* (*units) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::BCR::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::BCR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (actVal != NULL) {
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, (*actVal));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          memcpy(&buf[offset], q, 2);
          offset+=2;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (t != NULL) {
              memcpy(&buf[offset], (*t), 8);
              offset+=8;
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, (*units), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (actVal != NULL) {
              DDS_MARSH_PUT_LONG(buf, offset, (*actVal));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          memcpy(&buf[offset], q, 2);
          offset+=2;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (t != NULL) {
              memcpy(&buf[offset], (*t), 8);
              offset+=8;
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              DDS_MARSH_PUT_ENUM(buf, offset, (*units), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::BCR::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::BCR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::BCR::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::BCR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                actVal = (openfmb::commonmodule::INT64*)new openfmb::commonmodule::INT64();
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, (*actVal), stream_len);
              }
              else {
                actVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          memcpy(q, &buf[offset], 2);
          offset+=2;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                t = (openfmb::commonmodule::Timestamp*)new openfmb::commonmodule::Timestamp();
                memcpy((*t), &buf[offset], 8);
                offset+=8;
              }
              else {
                t = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (enum openfmb::commonmodule::UnitSymbolKind *)new enum openfmb::commonmodule::UnitSymbolKind ();
                DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, (*units), 4, openfmb::commonmodule::UnitSymbolKind, stream_len);
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                actVal = (openfmb::commonmodule::INT64*)new openfmb::commonmodule::INT64();
                DDS_MARSH_GET_LONG(buf, offset, (*actVal), stream_len);
              }
              else {
                actVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          memcpy(q, &buf[offset], 2);
          offset+=2;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                t = (openfmb::commonmodule::Timestamp*)new openfmb::commonmodule::Timestamp();
                memcpy((*t), &buf[offset], 8);
                offset+=8;
              }
              else {
                t = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (enum openfmb::commonmodule::UnitSymbolKind *)new enum openfmb::commonmodule::UnitSymbolKind ();
                DDS_MARSH_GET_ENUM(buf, offset, (*units), 4, openfmb::commonmodule::UnitSymbolKind, stream_len);
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::BCR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::BCR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::BCR get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::BCR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("actVal", fieldname)==0) {
    field_def->kind       = 66;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::BCR,actVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::BCR,actVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::BCR,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::BCR,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 79;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::BCR,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::BCR,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("units", fieldname)==0) {
    field_def->kind       = 76;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::BCR,units);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::BCR,units);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::CheckConditions Default Constructor
 ******************************************************************/
openfmb::commonmodule::CheckConditions::CheckConditions()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::CheckConditions Copy Constructor
 ******************************************************************/
openfmb::commonmodule::CheckConditions::CheckConditions( const CheckConditions & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::CheckConditions Destructor
 ******************************************************************/
openfmb::commonmodule::CheckConditions::~CheckConditions()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::CheckConditions Assignment Operator
 ******************************************************************/
openfmb::commonmodule::CheckConditions& openfmb::commonmodule::CheckConditions::operator=( const openfmb::commonmodule::CheckConditions & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::CheckConditions Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::CheckConditions init()
 ******************************************************************/
void openfmb::commonmodule::CheckConditions::init()
{
  this->synchroCheck = NULL;
  this->interlockCheck = NULL;
}

/******************************************************************
 * openfmb::commonmodule::CheckConditions clear()
 ******************************************************************/
void openfmb::commonmodule::CheckConditions::clear()
{
  if (this->synchroCheck != NULL) {
    delete this->synchroCheck;
    this->synchroCheck = NULL;
  }
  if (this->interlockCheck != NULL) {
    delete this->interlockCheck;
    this->interlockCheck = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::CheckConditions copy()
 ******************************************************************/
void openfmb::commonmodule::CheckConditions::copy( const CheckConditions * copy_from )
{

  CheckConditions * copy_to = this;

  if ( ! copy_from ) return;


  /* copy synchroCheck */
  if (copy_from->synchroCheck) {
    copy_to->synchroCheck = (unsigned char*)new unsigned char();
    (*copy_to->synchroCheck) = (*copy_from->synchroCheck);
  }
  else
    copy_to->synchroCheck = NULL;

  /* copy interlockCheck */
  if (copy_from->interlockCheck) {
    copy_to->interlockCheck = (unsigned char*)new unsigned char();
    (*copy_to->interlockCheck) = (*copy_from->interlockCheck);
  }
  else
    copy_to->interlockCheck = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::CheckConditions::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::CheckConditions::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (synchroCheck != NULL) {
          /* (*synchroCheck) */
          offset += 1;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (interlockCheck != NULL) {
          /* (*interlockCheck) */
          offset += 1;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CheckConditions::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::CheckConditions::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x0;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (synchroCheck != NULL) {
              DDS_MARSH_PUT_BYTE(buf, offset, (*synchroCheck));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x1;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (interlockCheck != NULL) {
              DDS_MARSH_PUT_BYTE(buf, offset, (*interlockCheck));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x0;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (synchroCheck != NULL) {
              DDS_MARSH_PUT_BYTE(buf, offset, (*synchroCheck));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x1;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (interlockCheck != NULL) {
              DDS_MARSH_PUT_BYTE(buf, offset, (*interlockCheck));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CheckConditions::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::CheckConditions::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CheckConditions::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::CheckConditions::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                synchroCheck = (unsigned char*)new unsigned char();
                DDS_MARSH_GET_BYTE(buf, offset, (*synchroCheck), stream_len);
              }
              else {
                synchroCheck = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                interlockCheck = (unsigned char*)new unsigned char();
                DDS_MARSH_GET_BYTE(buf, offset, (*interlockCheck), stream_len);
              }
              else {
                interlockCheck = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                synchroCheck = (unsigned char*)new unsigned char();
                DDS_MARSH_GET_BYTE(buf, offset, (*synchroCheck), stream_len);
              }
              else {
                synchroCheck = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                interlockCheck = (unsigned char*)new unsigned char();
                DDS_MARSH_GET_BYTE(buf, offset, (*interlockCheck), stream_len);
              }
              else {
                interlockCheck = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CheckConditions::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::CheckConditions::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CheckConditions get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::CheckConditions::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("synchroCheck", fieldname)==0) {
    field_def->kind       = 71;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::CheckConditions,synchroCheck);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::CheckConditions,synchroCheck);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("interlockCheck", fieldname)==0) {
    field_def->kind       = 71;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::CheckConditions,interlockCheck);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::CheckConditions,interlockCheck);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlDPC Default Constructor
 ******************************************************************/
openfmb::commonmodule::ControlDPC::ControlDPC()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ControlDPC Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ControlDPC::ControlDPC( const ControlDPC & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ControlDPC Destructor
 ******************************************************************/
openfmb::commonmodule::ControlDPC::~ControlDPC()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ControlDPC Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ControlDPC& openfmb::commonmodule::ControlDPC::operator=( const openfmb::commonmodule::ControlDPC & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ControlDPC Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ControlDPC init()
 ******************************************************************/
void openfmb::commonmodule::ControlDPC::init()
{
  this->ctlVal = 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlDPC clear()
 ******************************************************************/
void openfmb::commonmodule::ControlDPC::clear()
{
  /* clear basic type: this->ctlVal NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::ControlDPC copy()
 ******************************************************************/
void openfmb::commonmodule::ControlDPC::copy( const ControlDPC * copy_from )
{

  ControlDPC * copy_to = this;

  if ( ! copy_from ) return;


  /* copy ctlVal */
  copy_to->ctlVal = copy_from->ctlVal;

}

/******************************************************************
 *  openfmb::commonmodule::ControlDPC::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ControlDPC::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* ctlVal */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlDPC::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlDPC::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, ctlVal);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, ctlVal);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlDPC::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlDPC::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlDPC::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlDPC::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, ctlVal, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, ctlVal, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlDPC::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlDPC::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlDPC get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ControlDPC::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("ctlVal", fieldname)==0) {
    field_def->kind       = 7;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ControlDPC,ctlVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ControlDPC,ctlVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::DateTimeInterval Default Constructor
 ******************************************************************/
openfmb::commonmodule::DateTimeInterval::DateTimeInterval()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::DateTimeInterval Copy Constructor
 ******************************************************************/
openfmb::commonmodule::DateTimeInterval::DateTimeInterval( const DateTimeInterval & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::DateTimeInterval Destructor
 ******************************************************************/
openfmb::commonmodule::DateTimeInterval::~DateTimeInterval()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::DateTimeInterval Assignment Operator
 ******************************************************************/
openfmb::commonmodule::DateTimeInterval& openfmb::commonmodule::DateTimeInterval::operator=( const openfmb::commonmodule::DateTimeInterval & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::DateTimeInterval Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::DateTimeInterval init()
 ******************************************************************/
void openfmb::commonmodule::DateTimeInterval::init()
{
  this->end = NULL;
  this->start = NULL;
}

/******************************************************************
 * openfmb::commonmodule::DateTimeInterval clear()
 ******************************************************************/
void openfmb::commonmodule::DateTimeInterval::clear()
{
  if (this->end != NULL) {
    delete this->end;
    this->end = NULL;
  }
  if (this->start != NULL) {
    delete this->start;
    this->start = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::DateTimeInterval copy()
 ******************************************************************/
void openfmb::commonmodule::DateTimeInterval::copy( const DateTimeInterval * copy_from )
{

  DateTimeInterval * copy_to = this;

  if ( ! copy_from ) return;


  /* copy end */
  if (copy_from->end) {
    copy_to->end = (UML_Extension::dateTime*)new UML_Extension::dateTime();
    (*copy_to->end) = (*copy_from->end);
  }
  else
    copy_to->end = NULL;

  /* copy start */
  if (copy_from->start) {
    copy_to->start = (UML_Extension::dateTime*)new UML_Extension::dateTime();
    (*copy_to->start) = (*copy_from->start);
  }
  else
    copy_to->start = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::DateTimeInterval::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::DateTimeInterval::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (end != NULL) {
          /* (*end) */
          offset = (offset+7) & 0xfffffff8; /* align 8*/
          offset += 8;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (start != NULL) {
          /* (*start) */
          offset = (offset+7) & 0xfffffff8; /* align 8*/
          offset += 8;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DateTimeInterval::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::DateTimeInterval::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (end != NULL) {
              DDS_MARSH_PUT_LONGLONG_AND_REORDER(buf, offset, (*end));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (start != NULL) {
              DDS_MARSH_PUT_LONGLONG_AND_REORDER(buf, offset, (*start));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (end != NULL) {
              DDS_MARSH_PUT_LONGLONG(buf, offset, (*end));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (start != NULL) {
              DDS_MARSH_PUT_LONGLONG(buf, offset, (*start));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DateTimeInterval::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::DateTimeInterval::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DateTimeInterval::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::DateTimeInterval::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                end = (UML_Extension::dateTime*)new UML_Extension::dateTime();
                DDS_MARSH_GET_LONGLONG_AND_REORDER(buf, offset, (*end), stream_len);
              }
              else {
                end = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                start = (UML_Extension::dateTime*)new UML_Extension::dateTime();
                DDS_MARSH_GET_LONGLONG_AND_REORDER(buf, offset, (*start), stream_len);
              }
              else {
                start = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                end = (UML_Extension::dateTime*)new UML_Extension::dateTime();
                DDS_MARSH_GET_LONGLONG(buf, offset, (*end), stream_len);
              }
              else {
                end = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                start = (UML_Extension::dateTime*)new UML_Extension::dateTime();
                DDS_MARSH_GET_LONGLONG(buf, offset, (*start), stream_len);
              }
              else {
                start = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DateTimeInterval::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::DateTimeInterval::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DateTimeInterval get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::DateTimeInterval::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("end", fieldname)==0) {
    field_def->kind       = 81;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::DateTimeInterval,end);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::DateTimeInterval,end);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("start", fieldname)==0) {
    field_def->kind       = 81;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::DateTimeInterval,start);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::DateTimeInterval,start);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ENC_SolarControlKind Default Constructor
 ******************************************************************/
openfmb::commonmodule::ENC_SolarControlKind::ENC_SolarControlKind()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ENC_SolarControlKind Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ENC_SolarControlKind::ENC_SolarControlKind( const ENC_SolarControlKind & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ENC_SolarControlKind Destructor
 ******************************************************************/
openfmb::commonmodule::ENC_SolarControlKind::~ENC_SolarControlKind()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ENC_SolarControlKind Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ENC_SolarControlKind& openfmb::commonmodule::ENC_SolarControlKind::operator=( const openfmb::commonmodule::ENC_SolarControlKind & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ENC_SolarControlKind Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ENC_SolarControlKind init()
 ******************************************************************/
void openfmb::commonmodule::ENC_SolarControlKind::init()
{
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
  this->ctlVal = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ENC_SolarControlKind clear()
 ******************************************************************/
void openfmb::commonmodule::ENC_SolarControlKind::clear()
{
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
  if (this->ctlVal != NULL) {
    delete this->ctlVal;
    this->ctlVal = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ENC_SolarControlKind copy()
 ******************************************************************/
void openfmb::commonmodule::ENC_SolarControlKind::copy( const ENC_SolarControlKind * copy_from )
{

  ENC_SolarControlKind * copy_to = this;

  if ( ! copy_from ) return;


  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

  /* copy ctlVal */
  if (copy_from->ctlVal) {
    copy_to->ctlVal = (enum openfmb::commonmodule::SolarControlKind *)new enum openfmb::commonmodule::SolarControlKind ();
    (*copy_to->ctlVal) = (*copy_from->ctlVal);
  }
  else
    copy_to->ctlVal = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::ENC_SolarControlKind::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ENC_SolarControlKind::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* q */
      offset += 2;
      /* t */
      offset += 8;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (ctlVal != NULL) {
          /* (*ctlVal) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENC_SolarControlKind::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENC_SolarControlKind::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x2;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ctlVal != NULL) {
              DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, (*ctlVal), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x2;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ctlVal != NULL) {
              DDS_MARSH_PUT_ENUM(buf, offset, (*ctlVal), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENC_SolarControlKind::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENC_SolarControlKind::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENC_SolarControlKind::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENC_SolarControlKind::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ctlVal = (enum openfmb::commonmodule::SolarControlKind *)new enum openfmb::commonmodule::SolarControlKind ();
                DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, (*ctlVal), 4, openfmb::commonmodule::SolarControlKind, stream_len);
              }
              else {
                ctlVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ctlVal = (enum openfmb::commonmodule::SolarControlKind *)new enum openfmb::commonmodule::SolarControlKind ();
                DDS_MARSH_GET_ENUM(buf, offset, (*ctlVal), 4, openfmb::commonmodule::SolarControlKind, stream_len);
              }
              else {
                ctlVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENC_SolarControlKind::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENC_SolarControlKind::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENC_SolarControlKind get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ENC_SolarControlKind::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENC_SolarControlKind,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENC_SolarControlKind,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENC_SolarControlKind,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENC_SolarControlKind,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("ctlVal", fieldname)==0) {
    field_def->kind       = 76;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENC_SolarControlKind,ctlVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENC_SolarControlKind,ctlVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ENG_CalcMethodKind Default Constructor
 ******************************************************************/
openfmb::commonmodule::ENG_CalcMethodKind::ENG_CalcMethodKind()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ENG_CalcMethodKind Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ENG_CalcMethodKind::ENG_CalcMethodKind( const ENG_CalcMethodKind & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ENG_CalcMethodKind Destructor
 ******************************************************************/
openfmb::commonmodule::ENG_CalcMethodKind::~ENG_CalcMethodKind()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ENG_CalcMethodKind Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ENG_CalcMethodKind& openfmb::commonmodule::ENG_CalcMethodKind::operator=( const openfmb::commonmodule::ENG_CalcMethodKind & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ENG_CalcMethodKind Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ENG_CalcMethodKind init()
 ******************************************************************/
void openfmb::commonmodule::ENG_CalcMethodKind::init()
{
  this->setVal = openfmb::commonmodule::CalcMethodKind_P_CLASS;
}

/******************************************************************
 * openfmb::commonmodule::ENG_CalcMethodKind clear()
 ******************************************************************/
void openfmb::commonmodule::ENG_CalcMethodKind::clear()
{
  /* clear enum: this->setVal */
}

/******************************************************************
 *  openfmb::commonmodule::ENG_CalcMethodKind copy()
 ******************************************************************/
void openfmb::commonmodule::ENG_CalcMethodKind::copy( const ENG_CalcMethodKind * copy_from )
{

  ENG_CalcMethodKind * copy_to = this;

  if ( ! copy_from ) return;


  /* copy setVal */
  copy_to->setVal = copy_from->setVal;

}

/******************************************************************
 *  openfmb::commonmodule::ENG_CalcMethodKind::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ENG_CalcMethodKind::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* setVal */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_CalcMethodKind::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENG_CalcMethodKind::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, setVal, 4);
        }
      else
        {
          DDS_MARSH_PUT_ENUM(buf, offset, setVal, 4);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_CalcMethodKind::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENG_CalcMethodKind::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_CalcMethodKind::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENG_CalcMethodKind::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, setVal, 4, openfmb::commonmodule::CalcMethodKind, stream_len);
        }
       else
        {
          DDS_MARSH_GET_ENUM(buf, offset, setVal, 4, openfmb::commonmodule::CalcMethodKind, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_CalcMethodKind::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENG_CalcMethodKind::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_CalcMethodKind get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ENG_CalcMethodKind::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("setVal", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENG_CalcMethodKind,setVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENG_CalcMethodKind,setVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ENG_GridConnectModeKind Default Constructor
 ******************************************************************/
openfmb::commonmodule::ENG_GridConnectModeKind::ENG_GridConnectModeKind()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ENG_GridConnectModeKind Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ENG_GridConnectModeKind::ENG_GridConnectModeKind( const ENG_GridConnectModeKind & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ENG_GridConnectModeKind Destructor
 ******************************************************************/
openfmb::commonmodule::ENG_GridConnectModeKind::~ENG_GridConnectModeKind()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ENG_GridConnectModeKind Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ENG_GridConnectModeKind& openfmb::commonmodule::ENG_GridConnectModeKind::operator=( const openfmb::commonmodule::ENG_GridConnectModeKind & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ENG_GridConnectModeKind Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ENG_GridConnectModeKind init()
 ******************************************************************/
void openfmb::commonmodule::ENG_GridConnectModeKind::init()
{
  this->setVal = openfmb::commonmodule::GridConnectModeKind_CSI;
  this->setValExtension = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ENG_GridConnectModeKind clear()
 ******************************************************************/
void openfmb::commonmodule::ENG_GridConnectModeKind::clear()
{
  /* clear enum: this->setVal */
  /* clear string: this->setValExtension */
  if (this->setValExtension != NULL) {
    delete[] this->setValExtension;
    this->setValExtension = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ENG_GridConnectModeKind copy()
 ******************************************************************/
void openfmb::commonmodule::ENG_GridConnectModeKind::copy( const ENG_GridConnectModeKind * copy_from )
{

  ENG_GridConnectModeKind * copy_to = this;

  if ( ! copy_from ) return;


  /* copy setVal */
  copy_to->setVal = copy_from->setVal;

  /* copy setValExtension */
  if (copy_from->setValExtension) {
    copy_to->setValExtension = new char[strlen(copy_from->setValExtension) + 1];
    strcpy( copy_to->setValExtension, copy_from->setValExtension );
  }

}

/******************************************************************
 *  openfmb::commonmodule::ENG_GridConnectModeKind::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ENG_GridConnectModeKind::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* setVal */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
      /* setValExtension */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (setValExtension==NULL)?1:(unsigned int)((strlen(setValExtension)+1)*1);
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_GridConnectModeKind::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENG_GridConnectModeKind::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, setVal, 4);
          { int len = 1;
          if ( setValExtension ) len += (int)strlen( setValExtension );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, setValExtension, len);
          }
        }
      else
        {
          DDS_MARSH_PUT_ENUM(buf, offset, setVal, 4);
          { int len = 1;
          if ( setValExtension ) len += (int)strlen( setValExtension );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, setValExtension, len);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_GridConnectModeKind::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENG_GridConnectModeKind::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_GridConnectModeKind::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENG_GridConnectModeKind::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, setVal, 4, openfmb::commonmodule::GridConnectModeKind, stream_len);
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          setValExtension = new char[len];
          DDS_MARSH_GET_STR(buf, offset, setValExtension, len, stream_len);
          }
        }
       else
        {
          DDS_MARSH_GET_ENUM(buf, offset, setVal, 4, openfmb::commonmodule::GridConnectModeKind, stream_len);
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          setValExtension = new char[len];
          DDS_MARSH_GET_STR(buf, offset, setValExtension, len, stream_len);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_GridConnectModeKind::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENG_GridConnectModeKind::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENG_GridConnectModeKind get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ENG_GridConnectModeKind::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("setVal", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENG_GridConnectModeKind,setVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENG_GridConnectModeKind,setVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("setValExtension", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENG_GridConnectModeKind,setValExtension);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENG_GridConnectModeKind,setValExtension);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ENS_BehaviourModeKind Default Constructor
 ******************************************************************/
openfmb::commonmodule::ENS_BehaviourModeKind::ENS_BehaviourModeKind()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ENS_BehaviourModeKind Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ENS_BehaviourModeKind::ENS_BehaviourModeKind( const ENS_BehaviourModeKind & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ENS_BehaviourModeKind Destructor
 ******************************************************************/
openfmb::commonmodule::ENS_BehaviourModeKind::~ENS_BehaviourModeKind()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ENS_BehaviourModeKind Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ENS_BehaviourModeKind& openfmb::commonmodule::ENS_BehaviourModeKind::operator=( const openfmb::commonmodule::ENS_BehaviourModeKind & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ENS_BehaviourModeKind Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ENS_BehaviourModeKind init()
 ******************************************************************/
void openfmb::commonmodule::ENS_BehaviourModeKind::init()
{
  this->stVal = openfmb::commonmodule::BehaviourModeKind_on;
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
}

/******************************************************************
 * openfmb::commonmodule::ENS_BehaviourModeKind clear()
 ******************************************************************/
void openfmb::commonmodule::ENS_BehaviourModeKind::clear()
{
  /* clear enum: this->stVal */
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
}

/******************************************************************
 *  openfmb::commonmodule::ENS_BehaviourModeKind copy()
 ******************************************************************/
void openfmb::commonmodule::ENS_BehaviourModeKind::copy( const ENS_BehaviourModeKind * copy_from )
{

  ENS_BehaviourModeKind * copy_to = this;

  if ( ! copy_from ) return;


  /* copy stVal */
  copy_to->stVal = copy_from->stVal;

  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

}

/******************************************************************
 *  openfmb::commonmodule::ENS_BehaviourModeKind::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ENS_BehaviourModeKind::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* stVal */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
      /* q */
      offset += 2;
      /* t */
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_BehaviourModeKind::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENS_BehaviourModeKind::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, stVal, 4);
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
      else
        {
          DDS_MARSH_PUT_ENUM(buf, offset, stVal, 4);
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_BehaviourModeKind::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENS_BehaviourModeKind::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_BehaviourModeKind::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENS_BehaviourModeKind::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, stVal, 4, openfmb::commonmodule::BehaviourModeKind, stream_len);
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
       else
        {
          DDS_MARSH_GET_ENUM(buf, offset, stVal, 4, openfmb::commonmodule::BehaviourModeKind, stream_len);
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_BehaviourModeKind::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENS_BehaviourModeKind::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_BehaviourModeKind get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ENS_BehaviourModeKind::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("stVal", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_BehaviourModeKind,stVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_BehaviourModeKind,stVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_BehaviourModeKind,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_BehaviourModeKind,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_BehaviourModeKind,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_BehaviourModeKind,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ENS_DERGeneratorStateKind Default Constructor
 ******************************************************************/
openfmb::commonmodule::ENS_DERGeneratorStateKind::ENS_DERGeneratorStateKind()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ENS_DERGeneratorStateKind Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ENS_DERGeneratorStateKind::ENS_DERGeneratorStateKind( const ENS_DERGeneratorStateKind & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ENS_DERGeneratorStateKind Destructor
 ******************************************************************/
openfmb::commonmodule::ENS_DERGeneratorStateKind::~ENS_DERGeneratorStateKind()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ENS_DERGeneratorStateKind Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ENS_DERGeneratorStateKind& openfmb::commonmodule::ENS_DERGeneratorStateKind::operator=( const openfmb::commonmodule::ENS_DERGeneratorStateKind & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ENS_DERGeneratorStateKind Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ENS_DERGeneratorStateKind init()
 ******************************************************************/
void openfmb::commonmodule::ENS_DERGeneratorStateKind::init()
{
  this->stVal = openfmb::commonmodule::DERGeneratorStateKind_Not_operating;
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
}

/******************************************************************
 * openfmb::commonmodule::ENS_DERGeneratorStateKind clear()
 ******************************************************************/
void openfmb::commonmodule::ENS_DERGeneratorStateKind::clear()
{
  /* clear enum: this->stVal */
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
}

/******************************************************************
 *  openfmb::commonmodule::ENS_DERGeneratorStateKind copy()
 ******************************************************************/
void openfmb::commonmodule::ENS_DERGeneratorStateKind::copy( const ENS_DERGeneratorStateKind * copy_from )
{

  ENS_DERGeneratorStateKind * copy_to = this;

  if ( ! copy_from ) return;


  /* copy stVal */
  copy_to->stVal = copy_from->stVal;

  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

}

/******************************************************************
 *  openfmb::commonmodule::ENS_DERGeneratorStateKind::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ENS_DERGeneratorStateKind::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* stVal */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
      /* q */
      offset += 2;
      /* t */
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_DERGeneratorStateKind::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENS_DERGeneratorStateKind::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, stVal, 4);
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
      else
        {
          DDS_MARSH_PUT_ENUM(buf, offset, stVal, 4);
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_DERGeneratorStateKind::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENS_DERGeneratorStateKind::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_DERGeneratorStateKind::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENS_DERGeneratorStateKind::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, stVal, 4, openfmb::commonmodule::DERGeneratorStateKind, stream_len);
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
       else
        {
          DDS_MARSH_GET_ENUM(buf, offset, stVal, 4, openfmb::commonmodule::DERGeneratorStateKind, stream_len);
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_DERGeneratorStateKind::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENS_DERGeneratorStateKind::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_DERGeneratorStateKind get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ENS_DERGeneratorStateKind::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("stVal", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_DERGeneratorStateKind,stVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_DERGeneratorStateKind,stVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_DERGeneratorStateKind,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_DERGeneratorStateKind,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_DERGeneratorStateKind,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_DERGeneratorStateKind,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ENS_SolarStateKind Default Constructor
 ******************************************************************/
openfmb::commonmodule::ENS_SolarStateKind::ENS_SolarStateKind()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ENS_SolarStateKind Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ENS_SolarStateKind::ENS_SolarStateKind( const ENS_SolarStateKind & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ENS_SolarStateKind Destructor
 ******************************************************************/
openfmb::commonmodule::ENS_SolarStateKind::~ENS_SolarStateKind()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ENS_SolarStateKind Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ENS_SolarStateKind& openfmb::commonmodule::ENS_SolarStateKind::operator=( const openfmb::commonmodule::ENS_SolarStateKind & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ENS_SolarStateKind Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ENS_SolarStateKind init()
 ******************************************************************/
void openfmb::commonmodule::ENS_SolarStateKind::init()
{
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
  this->stVal = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ENS_SolarStateKind clear()
 ******************************************************************/
void openfmb::commonmodule::ENS_SolarStateKind::clear()
{
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
  if (this->stVal != NULL) {
    delete this->stVal;
    this->stVal = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ENS_SolarStateKind copy()
 ******************************************************************/
void openfmb::commonmodule::ENS_SolarStateKind::copy( const ENS_SolarStateKind * copy_from )
{

  ENS_SolarStateKind * copy_to = this;

  if ( ! copy_from ) return;


  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

  /* copy stVal */
  if (copy_from->stVal) {
    copy_to->stVal = (enum openfmb::commonmodule::SolarStateKind *)new enum openfmb::commonmodule::SolarStateKind ();
    (*copy_to->stVal) = (*copy_from->stVal);
  }
  else
    copy_to->stVal = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::ENS_SolarStateKind::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ENS_SolarStateKind::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* q */
      offset += 2;
      /* t */
      offset += 8;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (stVal != NULL) {
          /* (*stVal) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_SolarStateKind::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENS_SolarStateKind::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x2;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (stVal != NULL) {
              DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, (*stVal), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x2;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (stVal != NULL) {
              DDS_MARSH_PUT_ENUM(buf, offset, (*stVal), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_SolarStateKind::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENS_SolarStateKind::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_SolarStateKind::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ENS_SolarStateKind::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                stVal = (enum openfmb::commonmodule::SolarStateKind *)new enum openfmb::commonmodule::SolarStateKind ();
                DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, (*stVal), 4, openfmb::commonmodule::SolarStateKind, stream_len);
              }
              else {
                stVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                stVal = (enum openfmb::commonmodule::SolarStateKind *)new enum openfmb::commonmodule::SolarStateKind ();
                DDS_MARSH_GET_ENUM(buf, offset, (*stVal), 4, openfmb::commonmodule::SolarStateKind, stream_len);
              }
              else {
                stVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_SolarStateKind::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ENS_SolarStateKind::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ENS_SolarStateKind get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ENS_SolarStateKind::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_SolarStateKind,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_SolarStateKind,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_SolarStateKind,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_SolarStateKind,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("stVal", fieldname)==0) {
    field_def->kind       = 76;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ENS_SolarStateKind,stVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ENS_SolarStateKind,stVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::IdentifiedObject Default Constructor
 ******************************************************************/
openfmb::commonmodule::IdentifiedObject::IdentifiedObject()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::IdentifiedObject Copy Constructor
 ******************************************************************/
openfmb::commonmodule::IdentifiedObject::IdentifiedObject( const IdentifiedObject & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::IdentifiedObject Destructor
 ******************************************************************/
openfmb::commonmodule::IdentifiedObject::~IdentifiedObject()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::IdentifiedObject Assignment Operator
 ******************************************************************/
openfmb::commonmodule::IdentifiedObject& openfmb::commonmodule::IdentifiedObject::operator=( const openfmb::commonmodule::IdentifiedObject & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::IdentifiedObject Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::IdentifiedObject init()
 ******************************************************************/
void openfmb::commonmodule::IdentifiedObject::init()
{
  this->mRID = NULL;
  this->description = NULL;
  this->name = NULL;
}

/******************************************************************
 * openfmb::commonmodule::IdentifiedObject clear()
 ******************************************************************/
void openfmb::commonmodule::IdentifiedObject::clear()
{
  /* clear string: this->mRID */
  if (this->mRID != NULL) {
    delete[] this->mRID;
    this->mRID = NULL;
  }
  /* clear string: this->description */
  if (this->description != NULL) {
    delete[] this->description;
    this->description = NULL;
  }
  /* clear string: this->name */
  if (this->name != NULL) {
    delete[] this->name;
    this->name = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::IdentifiedObject copy()
 ******************************************************************/
void openfmb::commonmodule::IdentifiedObject::copy( const IdentifiedObject * copy_from )
{

  IdentifiedObject * copy_to = this;

  if ( ! copy_from ) return;


  /* copy mRID */
  if (copy_from->mRID) {
    if (copy_from->mRID) {
      copy_to->mRID = new char[strlen(copy_from->mRID) + 1];
      strcpy( copy_to->mRID, copy_from->mRID );
    }
  }
  else
    copy_to->mRID = NULL;

  /* copy description */
  if (copy_from->description) {
    if (copy_from->description) {
      copy_to->description = new char[strlen(copy_from->description) + 1];
      strcpy( copy_to->description, copy_from->description );
    }
  }
  else
    copy_to->description = NULL;

  /* copy name */
  if (copy_from->name) {
    if (copy_from->name) {
      copy_to->name = new char[strlen(copy_from->name) + 1];
      strcpy( copy_to->name, copy_from->name );
    }
  }
  else
    copy_to->name = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::IdentifiedObject::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::IdentifiedObject::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (mRID != NULL) {
          /* mRID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (mRID==NULL)?1:(unsigned int)((strlen(mRID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (description != NULL) {
          /* description */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (description==NULL)?1:(unsigned int)((strlen(description)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (name != NULL) {
          /* name */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (name==NULL)?1:(unsigned int)((strlen(name)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::IdentifiedObject::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::IdentifiedObject::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (mRID != NULL) {
              { int len = 1;
              if ( mRID ) len += (int)strlen( mRID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, mRID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (description != NULL) {
              { int len = 1;
              if ( description ) len += (int)strlen( description );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, description, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (name != NULL) {
              { int len = 1;
              if ( name ) len += (int)strlen( name );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, name, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (mRID != NULL) {
              { int len = 1;
              if ( mRID ) len += (int)strlen( mRID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, mRID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (description != NULL) {
              { int len = 1;
              if ( description ) len += (int)strlen( description );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, description, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (name != NULL) {
              { int len = 1;
              if ( name ) len += (int)strlen( name );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, name, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::IdentifiedObject::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::IdentifiedObject::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::IdentifiedObject::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::IdentifiedObject::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                mRID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, mRID, len, stream_len);
                }
              }
              else {
                mRID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                description = new char[len];
                DDS_MARSH_GET_STR(buf, offset, description, len, stream_len);
                }
              }
              else {
                description = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                name = new char[len];
                DDS_MARSH_GET_STR(buf, offset, name, len, stream_len);
                }
              }
              else {
                name = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                mRID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, mRID, len, stream_len);
                }
              }
              else {
                mRID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                description = new char[len];
                DDS_MARSH_GET_STR(buf, offset, description, len, stream_len);
                }
              }
              else {
                description = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                name = new char[len];
                DDS_MARSH_GET_STR(buf, offset, name, len, stream_len);
                }
              }
              else {
                name = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::IdentifiedObject::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::IdentifiedObject::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::IdentifiedObject get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::IdentifiedObject::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("mRID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::IdentifiedObject,mRID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::IdentifiedObject,mRID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("description", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::IdentifiedObject,description);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::IdentifiedObject,description);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("name", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::IdentifiedObject,name);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::IdentifiedObject,name);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::LogicalNode Default Constructor
 ******************************************************************/
openfmb::commonmodule::LogicalNode::LogicalNode()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::LogicalNode Copy Constructor
 ******************************************************************/
openfmb::commonmodule::LogicalNode::LogicalNode( const LogicalNode & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::LogicalNode Destructor
 ******************************************************************/
openfmb::commonmodule::LogicalNode::~LogicalNode()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::LogicalNode Assignment Operator
 ******************************************************************/
openfmb::commonmodule::LogicalNode& openfmb::commonmodule::LogicalNode::operator=( const openfmb::commonmodule::LogicalNode & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::LogicalNode Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::LogicalNode init()
 ******************************************************************/
void openfmb::commonmodule::LogicalNode::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_LogicalNode = 0;
}

/******************************************************************
 * openfmb::commonmodule::LogicalNode clear()
 ******************************************************************/
void openfmb::commonmodule::LogicalNode::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_LogicalNode NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNode copy()
 ******************************************************************/
void openfmb::commonmodule::LogicalNode::copy( const LogicalNode * copy_from )
{

  LogicalNode * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_LogicalNode */
  copy_to->__dummy_prevent_empty_class_LogicalNode = copy_from->__dummy_prevent_empty_class_LogicalNode;

}

/******************************************************************
 *  openfmb::commonmodule::LogicalNode::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::LogicalNode::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_LogicalNode */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNode::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::LogicalNode::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNode);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNode);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNode::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::LogicalNode::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNode::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::LogicalNode::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNode, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNode, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNode::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::LogicalNode::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNode get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::LogicalNode::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_LogicalNode", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::LogicalNode,__dummy_prevent_empty_class_LogicalNode);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::LogicalNode,__dummy_prevent_empty_class_LogicalNode);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForControl Default Constructor
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForControl::LogicalNodeForControl()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForControl Copy Constructor
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForControl::LogicalNodeForControl( const LogicalNodeForControl & other )
  : LogicalNode()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForControl Destructor
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForControl::~LogicalNodeForControl()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForControl Assignment Operator
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForControl& openfmb::commonmodule::LogicalNodeForControl::operator=( const openfmb::commonmodule::LogicalNodeForControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::LogicalNodeForControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::LogicalNodeForControl init()
 ******************************************************************/
void openfmb::commonmodule::LogicalNodeForControl::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::init();
  this->__dummy_prevent_empty_class_LogicalNodeForControl = 0;
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForControl clear()
 ******************************************************************/
void openfmb::commonmodule::LogicalNodeForControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_LogicalNodeForControl NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForControl copy()
 ******************************************************************/
void openfmb::commonmodule::LogicalNodeForControl::copy( const LogicalNodeForControl * copy_from )
{

  LogicalNodeForControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::copy( copy_from );
  /* copy __dummy_prevent_empty_class_LogicalNodeForControl */
  copy_to->__dummy_prevent_empty_class_LogicalNodeForControl = copy_from->__dummy_prevent_empty_class_LogicalNodeForControl;

}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForControl::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_LogicalNodeForControl */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForControl::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNode::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNodeForControl);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNodeForControl);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForControl::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNodeForControl, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LogicalNodeForControl, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::LogicalNodeForControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNode::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_LogicalNodeForControl", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::LogicalNodeForControl,__dummy_prevent_empty_class_LogicalNodeForControl);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::LogicalNodeForControl,__dummy_prevent_empty_class_LogicalNodeForControl);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForEventAndStatus Default Constructor
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForEventAndStatus::LogicalNodeForEventAndStatus()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForEventAndStatus Copy Constructor
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForEventAndStatus::LogicalNodeForEventAndStatus( const LogicalNodeForEventAndStatus & other )
  : LogicalNode()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForEventAndStatus Destructor
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForEventAndStatus::~LogicalNodeForEventAndStatus()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForEventAndStatus Assignment Operator
 ******************************************************************/
openfmb::commonmodule::LogicalNodeForEventAndStatus& openfmb::commonmodule::LogicalNodeForEventAndStatus::operator=( const openfmb::commonmodule::LogicalNodeForEventAndStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::LogicalNodeForEventAndStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::LogicalNodeForEventAndStatus init()
 ******************************************************************/
void openfmb::commonmodule::LogicalNodeForEventAndStatus::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::init();
}

/******************************************************************
 * openfmb::commonmodule::LogicalNodeForEventAndStatus clear()
 ******************************************************************/
void openfmb::commonmodule::LogicalNodeForEventAndStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::clear();
  /* clear struct: this->Beh */
  this->Beh.clear( );
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForEventAndStatus copy()
 ******************************************************************/
void openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( const LogicalNodeForEventAndStatus * copy_from )
{

  LogicalNodeForEventAndStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::copy( copy_from );
  /* copy Beh */
  copy_to->Beh.copy( &copy_from->Beh );

}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
      offset = Beh.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNode::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = Beh.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = Beh.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = Beh.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = Beh.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::LogicalNodeForEventAndStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNode::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Beh", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::LogicalNodeForEventAndStatus,Beh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::ENS_BehaviourModeKind::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValue Default Constructor
 ******************************************************************/
openfmb::commonmodule::MeasurementValue::MeasurementValue()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValue Copy Constructor
 ******************************************************************/
openfmb::commonmodule::MeasurementValue::MeasurementValue( const MeasurementValue & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValue Destructor
 ******************************************************************/
openfmb::commonmodule::MeasurementValue::~MeasurementValue()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValue Assignment Operator
 ******************************************************************/
openfmb::commonmodule::MeasurementValue& openfmb::commonmodule::MeasurementValue::operator=( const openfmb::commonmodule::MeasurementValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::MeasurementValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::MeasurementValue init()
 ******************************************************************/
void openfmb::commonmodule::MeasurementValue::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_MeasurementValue = 0;
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValue clear()
 ******************************************************************/
void openfmb::commonmodule::MeasurementValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_MeasurementValue NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValue copy()
 ******************************************************************/
void openfmb::commonmodule::MeasurementValue::copy( const MeasurementValue * copy_from )
{

  MeasurementValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_MeasurementValue */
  copy_to->__dummy_prevent_empty_class_MeasurementValue = copy_from->__dummy_prevent_empty_class_MeasurementValue;

}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValue::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_MeasurementValue */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValue::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValue);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValue);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValue::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValue, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValue, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::MeasurementValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_MeasurementValue", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::MeasurementValue,__dummy_prevent_empty_class_MeasurementValue);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::MeasurementValue,__dummy_prevent_empty_class_MeasurementValue);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValueSource Default Constructor
 ******************************************************************/
openfmb::commonmodule::MeasurementValueSource::MeasurementValueSource()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValueSource Copy Constructor
 ******************************************************************/
openfmb::commonmodule::MeasurementValueSource::MeasurementValueSource( const MeasurementValueSource & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValueSource Destructor
 ******************************************************************/
openfmb::commonmodule::MeasurementValueSource::~MeasurementValueSource()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValueSource Assignment Operator
 ******************************************************************/
openfmb::commonmodule::MeasurementValueSource& openfmb::commonmodule::MeasurementValueSource::operator=( const openfmb::commonmodule::MeasurementValueSource & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::MeasurementValueSource Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::MeasurementValueSource init()
 ******************************************************************/
void openfmb::commonmodule::MeasurementValueSource::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_MeasurementValueSource = 0;
}

/******************************************************************
 * openfmb::commonmodule::MeasurementValueSource clear()
 ******************************************************************/
void openfmb::commonmodule::MeasurementValueSource::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_MeasurementValueSource NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValueSource copy()
 ******************************************************************/
void openfmb::commonmodule::MeasurementValueSource::copy( const MeasurementValueSource * copy_from )
{

  MeasurementValueSource * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_MeasurementValueSource */
  copy_to->__dummy_prevent_empty_class_MeasurementValueSource = copy_from->__dummy_prevent_empty_class_MeasurementValueSource;

}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValueSource::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValueSource::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_MeasurementValueSource */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValueSource::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValueSource::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValueSource);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValueSource);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValueSource::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValueSource::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValueSource::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValueSource::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValueSource, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_MeasurementValueSource, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValueSource::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MeasurementValueSource::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementValueSource get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::MeasurementValueSource::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_MeasurementValueSource", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::MeasurementValueSource,__dummy_prevent_empty_class_MeasurementValueSource);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::MeasurementValueSource,__dummy_prevent_empty_class_MeasurementValueSource);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ORS Default Constructor
 ******************************************************************/
openfmb::commonmodule::ORS::ORS()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ORS Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ORS::ORS( const ORS & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ORS Destructor
 ******************************************************************/
openfmb::commonmodule::ORS::~ORS()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ORS Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ORS& openfmb::commonmodule::ORS::operator=( const openfmb::commonmodule::ORS & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ORS Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ORS init()
 ******************************************************************/
void openfmb::commonmodule::ORS::init()
{
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
}

/******************************************************************
 * openfmb::commonmodule::ORS clear()
 ******************************************************************/
void openfmb::commonmodule::ORS::clear()
{
  /* clear sequence: this->stVal */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->stVal.size(); i_0++)
      {
        /* clear string: this->stVal[i_0] */
        if (this->stVal[i_0] != NULL) {
          delete[] this->stVal[i_0];
          this->stVal[i_0] = NULL;
        }
      }
    this->stVal.clear();
  }
  /* clear array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        /* clear basic type: this->q[i_1] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        /* clear basic type: this->t[i_2] NOOP */
      }
  }
}

/******************************************************************
 *  openfmb::commonmodule::ORS copy()
 ******************************************************************/
void openfmb::commonmodule::ORS::copy( const ORS * copy_from )
{

  ORS * copy_to = this;

  if ( ! copy_from ) return;


  /* copy stVal */
  copy_to->stVal.resize(copy_from->stVal.size());
  if ( copy_from->stVal.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->stVal.size(); i_1++)
        {
          if (copy_from->stVal[i_1]) {
            copy_to->stVal[i_1] = new char[strlen(copy_from->stVal[i_1]) + 1];
            strcpy( copy_to->stVal[i_1], copy_from->stVal[i_1] );
          }
        }
    }

  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

}

/******************************************************************
 *  openfmb::commonmodule::ORS::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ORS::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* stVal*/
      /* stVal.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < stVal.size(); ii1++ ) {
           /* stVal[ii1] */
           offset = (offset+3) & 0xfffffffc;/* align 4 */
           offset += 4;
           offset += (stVal[ii1]==NULL)?1:(unsigned int)((strlen(stVal[ii1])+1)*1);
         }
      }
      /* q */
      offset += 2;
      /* t */
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ORS::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ORS::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* stVal */
          {
            unsigned int sl = (unsigned int)stVal.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < stVal.size(); i1++)
            {
              { int len = 1;
              if ( stVal[i1] ) len += (int)strlen( stVal[i1] );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, stVal[i1], len);
              }
            } 
          }  /* stVal */
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
      else
        {
          /* stVal */
          {
            unsigned int sl = (unsigned int)stVal.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < stVal.size(); i1++)
            {
              { int len = 1;
              if ( stVal[i1] ) len += (int)strlen( stVal[i1] );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, stVal[i1], len);
              }
            } 
          }  /* stVal */
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ORS::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ORS::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ORS::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ORS::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            stVal.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < stVal.capacity(); ii1++)
            {
              { int len;
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
              stVal[ii1] = new char[len];
              DDS_MARSH_GET_STR(buf, offset, stVal[ii1], len, stream_len);
              }
            } 
          }  /* stVal */
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            stVal.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < stVal.capacity(); ii1++)
            {
              { int len;
              DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
              stVal[ii1] = new char[len];
              DDS_MARSH_GET_STR(buf, offset, stVal[ii1], len, stream_len);
              }
            } 
          }  /* stVal */
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ORS::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ORS::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ORS get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ORS::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ORS,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ORS,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ORS,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ORS,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::Point Default Constructor
 ******************************************************************/
openfmb::commonmodule::Point::Point()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::Point Copy Constructor
 ******************************************************************/
openfmb::commonmodule::Point::Point( const Point & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::Point Destructor
 ******************************************************************/
openfmb::commonmodule::Point::~Point()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::Point Assignment Operator
 ******************************************************************/
openfmb::commonmodule::Point& openfmb::commonmodule::Point::operator=( const openfmb::commonmodule::Point & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::Point Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::Point init()
 ******************************************************************/
void openfmb::commonmodule::Point::init()
{
  this->xVal = 0.0;
  this->yVal = 0.0;
  this->zVal = NULL;
}

/******************************************************************
 * openfmb::commonmodule::Point clear()
 ******************************************************************/
void openfmb::commonmodule::Point::clear()
{
  /* clear basic type: this->xVal NOOP */
  /* clear basic type: this->yVal NOOP */
  if (this->zVal != NULL) {
    delete this->zVal;
    this->zVal = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::Point copy()
 ******************************************************************/
void openfmb::commonmodule::Point::copy( const Point * copy_from )
{

  Point * copy_to = this;

  if ( ! copy_from ) return;


  /* copy xVal */
  copy_to->xVal = copy_from->xVal;

  /* copy yVal */
  copy_to->yVal = copy_from->yVal;

  /* copy zVal */
  if (copy_from->zVal) {
    copy_to->zVal = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
    (*copy_to->zVal) = (*copy_from->zVal);
  }
  else
    copy_to->zVal = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::Point::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::Point::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* xVal */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
      /* yVal */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (zVal != NULL) {
          /* (*zVal) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Point::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::Point::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_FLOAT_AND_REORDER(buf, offset, xVal);
          DDS_MARSH_PUT_FLOAT_AND_REORDER(buf, offset, yVal);
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zVal != NULL) {
              DDS_MARSH_PUT_FLOAT_AND_REORDER(buf, offset, (*zVal));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          DDS_MARSH_PUT_FLOAT(buf, offset, xVal);
          DDS_MARSH_PUT_FLOAT(buf, offset, yVal);
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zVal != NULL) {
              DDS_MARSH_PUT_FLOAT(buf, offset, (*zVal));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Point::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::Point::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Point::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::Point::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_FLOAT_AND_REORDER(buf, offset, xVal, stream_len);
          DDS_MARSH_GET_FLOAT_AND_REORDER(buf, offset, yVal, stream_len);
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zVal = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
                DDS_MARSH_GET_FLOAT_AND_REORDER(buf, offset, (*zVal), stream_len);
              }
              else {
                zVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          DDS_MARSH_GET_FLOAT(buf, offset, xVal, stream_len);
          DDS_MARSH_GET_FLOAT(buf, offset, yVal, stream_len);
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zVal = (openfmb::commonmodule::FLOAT32*)new openfmb::commonmodule::FLOAT32();
                DDS_MARSH_GET_FLOAT(buf, offset, (*zVal), stream_len);
              }
              else {
                zVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Point::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::Point::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Point get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::Point::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("xVal", fieldname)==0) {
    field_def->kind       = 5;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::Point,xVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::Point,xVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("yVal", fieldname)==0) {
    field_def->kind       = 5;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::Point,yVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::Point,yVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("zVal", fieldname)==0) {
    field_def->kind       = 69;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::Point,zVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::Point,zVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMTR Default Constructor
 ******************************************************************/
openfmb::commonmodule::ReadingMMTR::ReadingMMTR()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMTR Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ReadingMMTR::ReadingMMTR( const ReadingMMTR & other )
  : LogicalNode()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMTR Destructor
 ******************************************************************/
openfmb::commonmodule::ReadingMMTR::~ReadingMMTR()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMTR Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ReadingMMTR& openfmb::commonmodule::ReadingMMTR::operator=( const openfmb::commonmodule::ReadingMMTR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ReadingMMTR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ReadingMMTR init()
 ******************************************************************/
void openfmb::commonmodule::ReadingMMTR::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::init();
  this->TotVAh = NULL;
  this->TotWh = NULL;
  this->TotVArh = NULL;
  this->SupWh = NULL;
  this->SupVArh = NULL;
  this->DmdWh = NULL;
  this->DmdVArh = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMTR clear()
 ******************************************************************/
void openfmb::commonmodule::ReadingMMTR::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::clear();
  if (this->TotVAh != NULL) {
    /* clear struct: (*this->TotVAh) */
    (*this->TotVAh).clear( );
    delete this->TotVAh;
    this->TotVAh = NULL;
  }
  if (this->TotWh != NULL) {
    /* clear struct: (*this->TotWh) */
    (*this->TotWh).clear( );
    delete this->TotWh;
    this->TotWh = NULL;
  }
  if (this->TotVArh != NULL) {
    /* clear struct: (*this->TotVArh) */
    (*this->TotVArh).clear( );
    delete this->TotVArh;
    this->TotVArh = NULL;
  }
  if (this->SupWh != NULL) {
    /* clear struct: (*this->SupWh) */
    (*this->SupWh).clear( );
    delete this->SupWh;
    this->SupWh = NULL;
  }
  if (this->SupVArh != NULL) {
    /* clear struct: (*this->SupVArh) */
    (*this->SupVArh).clear( );
    delete this->SupVArh;
    this->SupVArh = NULL;
  }
  if (this->DmdWh != NULL) {
    /* clear struct: (*this->DmdWh) */
    (*this->DmdWh).clear( );
    delete this->DmdWh;
    this->DmdWh = NULL;
  }
  if (this->DmdVArh != NULL) {
    /* clear struct: (*this->DmdVArh) */
    (*this->DmdVArh).clear( );
    delete this->DmdVArh;
    this->DmdVArh = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMTR copy()
 ******************************************************************/
void openfmb::commonmodule::ReadingMMTR::copy( const ReadingMMTR * copy_from )
{

  ReadingMMTR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::copy( copy_from );
  /* copy TotVAh */
  if (copy_from->TotVAh) {
    copy_to->TotVAh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
    (*copy_to->TotVAh).copy( &(*copy_from->TotVAh) );
  }
  else
    copy_to->TotVAh = NULL;

  /* copy TotWh */
  if (copy_from->TotWh) {
    copy_to->TotWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
    (*copy_to->TotWh).copy( &(*copy_from->TotWh) );
  }
  else
    copy_to->TotWh = NULL;

  /* copy TotVArh */
  if (copy_from->TotVArh) {
    copy_to->TotVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
    (*copy_to->TotVArh).copy( &(*copy_from->TotVArh) );
  }
  else
    copy_to->TotVArh = NULL;

  /* copy SupWh */
  if (copy_from->SupWh) {
    copy_to->SupWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
    (*copy_to->SupWh).copy( &(*copy_from->SupWh) );
  }
  else
    copy_to->SupWh = NULL;

  /* copy SupVArh */
  if (copy_from->SupVArh) {
    copy_to->SupVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
    (*copy_to->SupVArh).copy( &(*copy_from->SupVArh) );
  }
  else
    copy_to->SupVArh = NULL;

  /* copy DmdWh */
  if (copy_from->DmdWh) {
    copy_to->DmdWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
    (*copy_to->DmdWh).copy( &(*copy_from->DmdWh) );
  }
  else
    copy_to->DmdWh = NULL;

  /* copy DmdVArh */
  if (copy_from->DmdVArh) {
    copy_to->DmdVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
    (*copy_to->DmdVArh).copy( &(*copy_from->DmdVArh) );
  }
  else
    copy_to->DmdVArh = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMTR::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMTR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (TotVAh != NULL) {
          offset = (*TotVAh).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (TotWh != NULL) {
          offset = (*TotWh).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (TotVArh != NULL) {
          offset = (*TotVArh).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (SupWh != NULL) {
          offset = (*SupWh).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (SupVArh != NULL) {
          offset = (*SupVArh).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (DmdWh != NULL) {
          offset = (*DmdWh).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (DmdVArh != NULL) {
          offset = (*DmdVArh).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMTR::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMTR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNode::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (TotVAh != NULL) {
              offset = (*TotVAh).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (TotWh != NULL) {
              offset = (*TotWh).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (TotVArh != NULL) {
              offset = (*TotVArh).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SupWh != NULL) {
              offset = (*SupWh).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SupVArh != NULL) {
              offset = (*SupVArh).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DmdWh != NULL) {
              offset = (*DmdWh).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DmdVArh != NULL) {
              offset = (*DmdVArh).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (TotVAh != NULL) {
              offset = (*TotVAh).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (TotWh != NULL) {
              offset = (*TotWh).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (TotVArh != NULL) {
              offset = (*TotVArh).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SupWh != NULL) {
              offset = (*SupWh).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SupVArh != NULL) {
              offset = (*SupVArh).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DmdWh != NULL) {
              offset = (*DmdWh).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DmdVArh != NULL) {
              offset = (*DmdVArh).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMTR::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMTR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMTR::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMTR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                TotVAh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*TotVAh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                TotVAh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                TotWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*TotWh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                TotWh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                TotVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*TotVArh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                TotVArh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SupWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*SupWh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SupWh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SupVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*SupVArh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SupVArh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DmdWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*DmdWh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DmdWh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DmdVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*DmdVArh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DmdVArh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                TotVAh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*TotVAh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                TotVAh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                TotWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*TotWh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                TotWh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                TotVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*TotVArh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                TotVArh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SupWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*SupWh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SupWh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SupVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*SupVArh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SupVArh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DmdWh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*DmdWh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DmdWh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DmdVArh = (struct openfmb::commonmodule::BCR*)new struct openfmb::commonmodule::BCR();
                offset = (*DmdVArh).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DmdVArh = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMTR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMTR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMTR get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ReadingMMTR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNode::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("TotVAh", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMTR,TotVAh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::BCR::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("TotWh", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMTR,TotWh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::BCR::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("TotVArh", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMTR,TotVArh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::BCR::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("SupWh", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMTR,SupWh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::BCR::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("SupVArh", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMTR,SupVArh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::BCR::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("DmdWh", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMTR,DmdWh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::BCR::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("DmdVArh", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMTR,DmdVArh);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::BCR::get_field_def(&fieldname[8], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusDPS Default Constructor
 ******************************************************************/
openfmb::commonmodule::StatusDPS::StatusDPS()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::StatusDPS Copy Constructor
 ******************************************************************/
openfmb::commonmodule::StatusDPS::StatusDPS( const StatusDPS & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::StatusDPS Destructor
 ******************************************************************/
openfmb::commonmodule::StatusDPS::~StatusDPS()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::StatusDPS Assignment Operator
 ******************************************************************/
openfmb::commonmodule::StatusDPS& openfmb::commonmodule::StatusDPS::operator=( const openfmb::commonmodule::StatusDPS & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::StatusDPS Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::StatusDPS init()
 ******************************************************************/
void openfmb::commonmodule::StatusDPS::init()
{
  this->stVal = openfmb::commonmodule::DbPosKind_invalid;
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
}

/******************************************************************
 * openfmb::commonmodule::StatusDPS clear()
 ******************************************************************/
void openfmb::commonmodule::StatusDPS::clear()
{
  /* clear enum: this->stVal */
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
}

/******************************************************************
 *  openfmb::commonmodule::StatusDPS copy()
 ******************************************************************/
void openfmb::commonmodule::StatusDPS::copy( const StatusDPS * copy_from )
{

  StatusDPS * copy_to = this;

  if ( ! copy_from ) return;


  /* copy stVal */
  copy_to->stVal = copy_from->stVal;

  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

}

/******************************************************************
 *  openfmb::commonmodule::StatusDPS::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::StatusDPS::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* stVal */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
      /* q */
      offset += 2;
      /* t */
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusDPS::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusDPS::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, stVal, 4);
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
      else
        {
          DDS_MARSH_PUT_ENUM(buf, offset, stVal, 4);
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusDPS::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusDPS::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusDPS::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusDPS::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, stVal, 4, openfmb::commonmodule::DbPosKind, stream_len);
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
       else
        {
          DDS_MARSH_GET_ENUM(buf, offset, stVal, 4, openfmb::commonmodule::DbPosKind, stream_len);
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusDPS::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusDPS::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusDPS get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::StatusDPS::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("stVal", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusDPS,stVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusDPS,stVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusDPS,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusDPS,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusDPS,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusDPS,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusSPS Default Constructor
 ******************************************************************/
openfmb::commonmodule::StatusSPS::StatusSPS()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::StatusSPS Copy Constructor
 ******************************************************************/
openfmb::commonmodule::StatusSPS::StatusSPS( const StatusSPS & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::StatusSPS Destructor
 ******************************************************************/
openfmb::commonmodule::StatusSPS::~StatusSPS()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::StatusSPS Assignment Operator
 ******************************************************************/
openfmb::commonmodule::StatusSPS& openfmb::commonmodule::StatusSPS::operator=( const openfmb::commonmodule::StatusSPS & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::StatusSPS Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::StatusSPS init()
 ******************************************************************/
void openfmb::commonmodule::StatusSPS::init()
{
  this->q = NULL;
  this->stVal = 0;
  this->t = NULL;
}

/******************************************************************
 * openfmb::commonmodule::StatusSPS clear()
 ******************************************************************/
void openfmb::commonmodule::StatusSPS::clear()
{
  if (this->q != NULL) {
    delete[] this->q;
    this->q = NULL;
  }
  /* clear basic type: this->stVal NOOP */
  if (this->t != NULL) {
    delete[] this->t;
    this->t = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::StatusSPS copy()
 ******************************************************************/
void openfmb::commonmodule::StatusSPS::copy( const StatusSPS * copy_from )
{

  StatusSPS * copy_to = this;

  if ( ! copy_from ) return;


  /* copy q */
  if (copy_from->q) {
    copy_to->q = (openfmb::commonmodule::Quality*)new openfmb::commonmodule::Quality();
    {
      int i_1;
      for (i_1 = 0; i_1 < 2; i_1++)
        {
          (*copy_to->q)[i_1] = (*copy_from->q)[i_1];
        }
    }
  }
  else
    copy_to->q = NULL;

  /* copy stVal */
  copy_to->stVal = copy_from->stVal;

  /* copy t */
  if (copy_from->t) {
    copy_to->t = (openfmb::commonmodule::Timestamp*)new openfmb::commonmodule::Timestamp();
    {
      int i_1;
      for (i_1 = 0; i_1 < 8; i_1++)
        {
          (*copy_to->t)[i_1] = (*copy_from->t)[i_1];
        }
    }
  }
  else
    copy_to->t = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::StatusSPS::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::StatusSPS::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (q != NULL) {
          /* (*q) */
          offset += 2;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      /* stVal */
      offset += 1;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (t != NULL) {
          /* (*t) */
          offset += 8;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusSPS::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusSPS::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (q != NULL) {
              memcpy(&buf[offset], (*q), 2);
              offset+=2;
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          DDS_MARSH_PUT_BYTE(buf, offset, stVal);
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (t != NULL) {
              memcpy(&buf[offset], (*t), 8);
              offset+=8;
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (q != NULL) {
              memcpy(&buf[offset], (*q), 2);
              offset+=2;
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          DDS_MARSH_PUT_BYTE(buf, offset, stVal);
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (t != NULL) {
              memcpy(&buf[offset], (*t), 8);
              offset+=8;
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusSPS::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusSPS::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusSPS::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusSPS::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                q = (openfmb::commonmodule::Quality*)new openfmb::commonmodule::Quality();
                memcpy((*q), &buf[offset], 2);
                offset+=2;
              }
              else {
                q = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          DDS_MARSH_GET_BYTE(buf, offset, stVal, stream_len);
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                t = (openfmb::commonmodule::Timestamp*)new openfmb::commonmodule::Timestamp();
                memcpy((*t), &buf[offset], 8);
                offset+=8;
              }
              else {
                t = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                q = (openfmb::commonmodule::Quality*)new openfmb::commonmodule::Quality();
                memcpy((*q), &buf[offset], 2);
                offset+=2;
              }
              else {
                q = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          DDS_MARSH_GET_BYTE(buf, offset, stVal, stream_len);
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                t = (openfmb::commonmodule::Timestamp*)new openfmb::commonmodule::Timestamp();
                memcpy((*t), &buf[offset], 8);
                offset+=8;
              }
              else {
                t = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusSPS::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusSPS::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusSPS get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::StatusSPS::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 79;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusSPS,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusSPS,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("stVal", fieldname)==0) {
    field_def->kind       = 7;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusSPS,stVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusSPS,stVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 79;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusSPS,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusSPS,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusValue Default Constructor
 ******************************************************************/
openfmb::commonmodule::StatusValue::StatusValue()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::StatusValue Copy Constructor
 ******************************************************************/
openfmb::commonmodule::StatusValue::StatusValue( const StatusValue & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::StatusValue Destructor
 ******************************************************************/
openfmb::commonmodule::StatusValue::~StatusValue()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::StatusValue Assignment Operator
 ******************************************************************/
openfmb::commonmodule::StatusValue& openfmb::commonmodule::StatusValue::operator=( const openfmb::commonmodule::StatusValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::StatusValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::StatusValue init()
 ******************************************************************/
void openfmb::commonmodule::StatusValue::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_StatusValue = 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusValue clear()
 ******************************************************************/
void openfmb::commonmodule::StatusValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_StatusValue NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::StatusValue copy()
 ******************************************************************/
void openfmb::commonmodule::StatusValue::copy( const StatusValue * copy_from )
{

  StatusValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_StatusValue */
  copy_to->__dummy_prevent_empty_class_StatusValue = copy_from->__dummy_prevent_empty_class_StatusValue;

}

/******************************************************************
 *  openfmb::commonmodule::StatusValue::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::StatusValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_StatusValue */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValue::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValue);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValue);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValue::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValue, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValue, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::StatusValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_StatusValue", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusValue,__dummy_prevent_empty_class_StatusValue);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusValue,__dummy_prevent_empty_class_StatusValue);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusValueSource Default Constructor
 ******************************************************************/
openfmb::commonmodule::StatusValueSource::StatusValueSource()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::StatusValueSource Copy Constructor
 ******************************************************************/
openfmb::commonmodule::StatusValueSource::StatusValueSource( const StatusValueSource & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::StatusValueSource Destructor
 ******************************************************************/
openfmb::commonmodule::StatusValueSource::~StatusValueSource()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::StatusValueSource Assignment Operator
 ******************************************************************/
openfmb::commonmodule::StatusValueSource& openfmb::commonmodule::StatusValueSource::operator=( const openfmb::commonmodule::StatusValueSource & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::StatusValueSource Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::StatusValueSource init()
 ******************************************************************/
void openfmb::commonmodule::StatusValueSource::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_StatusValueSource = 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusValueSource clear()
 ******************************************************************/
void openfmb::commonmodule::StatusValueSource::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_StatusValueSource NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::StatusValueSource copy()
 ******************************************************************/
void openfmb::commonmodule::StatusValueSource::copy( const StatusValueSource * copy_from )
{

  StatusValueSource * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_StatusValueSource */
  copy_to->__dummy_prevent_empty_class_StatusValueSource = copy_from->__dummy_prevent_empty_class_StatusValueSource;

}

/******************************************************************
 *  openfmb::commonmodule::StatusValueSource::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::StatusValueSource::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_StatusValueSource */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValueSource::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusValueSource::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValueSource);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValueSource);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValueSource::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusValueSource::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValueSource::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusValueSource::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValueSource, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_StatusValueSource, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValueSource::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusValueSource::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusValueSource get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::StatusValueSource::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_StatusValueSource", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusValueSource,__dummy_prevent_empty_class_StatusValueSource);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusValueSource,__dummy_prevent_empty_class_StatusValueSource);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::Unit Default Constructor
 ******************************************************************/
openfmb::commonmodule::Unit::Unit()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::Unit Copy Constructor
 ******************************************************************/
openfmb::commonmodule::Unit::Unit( const Unit & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::Unit Destructor
 ******************************************************************/
openfmb::commonmodule::Unit::~Unit()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::Unit Assignment Operator
 ******************************************************************/
openfmb::commonmodule::Unit& openfmb::commonmodule::Unit::operator=( const openfmb::commonmodule::Unit & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::Unit Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::Unit init()
 ******************************************************************/
void openfmb::commonmodule::Unit::init()
{
  this->SIUnit = openfmb::commonmodule::UnitSymbolKind_Amp;
  this->multiplier = NULL;
}

/******************************************************************
 * openfmb::commonmodule::Unit clear()
 ******************************************************************/
void openfmb::commonmodule::Unit::clear()
{
  /* clear enum: this->SIUnit */
  if (this->multiplier != NULL) {
    delete this->multiplier;
    this->multiplier = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::Unit copy()
 ******************************************************************/
void openfmb::commonmodule::Unit::copy( const Unit * copy_from )
{

  Unit * copy_to = this;

  if ( ! copy_from ) return;


  /* copy SIUnit */
  copy_to->SIUnit = copy_from->SIUnit;

  /* copy multiplier */
  if (copy_from->multiplier) {
    copy_to->multiplier = (enum openfmb::commonmodule::UnitMultiplierKind *)new enum openfmb::commonmodule::UnitMultiplierKind ();
    (*copy_to->multiplier) = (*copy_from->multiplier);
  }
  else
    copy_to->multiplier = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::Unit::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::Unit::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* SIUnit */
      offset = (offset+3) & 0xfffffffc; /* align 4 */
      offset += 4;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (multiplier != NULL) {
          /* (*multiplier) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Unit::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::Unit::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, SIUnit, 4);
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x1;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (multiplier != NULL) {
              DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, (*multiplier), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          DDS_MARSH_PUT_ENUM(buf, offset, SIUnit, 4);
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x1;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (multiplier != NULL) {
              DDS_MARSH_PUT_ENUM(buf, offset, (*multiplier), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Unit::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::Unit::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Unit::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::Unit::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, SIUnit, 4, openfmb::commonmodule::UnitSymbolKind, stream_len);
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                multiplier = (enum openfmb::commonmodule::UnitMultiplierKind *)new enum openfmb::commonmodule::UnitMultiplierKind ();
                DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, (*multiplier), 4, openfmb::commonmodule::UnitMultiplierKind, stream_len);
              }
              else {
                multiplier = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          DDS_MARSH_GET_ENUM(buf, offset, SIUnit, 4, openfmb::commonmodule::UnitSymbolKind, stream_len);
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                multiplier = (enum openfmb::commonmodule::UnitMultiplierKind *)new enum openfmb::commonmodule::UnitMultiplierKind ();
                DDS_MARSH_GET_ENUM(buf, offset, (*multiplier), 4, openfmb::commonmodule::UnitMultiplierKind, stream_len);
              }
              else {
                multiplier = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Unit::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::Unit::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Unit get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::Unit::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("SIUnit", fieldname)==0) {
    field_def->kind       = 12;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::Unit,SIUnit);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::Unit,SIUnit);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("multiplier", fieldname)==0) {
    field_def->kind       = 76;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::Unit,multiplier);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::Unit,multiplier);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::Vector Default Constructor
 ******************************************************************/
openfmb::commonmodule::Vector::Vector()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::Vector Copy Constructor
 ******************************************************************/
openfmb::commonmodule::Vector::Vector( const Vector & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::Vector Destructor
 ******************************************************************/
openfmb::commonmodule::Vector::~Vector()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::Vector Assignment Operator
 ******************************************************************/
openfmb::commonmodule::Vector& openfmb::commonmodule::Vector::operator=( const openfmb::commonmodule::Vector & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::Vector Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::Vector init()
 ******************************************************************/
void openfmb::commonmodule::Vector::init()
{
  /* init struct: this->mag */
  this->mag.init( );
  this->ang = NULL;
}

/******************************************************************
 * openfmb::commonmodule::Vector clear()
 ******************************************************************/
void openfmb::commonmodule::Vector::clear()
{
  /* clear struct: this->mag */
  this->mag.clear( );
  if (this->ang != NULL) {
    /* clear struct: (*this->ang) */
    (*this->ang).clear( );
    delete this->ang;
    this->ang = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::Vector copy()
 ******************************************************************/
void openfmb::commonmodule::Vector::copy( const Vector * copy_from )
{

  Vector * copy_to = this;

  if ( ! copy_from ) return;


  /* copy mag */
  copy_to->mag.copy( &copy_from->mag );

  /* copy ang */
  if (copy_from->ang) {
    copy_to->ang = (struct openfmb::commonmodule::AnalogueValue*)new struct openfmb::commonmodule::AnalogueValue();
    (*copy_to->ang).copy( &(*copy_from->ang) );
  }
  else
    copy_to->ang = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::Vector::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::Vector::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = mag.get_marshal_size( offset, 0 );
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (ang != NULL) {
          offset = (*ang).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Vector::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::Vector::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = mag.marshal_cdr( buf, offset, stream_len, 1, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ang != NULL) {
              offset = (*ang).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = mag.marshal_cdr( buf, offset, stream_len, 0, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ang != NULL) {
              offset = (*ang).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Vector::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::Vector::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Vector::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::Vector::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = mag.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ang = (struct openfmb::commonmodule::AnalogueValue*)new struct openfmb::commonmodule::AnalogueValue();
                offset = (*ang).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ang = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = mag.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ang = (struct openfmb::commonmodule::AnalogueValue*)new struct openfmb::commonmodule::AnalogueValue();
                offset = (*ang).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ang = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Vector::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::Vector::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::Vector get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::Vector::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("mag", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::Vector,mag);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::AnalogueValue::get_field_def(&fieldname[4], field_def);
  }
  if ( (strncmp("ang", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::Vector,ang);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::AnalogueValue::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ENC_ESSControlKind Default Constructor
 ******************************************************************/
openfmb::essmodule::ENC_ESSControlKind::ENC_ESSControlKind()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ENC_ESSControlKind Copy Constructor
 ******************************************************************/
openfmb::essmodule::ENC_ESSControlKind::ENC_ESSControlKind( const ENC_ESSControlKind & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ENC_ESSControlKind Destructor
 ******************************************************************/
openfmb::essmodule::ENC_ESSControlKind::~ENC_ESSControlKind()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ENC_ESSControlKind Assignment Operator
 ******************************************************************/
openfmb::essmodule::ENC_ESSControlKind& openfmb::essmodule::ENC_ESSControlKind::operator=( const openfmb::essmodule::ENC_ESSControlKind & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ENC_ESSControlKind Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ENC_ESSControlKind init()
 ******************************************************************/
void openfmb::essmodule::ENC_ESSControlKind::init()
{
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
  this->ctlVal = NULL;
}

/******************************************************************
 * openfmb::essmodule::ENC_ESSControlKind clear()
 ******************************************************************/
void openfmb::essmodule::ENC_ESSControlKind::clear()
{
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
  if (this->ctlVal != NULL) {
    delete this->ctlVal;
    this->ctlVal = NULL;
  }
}

/******************************************************************
 *  openfmb::essmodule::ENC_ESSControlKind copy()
 ******************************************************************/
void openfmb::essmodule::ENC_ESSControlKind::copy( const ENC_ESSControlKind * copy_from )
{

  ENC_ESSControlKind * copy_to = this;

  if ( ! copy_from ) return;


  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

  /* copy ctlVal */
  if (copy_from->ctlVal) {
    copy_to->ctlVal = (enum openfmb::essmodule::ESSControlKind *)new enum openfmb::essmodule::ESSControlKind ();
    (*copy_to->ctlVal) = (*copy_from->ctlVal);
  }
  else
    copy_to->ctlVal = NULL;

}

/******************************************************************
 *  openfmb::essmodule::ENC_ESSControlKind::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ENC_ESSControlKind::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* q */
      offset += 2;
      /* t */
      offset += 8;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (ctlVal != NULL) {
          /* (*ctlVal) */
          offset = (offset+3) & 0xfffffffc; /* align 4 */
          offset += 4;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ENC_ESSControlKind::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ENC_ESSControlKind::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x2;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ctlVal != NULL) {
              DDS_MARSH_PUT_ENUM_AND_REORDER(buf, offset, (*ctlVal), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x2;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ctlVal != NULL) {
              DDS_MARSH_PUT_ENUM(buf, offset, (*ctlVal), 4);
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ENC_ESSControlKind::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ENC_ESSControlKind::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ENC_ESSControlKind::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ENC_ESSControlKind::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ctlVal = (enum openfmb::essmodule::ESSControlKind *)new enum openfmb::essmodule::ESSControlKind ();
                DDS_MARSH_GET_ENUM_AND_REORDER(buf, offset, (*ctlVal), 4, openfmb::essmodule::ESSControlKind, stream_len);
              }
              else {
                ctlVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ctlVal = (enum openfmb::essmodule::ESSControlKind *)new enum openfmb::essmodule::ESSControlKind ();
                DDS_MARSH_GET_ENUM(buf, offset, (*ctlVal), 4, openfmb::essmodule::ESSControlKind, stream_len);
              }
              else {
                ctlVal = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ENC_ESSControlKind::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ENC_ESSControlKind::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ENC_ESSControlKind get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ENC_ESSControlKind::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ENC_ESSControlKind,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ENC_ESSControlKind,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ENC_ESSControlKind,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ENC_ESSControlKind,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("ctlVal", fieldname)==0) {
    field_def->kind       = 76;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ENC_ESSControlKind,ctlVal);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ENC_ESSControlKind,ctlVal);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventAndStatusZGEN Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationEventAndStatusZGEN::GenerationEventAndStatusZGEN()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventAndStatusZGEN Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationEventAndStatusZGEN::GenerationEventAndStatusZGEN( const GenerationEventAndStatusZGEN & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventAndStatusZGEN Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationEventAndStatusZGEN::~GenerationEventAndStatusZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventAndStatusZGEN Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationEventAndStatusZGEN& openfmb::generationmodule::GenerationEventAndStatusZGEN::operator=( const openfmb::generationmodule::GenerationEventAndStatusZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationEventAndStatusZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationEventAndStatusZGEN init()
 ******************************************************************/
void openfmb::generationmodule::GenerationEventAndStatusZGEN::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
  this->GnSynSt = NULL;
  this->ParSt = NULL;
  this->RampLodSw = NULL;
  this->DCPwrSt = NULL;
  this->EmgStop = NULL;
  this->GnCtl = NULL;
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventAndStatusZGEN clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationEventAndStatusZGEN::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->GnOpSt */
  this->GnOpSt.clear( );
  if (this->GnSynSt != NULL) {
    /* clear struct: (*this->GnSynSt) */
    (*this->GnSynSt).clear( );
    delete this->GnSynSt;
    this->GnSynSt = NULL;
  }
  if (this->ParSt != NULL) {
    /* clear struct: (*this->ParSt) */
    (*this->ParSt).clear( );
    delete this->ParSt;
    this->ParSt = NULL;
  }
  if (this->RampLodSw != NULL) {
    /* clear struct: (*this->RampLodSw) */
    (*this->RampLodSw).clear( );
    delete this->RampLodSw;
    this->RampLodSw = NULL;
  }
  if (this->DCPwrSt != NULL) {
    /* clear struct: (*this->DCPwrSt) */
    (*this->DCPwrSt).clear( );
    delete this->DCPwrSt;
    this->DCPwrSt = NULL;
  }
  if (this->EmgStop != NULL) {
    /* clear struct: (*this->EmgStop) */
    (*this->EmgStop).clear( );
    delete this->EmgStop;
    this->EmgStop = NULL;
  }
  if (this->GnCtl != NULL) {
    /* clear struct: (*this->GnCtl) */
    (*this->GnCtl).clear( );
    delete this->GnCtl;
    this->GnCtl = NULL;
  }
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventAndStatusZGEN copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationEventAndStatusZGEN::copy( const GenerationEventAndStatusZGEN * copy_from )
{

  GenerationEventAndStatusZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy GnOpSt */
  copy_to->GnOpSt.copy( &copy_from->GnOpSt );

  /* copy GnSynSt */
  if (copy_from->GnSynSt) {
    copy_to->GnSynSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->GnSynSt).copy( &(*copy_from->GnSynSt) );
  }
  else
    copy_to->GnSynSt = NULL;

  /* copy ParSt */
  if (copy_from->ParSt) {
    copy_to->ParSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->ParSt).copy( &(*copy_from->ParSt) );
  }
  else
    copy_to->ParSt = NULL;

  /* copy RampLodSw */
  if (copy_from->RampLodSw) {
    copy_to->RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->RampLodSw).copy( &(*copy_from->RampLodSw) );
  }
  else
    copy_to->RampLodSw = NULL;

  /* copy DCPwrSt */
  if (copy_from->DCPwrSt) {
    copy_to->DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->DCPwrSt).copy( &(*copy_from->DCPwrSt) );
  }
  else
    copy_to->DCPwrSt = NULL;

  /* copy EmgStop */
  if (copy_from->EmgStop) {
    copy_to->EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->EmgStop).copy( &(*copy_from->EmgStop) );
  }
  else
    copy_to->EmgStop = NULL;

  /* copy GnCtl */
  if (copy_from->GnCtl) {
    copy_to->GnCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
    (*copy_to->GnCtl).copy( &(*copy_from->GnCtl) );
  }
  else
    copy_to->GnCtl = NULL;

}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventAndStatusZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventAndStatusZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = GnOpSt.get_marshal_size( offset, 0 );
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GnSynSt != NULL) {
          offset = (*GnSynSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (ParSt != NULL) {
          offset = (*ParSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (RampLodSw != NULL) {
          offset = (*RampLodSw).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (DCPwrSt != NULL) {
          offset = (*DCPwrSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (EmgStop != NULL) {
          offset = (*EmgStop).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GnCtl != NULL) {
          offset = (*GnCtl).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventAndStatusZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventAndStatusZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = GnOpSt.marshal_cdr( buf, offset, stream_len, 1, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnSynSt != NULL) {
              offset = (*GnSynSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ParSt != NULL) {
              offset = (*ParSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (RampLodSw != NULL) {
              offset = (*RampLodSw).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DCPwrSt != NULL) {
              offset = (*DCPwrSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (EmgStop != NULL) {
              offset = (*EmgStop).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 11;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnCtl != NULL) {
              offset = (*GnCtl).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = GnOpSt.marshal_cdr( buf, offset, stream_len, 0, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnSynSt != NULL) {
              offset = (*GnSynSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ParSt != NULL) {
              offset = (*ParSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (RampLodSw != NULL) {
              offset = (*RampLodSw).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DCPwrSt != NULL) {
              offset = (*DCPwrSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (EmgStop != NULL) {
              offset = (*EmgStop).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 11;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnCtl != NULL) {
              offset = (*GnCtl).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventAndStatusZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventAndStatusZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = GnOpSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnSynSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*GnSynSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnSynSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ParSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*ParSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ParSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*RampLodSw).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                RampLodSw = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*DCPwrSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DCPwrSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*EmgStop).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                EmgStop = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 11) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
                offset = (*GnCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = GnOpSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnSynSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*GnSynSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnSynSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ParSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*ParSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ParSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*RampLodSw).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                RampLodSw = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*DCPwrSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DCPwrSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*EmgStop).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                EmgStop = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 11) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
                offset = (*GnCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventAndStatusZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationEventAndStatusZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("GnOpSt", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventAndStatusZGEN,GnOpSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::ENS_DERGeneratorStateKind::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("GnSynSt", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventAndStatusZGEN,GnSynSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("ParSt", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventAndStatusZGEN,ParSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("RampLodSw", fieldname, 9) == 0) && 
       (fieldname[9] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventAndStatusZGEN,RampLodSw);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[10], field_def);
  }
  if ( (strncmp("DCPwrSt", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventAndStatusZGEN,DCPwrSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("EmgStop", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventAndStatusZGEN,EmgStop);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("GnCtl", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventAndStatusZGEN,GnCtl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlScheduleProfile Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationControlScheduleProfile::GenerationControlScheduleProfile()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlScheduleProfile Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationControlScheduleProfile::GenerationControlScheduleProfile( const GenerationControlScheduleProfile & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlScheduleProfile Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationControlScheduleProfile::~GenerationControlScheduleProfile()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlScheduleProfile Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationControlScheduleProfile& openfmb::generationmodule::GenerationControlScheduleProfile::operator=( const openfmb::generationmodule::GenerationControlScheduleProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationControlScheduleProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationControlScheduleProfile init()
 ******************************************************************/
void openfmb::generationmodule::GenerationControlScheduleProfile::init()
{
  this->__dummy_prevent_empty_class_GenerationControlScheduleProfile = 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlScheduleProfile clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationControlScheduleProfile::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_GenerationControlScheduleProfile NOOP */
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlScheduleProfile copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationControlScheduleProfile::copy( const GenerationControlScheduleProfile * copy_from )
{

  GenerationControlScheduleProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_GenerationControlScheduleProfile */
  copy_to->__dummy_prevent_empty_class_GenerationControlScheduleProfile = copy_from->__dummy_prevent_empty_class_GenerationControlScheduleProfile;

}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlScheduleProfile::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlScheduleProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_GenerationControlScheduleProfile */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlScheduleProfile::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlScheduleProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationControlScheduleProfile);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationControlScheduleProfile);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlScheduleProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlScheduleProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlScheduleProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlScheduleProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationControlScheduleProfile, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationControlScheduleProfile, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlScheduleProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlScheduleProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlScheduleProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationControlScheduleProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_GenerationControlScheduleProfile", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::generationmodule::GenerationControlScheduleProfile,__dummy_prevent_empty_class_GenerationControlScheduleProfile);
    } else
      field_def->offset  += s_offsetof(struct openfmb::generationmodule::GenerationControlScheduleProfile,__dummy_prevent_empty_class_GenerationControlScheduleProfile);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile Default Constructor
 ******************************************************************/
openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::PlannedInterconnectionScheduleProfile()
{
  init();
}

/******************************************************************
 * openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile Copy Constructor
 ******************************************************************/
openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::PlannedInterconnectionScheduleProfile( const PlannedInterconnectionScheduleProfile & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile Destructor
 ******************************************************************/
openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::~PlannedInterconnectionScheduleProfile()
{
  clear();
}

/******************************************************************
 * openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile Assignment Operator
 ******************************************************************/
openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile& openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::operator=( const openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::interconnectionmodule::::PlannedInterconnectionScheduleProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile init()
 ******************************************************************/
void openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::init()
{
  this->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile = 0;
}

/******************************************************************
 * openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile clear()
 ******************************************************************/
void openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile NOOP */
}

/******************************************************************
 *  openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile copy()
 ******************************************************************/
void openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::copy( const PlannedInterconnectionScheduleProfile * copy_from )
{

  PlannedInterconnectionScheduleProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile */
  copy_to->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile = copy_from->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile;

}

/******************************************************************
 *  openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::get_marshal_size()
 ******************************************************************/
int openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::marshal_cdr()
 ******************************************************************/
int openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile,__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile);
    } else
      field_def->offset  += s_offsetof(struct openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile,__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfile);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile Default Constructor
 ******************************************************************/
openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::RequestedInterconnectionScheduleProfile()
{
  init();
}

/******************************************************************
 * openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile Copy Constructor
 ******************************************************************/
openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::RequestedInterconnectionScheduleProfile( const RequestedInterconnectionScheduleProfile & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile Destructor
 ******************************************************************/
openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::~RequestedInterconnectionScheduleProfile()
{
  clear();
}

/******************************************************************
 * openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile Assignment Operator
 ******************************************************************/
openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile& openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::operator=( const openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::interconnectionmodule::::RequestedInterconnectionScheduleProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile init()
 ******************************************************************/
void openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::init()
{
  this->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile = 0;
}

/******************************************************************
 * openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile clear()
 ******************************************************************/
void openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile NOOP */
}

/******************************************************************
 *  openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile copy()
 ******************************************************************/
void openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::copy( const RequestedInterconnectionScheduleProfile * copy_from )
{

  RequestedInterconnectionScheduleProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile */
  copy_to->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile = copy_from->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile;

}

/******************************************************************
 *  openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::get_marshal_size()
 ******************************************************************/
int openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::marshal_cdr()
 ******************************************************************/
int openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile,__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile);
    } else
      field_def->offset  += s_offsetof(struct openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile,__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfile);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadEventAndStatusZGLD Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEventAndStatusZGLD::LoadEventAndStatusZGLD()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadEventAndStatusZGLD Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEventAndStatusZGLD::LoadEventAndStatusZGLD( const LoadEventAndStatusZGLD & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadEventAndStatusZGLD Destructor
 ******************************************************************/
openfmb::loadmodule::LoadEventAndStatusZGLD::~LoadEventAndStatusZGLD()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadEventAndStatusZGLD Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadEventAndStatusZGLD& openfmb::loadmodule::LoadEventAndStatusZGLD::operator=( const openfmb::loadmodule::LoadEventAndStatusZGLD & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadEventAndStatusZGLD Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadEventAndStatusZGLD init()
 ******************************************************************/
void openfmb::loadmodule::LoadEventAndStatusZGLD::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
  this->RampLodSw = NULL;
  this->Stdby = NULL;
  this->DCPwrSt = NULL;
  this->EmgStop = NULL;
  this->LdCtl = NULL;
}

/******************************************************************
 * openfmb::loadmodule::LoadEventAndStatusZGLD clear()
 ******************************************************************/
void openfmb::loadmodule::LoadEventAndStatusZGLD::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->LdOpSt */
  this->LdOpSt.clear( );
  if (this->RampLodSw != NULL) {
    /* clear struct: (*this->RampLodSw) */
    (*this->RampLodSw).clear( );
    delete this->RampLodSw;
    this->RampLodSw = NULL;
  }
  if (this->Stdby != NULL) {
    /* clear struct: (*this->Stdby) */
    (*this->Stdby).clear( );
    delete this->Stdby;
    this->Stdby = NULL;
  }
  if (this->DCPwrSt != NULL) {
    /* clear struct: (*this->DCPwrSt) */
    (*this->DCPwrSt).clear( );
    delete this->DCPwrSt;
    this->DCPwrSt = NULL;
  }
  if (this->EmgStop != NULL) {
    /* clear struct: (*this->EmgStop) */
    (*this->EmgStop).clear( );
    delete this->EmgStop;
    this->EmgStop = NULL;
  }
  if (this->LdCtl != NULL) {
    /* clear struct: (*this->LdCtl) */
    (*this->LdCtl).clear( );
    delete this->LdCtl;
    this->LdCtl = NULL;
  }
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventAndStatusZGLD copy()
 ******************************************************************/
void openfmb::loadmodule::LoadEventAndStatusZGLD::copy( const LoadEventAndStatusZGLD * copy_from )
{

  LoadEventAndStatusZGLD * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy LdOpSt */
  copy_to->LdOpSt.copy( &copy_from->LdOpSt );

  /* copy RampLodSw */
  if (copy_from->RampLodSw) {
    copy_to->RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->RampLodSw).copy( &(*copy_from->RampLodSw) );
  }
  else
    copy_to->RampLodSw = NULL;

  /* copy Stdby */
  if (copy_from->Stdby) {
    copy_to->Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->Stdby).copy( &(*copy_from->Stdby) );
  }
  else
    copy_to->Stdby = NULL;

  /* copy DCPwrSt */
  if (copy_from->DCPwrSt) {
    copy_to->DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->DCPwrSt).copy( &(*copy_from->DCPwrSt) );
  }
  else
    copy_to->DCPwrSt = NULL;

  /* copy EmgStop */
  if (copy_from->EmgStop) {
    copy_to->EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->EmgStop).copy( &(*copy_from->EmgStop) );
  }
  else
    copy_to->EmgStop = NULL;

  /* copy LdCtl */
  if (copy_from->LdCtl) {
    copy_to->LdCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
    (*copy_to->LdCtl).copy( &(*copy_from->LdCtl) );
  }
  else
    copy_to->LdCtl = NULL;

}

/******************************************************************
 *  openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = LdOpSt.get_marshal_size( offset, 0 );
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (RampLodSw != NULL) {
          offset = (*RampLodSw).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (Stdby != NULL) {
          offset = (*Stdby).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (DCPwrSt != NULL) {
          offset = (*DCPwrSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (EmgStop != NULL) {
          offset = (*EmgStop).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (LdCtl != NULL) {
          offset = (*LdCtl).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = LdOpSt.marshal_cdr( buf, offset, stream_len, 1, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (RampLodSw != NULL) {
              offset = (*RampLodSw).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Stdby != NULL) {
              offset = (*Stdby).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DCPwrSt != NULL) {
              offset = (*DCPwrSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (EmgStop != NULL) {
              offset = (*EmgStop).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (LdCtl != NULL) {
              offset = (*LdCtl).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = LdOpSt.marshal_cdr( buf, offset, stream_len, 0, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (RampLodSw != NULL) {
              offset = (*RampLodSw).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Stdby != NULL) {
              offset = (*Stdby).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DCPwrSt != NULL) {
              offset = (*DCPwrSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (EmgStop != NULL) {
              offset = (*EmgStop).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (LdCtl != NULL) {
              offset = (*LdCtl).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = LdOpSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*RampLodSw).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                RampLodSw = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*Stdby).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Stdby = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*DCPwrSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DCPwrSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*EmgStop).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                EmgStop = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                LdCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
                offset = (*LdCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                LdCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = LdOpSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*RampLodSw).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                RampLodSw = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*Stdby).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Stdby = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*DCPwrSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DCPwrSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*EmgStop).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                EmgStop = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                LdCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
                offset = (*LdCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                LdCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventAndStatusZGLD get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadEventAndStatusZGLD::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("LdOpSt", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEventAndStatusZGLD,LdOpSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::ENS_DERGeneratorStateKind::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("RampLodSw", fieldname, 9) == 0) && 
       (fieldname[9] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEventAndStatusZGLD,RampLodSw);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[10], field_def);
  }
  if ( (strncmp("Stdby", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEventAndStatusZGLD,Stdby);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("DCPwrSt", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEventAndStatusZGLD,DCPwrSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("EmgStop", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEventAndStatusZGLD,EmgStop);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("LdCtl", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEventAndStatusZGLD,LdCtl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadEventZGLD Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEventZGLD::LoadEventZGLD()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadEventZGLD Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEventZGLD::LoadEventZGLD( const LoadEventZGLD & other )
  : LoadEventAndStatusZGLD()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadEventZGLD Destructor
 ******************************************************************/
openfmb::loadmodule::LoadEventZGLD::~LoadEventZGLD()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadEventZGLD Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadEventZGLD& openfmb::loadmodule::LoadEventZGLD::operator=( const openfmb::loadmodule::LoadEventZGLD & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadEventZGLD Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadEventZGLD init()
 ******************************************************************/
void openfmb::loadmodule::LoadEventZGLD::init()
{
  /* init PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::init();
  this->__dummy_prevent_empty_class_LoadEventZGLD = 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadEventZGLD clear()
 ******************************************************************/
void openfmb::loadmodule::LoadEventZGLD::clear()
{
  /* clear PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_LoadEventZGLD NOOP */
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventZGLD copy()
 ******************************************************************/
void openfmb::loadmodule::LoadEventZGLD::copy( const LoadEventZGLD * copy_from )
{

  LoadEventZGLD * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::copy( copy_from );
  /* copy __dummy_prevent_empty_class_LoadEventZGLD */
  copy_to->__dummy_prevent_empty_class_LoadEventZGLD = copy_from->__dummy_prevent_empty_class_LoadEventZGLD;

}

/******************************************************************
 *  openfmb::loadmodule::LoadEventZGLD::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadEventZGLD::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_LoadEventZGLD */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventZGLD::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEventZGLD::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadEventZGLD);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadEventZGLD);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventZGLD::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEventZGLD::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventZGLD::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEventZGLD::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadEventZGLD, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadEventZGLD, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventZGLD::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEventZGLD::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventZGLD get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadEventZGLD::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::loadmodule::LoadEventAndStatusZGLD::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_LoadEventZGLD", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::loadmodule::LoadEventZGLD,__dummy_prevent_empty_class_LoadEventZGLD);
    } else
      field_def->offset  += s_offsetof(struct openfmb::loadmodule::LoadEventZGLD,__dummy_prevent_empty_class_LoadEventZGLD);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusZGLD Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadStatusZGLD::LoadStatusZGLD()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusZGLD Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadStatusZGLD::LoadStatusZGLD( const LoadStatusZGLD & other )
  : LoadEventAndStatusZGLD()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusZGLD Destructor
 ******************************************************************/
openfmb::loadmodule::LoadStatusZGLD::~LoadStatusZGLD()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusZGLD Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadStatusZGLD& openfmb::loadmodule::LoadStatusZGLD::operator=( const openfmb::loadmodule::LoadStatusZGLD & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadStatusZGLD Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadStatusZGLD init()
 ******************************************************************/
void openfmb::loadmodule::LoadStatusZGLD::init()
{
  /* init PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::init();
  this->__dummy_prevent_empty_class_LoadStatusZGLD = 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusZGLD clear()
 ******************************************************************/
void openfmb::loadmodule::LoadStatusZGLD::clear()
{
  /* clear PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_LoadStatusZGLD NOOP */
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusZGLD copy()
 ******************************************************************/
void openfmb::loadmodule::LoadStatusZGLD::copy( const LoadStatusZGLD * copy_from )
{

  LoadStatusZGLD * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::copy( copy_from );
  /* copy __dummy_prevent_empty_class_LoadStatusZGLD */
  copy_to->__dummy_prevent_empty_class_LoadStatusZGLD = copy_from->__dummy_prevent_empty_class_LoadStatusZGLD;

}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusZGLD::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusZGLD::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_LoadStatusZGLD */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusZGLD::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusZGLD::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadStatusZGLD);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadStatusZGLD);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusZGLD::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusZGLD::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusZGLD::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusZGLD::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadStatusZGLD, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadStatusZGLD, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusZGLD::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusZGLD::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusZGLD get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadStatusZGLD::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::loadmodule::LoadEventAndStatusZGLD::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_LoadStatusZGLD", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::loadmodule::LoadStatusZGLD,__dummy_prevent_empty_class_LoadStatusZGLD);
    } else
      field_def->offset  += s_offsetof(struct openfmb::loadmodule::LoadStatusZGLD,__dummy_prevent_empty_class_LoadStatusZGLD);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::ESSControlScheduleProfileList Default Constructor
 ******************************************************************/
openfmb::optimizermodule::ESSControlScheduleProfileList::ESSControlScheduleProfileList()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::ESSControlScheduleProfileList Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::ESSControlScheduleProfileList::ESSControlScheduleProfileList( const ESSControlScheduleProfileList & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::ESSControlScheduleProfileList Destructor
 ******************************************************************/
openfmb::optimizermodule::ESSControlScheduleProfileList::~ESSControlScheduleProfileList()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::ESSControlScheduleProfileList Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::ESSControlScheduleProfileList& openfmb::optimizermodule::ESSControlScheduleProfileList::operator=( const openfmb::optimizermodule::ESSControlScheduleProfileList & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::ESSControlScheduleProfileList Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::ESSControlScheduleProfileList init()
 ******************************************************************/
void openfmb::optimizermodule::ESSControlScheduleProfileList::init()
{
  this->__dummy_prevent_empty_class_ESSControlScheduleProfileList = 0;
}

/******************************************************************
 * openfmb::optimizermodule::ESSControlScheduleProfileList clear()
 ******************************************************************/
void openfmb::optimizermodule::ESSControlScheduleProfileList::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_ESSControlScheduleProfileList NOOP */
}

/******************************************************************
 *  openfmb::optimizermodule::ESSControlScheduleProfileList copy()
 ******************************************************************/
void openfmb::optimizermodule::ESSControlScheduleProfileList::copy( const ESSControlScheduleProfileList * copy_from )
{

  ESSControlScheduleProfileList * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_ESSControlScheduleProfileList */
  copy_to->__dummy_prevent_empty_class_ESSControlScheduleProfileList = copy_from->__dummy_prevent_empty_class_ESSControlScheduleProfileList;

}

/******************************************************************
 *  openfmb::optimizermodule::ESSControlScheduleProfileList::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::ESSControlScheduleProfileList::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_ESSControlScheduleProfileList */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::ESSControlScheduleProfileList::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::ESSControlScheduleProfileList::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSControlScheduleProfileList);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSControlScheduleProfileList);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::ESSControlScheduleProfileList::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::ESSControlScheduleProfileList::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::ESSControlScheduleProfileList::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::ESSControlScheduleProfileList::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSControlScheduleProfileList, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSControlScheduleProfileList, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::ESSControlScheduleProfileList::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::ESSControlScheduleProfileList::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::ESSControlScheduleProfileList get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::ESSControlScheduleProfileList::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_ESSControlScheduleProfileList", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::optimizermodule::ESSControlScheduleProfileList,__dummy_prevent_empty_class_ESSControlScheduleProfileList);
    } else
      field_def->offset  += s_offsetof(struct openfmb::optimizermodule::ESSControlScheduleProfileList,__dummy_prevent_empty_class_ESSControlScheduleProfileList);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::LoadControlScheduleProfileList Default Constructor
 ******************************************************************/
openfmb::optimizermodule::LoadControlScheduleProfileList::LoadControlScheduleProfileList()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::LoadControlScheduleProfileList Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::LoadControlScheduleProfileList::LoadControlScheduleProfileList( const LoadControlScheduleProfileList & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::LoadControlScheduleProfileList Destructor
 ******************************************************************/
openfmb::optimizermodule::LoadControlScheduleProfileList::~LoadControlScheduleProfileList()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::LoadControlScheduleProfileList Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::LoadControlScheduleProfileList& openfmb::optimizermodule::LoadControlScheduleProfileList::operator=( const openfmb::optimizermodule::LoadControlScheduleProfileList & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::LoadControlScheduleProfileList Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::LoadControlScheduleProfileList init()
 ******************************************************************/
void openfmb::optimizermodule::LoadControlScheduleProfileList::init()
{
  this->__dummy_prevent_empty_class_LoadControlScheduleProfileList = 0;
}

/******************************************************************
 * openfmb::optimizermodule::LoadControlScheduleProfileList clear()
 ******************************************************************/
void openfmb::optimizermodule::LoadControlScheduleProfileList::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_LoadControlScheduleProfileList NOOP */
}

/******************************************************************
 *  openfmb::optimizermodule::LoadControlScheduleProfileList copy()
 ******************************************************************/
void openfmb::optimizermodule::LoadControlScheduleProfileList::copy( const LoadControlScheduleProfileList * copy_from )
{

  LoadControlScheduleProfileList * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_LoadControlScheduleProfileList */
  copy_to->__dummy_prevent_empty_class_LoadControlScheduleProfileList = copy_from->__dummy_prevent_empty_class_LoadControlScheduleProfileList;

}

/******************************************************************
 *  openfmb::optimizermodule::LoadControlScheduleProfileList::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::LoadControlScheduleProfileList::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_LoadControlScheduleProfileList */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::LoadControlScheduleProfileList::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::LoadControlScheduleProfileList::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlScheduleProfileList);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlScheduleProfileList);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::LoadControlScheduleProfileList::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::LoadControlScheduleProfileList::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::LoadControlScheduleProfileList::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::LoadControlScheduleProfileList::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlScheduleProfileList, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlScheduleProfileList, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::LoadControlScheduleProfileList::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::LoadControlScheduleProfileList::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::LoadControlScheduleProfileList get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::LoadControlScheduleProfileList::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_LoadControlScheduleProfileList", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::optimizermodule::LoadControlScheduleProfileList,__dummy_prevent_empty_class_LoadControlScheduleProfileList);
    } else
      field_def->offset  += s_offsetof(struct openfmb::optimizermodule::LoadControlScheduleProfileList,__dummy_prevent_empty_class_LoadControlScheduleProfileList);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList Default Constructor
 ******************************************************************/
openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::PlannedInterconnectionScheduleProfileList()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::PlannedInterconnectionScheduleProfileList( const PlannedInterconnectionScheduleProfileList & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList Destructor
 ******************************************************************/
openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::~PlannedInterconnectionScheduleProfileList()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList& openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::operator=( const openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::PlannedInterconnectionScheduleProfileList Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList init()
 ******************************************************************/
void openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::init()
{
  this->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList = 0;
}

/******************************************************************
 * openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList clear()
 ******************************************************************/
void openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList NOOP */
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList copy()
 ******************************************************************/
void openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::copy( const PlannedInterconnectionScheduleProfileList * copy_from )
{

  PlannedInterconnectionScheduleProfileList * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList */
  copy_to->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList = copy_from->__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList;

}

/******************************************************************
 *  openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList,__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList);
    } else
      field_def->offset  += s_offsetof(struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList,__dummy_prevent_empty_class_PlannedInterconnectionScheduleProfileList);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::RegulatorControlScheduleProfileList Default Constructor
 ******************************************************************/
openfmb::optimizermodule::RegulatorControlScheduleProfileList::RegulatorControlScheduleProfileList()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::RegulatorControlScheduleProfileList Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::RegulatorControlScheduleProfileList::RegulatorControlScheduleProfileList( const RegulatorControlScheduleProfileList & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::RegulatorControlScheduleProfileList Destructor
 ******************************************************************/
openfmb::optimizermodule::RegulatorControlScheduleProfileList::~RegulatorControlScheduleProfileList()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::RegulatorControlScheduleProfileList Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::RegulatorControlScheduleProfileList& openfmb::optimizermodule::RegulatorControlScheduleProfileList::operator=( const openfmb::optimizermodule::RegulatorControlScheduleProfileList & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::RegulatorControlScheduleProfileList Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::RegulatorControlScheduleProfileList init()
 ******************************************************************/
void openfmb::optimizermodule::RegulatorControlScheduleProfileList::init()
{
  this->__dummy_prevent_empty_class_RegulatorControlScheduleProfileList = 0;
}

/******************************************************************
 * openfmb::optimizermodule::RegulatorControlScheduleProfileList clear()
 ******************************************************************/
void openfmb::optimizermodule::RegulatorControlScheduleProfileList::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_RegulatorControlScheduleProfileList NOOP */
}

/******************************************************************
 *  openfmb::optimizermodule::RegulatorControlScheduleProfileList copy()
 ******************************************************************/
void openfmb::optimizermodule::RegulatorControlScheduleProfileList::copy( const RegulatorControlScheduleProfileList * copy_from )
{

  RegulatorControlScheduleProfileList * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_RegulatorControlScheduleProfileList */
  copy_to->__dummy_prevent_empty_class_RegulatorControlScheduleProfileList = copy_from->__dummy_prevent_empty_class_RegulatorControlScheduleProfileList;

}

/******************************************************************
 *  openfmb::optimizermodule::RegulatorControlScheduleProfileList::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::RegulatorControlScheduleProfileList::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_RegulatorControlScheduleProfileList */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RegulatorControlScheduleProfileList::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::RegulatorControlScheduleProfileList::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_RegulatorControlScheduleProfileList);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_RegulatorControlScheduleProfileList);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RegulatorControlScheduleProfileList::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::RegulatorControlScheduleProfileList::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RegulatorControlScheduleProfileList::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::RegulatorControlScheduleProfileList::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_RegulatorControlScheduleProfileList, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_RegulatorControlScheduleProfileList, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RegulatorControlScheduleProfileList::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::RegulatorControlScheduleProfileList::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RegulatorControlScheduleProfileList get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::RegulatorControlScheduleProfileList::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_RegulatorControlScheduleProfileList", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::optimizermodule::RegulatorControlScheduleProfileList,__dummy_prevent_empty_class_RegulatorControlScheduleProfileList);
    } else
      field_def->offset  += s_offsetof(struct openfmb::optimizermodule::RegulatorControlScheduleProfileList,__dummy_prevent_empty_class_RegulatorControlScheduleProfileList);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList Default Constructor
 ******************************************************************/
openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::RequestedInterconnectionScheduleProfileList()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::RequestedInterconnectionScheduleProfileList( const RequestedInterconnectionScheduleProfileList & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList Destructor
 ******************************************************************/
openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::~RequestedInterconnectionScheduleProfileList()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList& openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::operator=( const openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::RequestedInterconnectionScheduleProfileList Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList init()
 ******************************************************************/
void openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::init()
{
  this->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList = 0;
}

/******************************************************************
 * openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList clear()
 ******************************************************************/
void openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList NOOP */
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList copy()
 ******************************************************************/
void openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::copy( const RequestedInterconnectionScheduleProfileList * copy_from )
{

  RequestedInterconnectionScheduleProfileList * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList */
  copy_to->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList = copy_from->__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList;

}

/******************************************************************
 *  openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList,__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList);
    } else
      field_def->offset  += s_offsetof(struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList,__dummy_prevent_empty_class_RequestedInterconnectionScheduleProfileList);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::SolarControlScheduleProfileList Default Constructor
 ******************************************************************/
openfmb::optimizermodule::SolarControlScheduleProfileList::SolarControlScheduleProfileList()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::SolarControlScheduleProfileList Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::SolarControlScheduleProfileList::SolarControlScheduleProfileList( const SolarControlScheduleProfileList & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::SolarControlScheduleProfileList Destructor
 ******************************************************************/
openfmb::optimizermodule::SolarControlScheduleProfileList::~SolarControlScheduleProfileList()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::SolarControlScheduleProfileList Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::SolarControlScheduleProfileList& openfmb::optimizermodule::SolarControlScheduleProfileList::operator=( const openfmb::optimizermodule::SolarControlScheduleProfileList & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::SolarControlScheduleProfileList Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::SolarControlScheduleProfileList init()
 ******************************************************************/
void openfmb::optimizermodule::SolarControlScheduleProfileList::init()
{
  this->__dummy_prevent_empty_class_SolarControlScheduleProfileList = 0;
}

/******************************************************************
 * openfmb::optimizermodule::SolarControlScheduleProfileList clear()
 ******************************************************************/
void openfmb::optimizermodule::SolarControlScheduleProfileList::clear()
{
  /* clear basic type: this->__dummy_prevent_empty_class_SolarControlScheduleProfileList NOOP */
}

/******************************************************************
 *  openfmb::optimizermodule::SolarControlScheduleProfileList copy()
 ******************************************************************/
void openfmb::optimizermodule::SolarControlScheduleProfileList::copy( const SolarControlScheduleProfileList * copy_from )
{

  SolarControlScheduleProfileList * copy_to = this;

  if ( ! copy_from ) return;


  /* copy __dummy_prevent_empty_class_SolarControlScheduleProfileList */
  copy_to->__dummy_prevent_empty_class_SolarControlScheduleProfileList = copy_from->__dummy_prevent_empty_class_SolarControlScheduleProfileList;

}

/******************************************************************
 *  openfmb::optimizermodule::SolarControlScheduleProfileList::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::SolarControlScheduleProfileList::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* __dummy_prevent_empty_class_SolarControlScheduleProfileList */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::SolarControlScheduleProfileList::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::SolarControlScheduleProfileList::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_SolarControlScheduleProfileList);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_SolarControlScheduleProfileList);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::SolarControlScheduleProfileList::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::SolarControlScheduleProfileList::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::SolarControlScheduleProfileList::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::SolarControlScheduleProfileList::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_SolarControlScheduleProfileList, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_SolarControlScheduleProfileList, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::SolarControlScheduleProfileList::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::SolarControlScheduleProfileList::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::SolarControlScheduleProfileList get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::SolarControlScheduleProfileList::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if (strcmp("__dummy_prevent_empty_class_SolarControlScheduleProfileList", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::optimizermodule::SolarControlScheduleProfileList,__dummy_prevent_empty_class_SolarControlScheduleProfileList);
    } else
      field_def->offset  += s_offsetof(struct openfmb::optimizermodule::SolarControlScheduleProfileList,__dummy_prevent_empty_class_SolarControlScheduleProfileList);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::RequestedOptimizerScheduleProfile Default Constructor
 ******************************************************************/
openfmb::optimizermodule::RequestedOptimizerScheduleProfile::RequestedOptimizerScheduleProfile()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::RequestedOptimizerScheduleProfile Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::RequestedOptimizerScheduleProfile::RequestedOptimizerScheduleProfile( const RequestedOptimizerScheduleProfile & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::RequestedOptimizerScheduleProfile Destructor
 ******************************************************************/
openfmb::optimizermodule::RequestedOptimizerScheduleProfile::~RequestedOptimizerScheduleProfile()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::RequestedOptimizerScheduleProfile Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::RequestedOptimizerScheduleProfile& openfmb::optimizermodule::RequestedOptimizerScheduleProfile::operator=( const openfmb::optimizermodule::RequestedOptimizerScheduleProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::RequestedOptimizerScheduleProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::RequestedOptimizerScheduleProfile init()
 ******************************************************************/
void openfmb::optimizermodule::RequestedOptimizerScheduleProfile::init()
{
  this->regulatorControlScheduleProfileList = NULL;
  this->solarControlScheduleProfileList = NULL;
  this->loadControlScheduleProfileList = NULL;
  this->requestedInterconnectionScheduleProfileList = NULL;
  this->essControlScheduleProfileList = NULL;
}

/******************************************************************
 * openfmb::optimizermodule::RequestedOptimizerScheduleProfile clear()
 ******************************************************************/
void openfmb::optimizermodule::RequestedOptimizerScheduleProfile::clear()
{
  if (this->regulatorControlScheduleProfileList != NULL) {
    /* clear struct: (*this->regulatorControlScheduleProfileList) */
    (*this->regulatorControlScheduleProfileList).clear( );
    delete this->regulatorControlScheduleProfileList;
    this->regulatorControlScheduleProfileList = NULL;
  }
  if (this->solarControlScheduleProfileList != NULL) {
    /* clear struct: (*this->solarControlScheduleProfileList) */
    (*this->solarControlScheduleProfileList).clear( );
    delete this->solarControlScheduleProfileList;
    this->solarControlScheduleProfileList = NULL;
  }
  if (this->loadControlScheduleProfileList != NULL) {
    /* clear struct: (*this->loadControlScheduleProfileList) */
    (*this->loadControlScheduleProfileList).clear( );
    delete this->loadControlScheduleProfileList;
    this->loadControlScheduleProfileList = NULL;
  }
  if (this->requestedInterconnectionScheduleProfileList != NULL) {
    /* clear struct: (*this->requestedInterconnectionScheduleProfileList) */
    (*this->requestedInterconnectionScheduleProfileList).clear( );
    delete this->requestedInterconnectionScheduleProfileList;
    this->requestedInterconnectionScheduleProfileList = NULL;
  }
  if (this->essControlScheduleProfileList != NULL) {
    /* clear struct: (*this->essControlScheduleProfileList) */
    (*this->essControlScheduleProfileList).clear( );
    delete this->essControlScheduleProfileList;
    this->essControlScheduleProfileList = NULL;
  }
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedOptimizerScheduleProfile copy()
 ******************************************************************/
void openfmb::optimizermodule::RequestedOptimizerScheduleProfile::copy( const RequestedOptimizerScheduleProfile * copy_from )
{

  RequestedOptimizerScheduleProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy regulatorControlScheduleProfileList */
  if (copy_from->regulatorControlScheduleProfileList) {
    copy_to->regulatorControlScheduleProfileList = (struct openfmb::optimizermodule::RegulatorControlScheduleProfileList*)new struct openfmb::optimizermodule::RegulatorControlScheduleProfileList();
    (*copy_to->regulatorControlScheduleProfileList).copy( &(*copy_from->regulatorControlScheduleProfileList) );
  }
  else
    copy_to->regulatorControlScheduleProfileList = NULL;

  /* copy solarControlScheduleProfileList */
  if (copy_from->solarControlScheduleProfileList) {
    copy_to->solarControlScheduleProfileList = (struct openfmb::optimizermodule::SolarControlScheduleProfileList*)new struct openfmb::optimizermodule::SolarControlScheduleProfileList();
    (*copy_to->solarControlScheduleProfileList).copy( &(*copy_from->solarControlScheduleProfileList) );
  }
  else
    copy_to->solarControlScheduleProfileList = NULL;

  /* copy loadControlScheduleProfileList */
  if (copy_from->loadControlScheduleProfileList) {
    copy_to->loadControlScheduleProfileList = (struct openfmb::optimizermodule::LoadControlScheduleProfileList*)new struct openfmb::optimizermodule::LoadControlScheduleProfileList();
    (*copy_to->loadControlScheduleProfileList).copy( &(*copy_from->loadControlScheduleProfileList) );
  }
  else
    copy_to->loadControlScheduleProfileList = NULL;

  /* copy requestedInterconnectionScheduleProfileList */
  if (copy_from->requestedInterconnectionScheduleProfileList) {
    copy_to->requestedInterconnectionScheduleProfileList = (struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList*)new struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList();
    (*copy_to->requestedInterconnectionScheduleProfileList).copy( &(*copy_from->requestedInterconnectionScheduleProfileList) );
  }
  else
    copy_to->requestedInterconnectionScheduleProfileList = NULL;

  /* copy essControlScheduleProfileList */
  if (copy_from->essControlScheduleProfileList) {
    copy_to->essControlScheduleProfileList = (struct openfmb::optimizermodule::ESSControlScheduleProfileList*)new struct openfmb::optimizermodule::ESSControlScheduleProfileList();
    (*copy_to->essControlScheduleProfileList).copy( &(*copy_from->essControlScheduleProfileList) );
  }
  else
    copy_to->essControlScheduleProfileList = NULL;

}

/******************************************************************
 *  openfmb::optimizermodule::RequestedOptimizerScheduleProfile::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::RequestedOptimizerScheduleProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (regulatorControlScheduleProfileList != NULL) {
          offset = (*regulatorControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (solarControlScheduleProfileList != NULL) {
          offset = (*solarControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (loadControlScheduleProfileList != NULL) {
          offset = (*loadControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (requestedInterconnectionScheduleProfileList != NULL) {
          offset = (*requestedInterconnectionScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essControlScheduleProfileList != NULL) {
          offset = (*essControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedOptimizerScheduleProfile::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::RequestedOptimizerScheduleProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (regulatorControlScheduleProfileList != NULL) {
              offset = (*regulatorControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarControlScheduleProfileList != NULL) {
              offset = (*solarControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadControlScheduleProfileList != NULL) {
              offset = (*loadControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (requestedInterconnectionScheduleProfileList != NULL) {
              offset = (*requestedInterconnectionScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essControlScheduleProfileList != NULL) {
              offset = (*essControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (regulatorControlScheduleProfileList != NULL) {
              offset = (*regulatorControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarControlScheduleProfileList != NULL) {
              offset = (*solarControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadControlScheduleProfileList != NULL) {
              offset = (*loadControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (requestedInterconnectionScheduleProfileList != NULL) {
              offset = (*requestedInterconnectionScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essControlScheduleProfileList != NULL) {
              offset = (*essControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedOptimizerScheduleProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::RequestedOptimizerScheduleProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedOptimizerScheduleProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::RequestedOptimizerScheduleProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                regulatorControlScheduleProfileList = (struct openfmb::optimizermodule::RegulatorControlScheduleProfileList*)new struct openfmb::optimizermodule::RegulatorControlScheduleProfileList();
                offset = (*regulatorControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                regulatorControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarControlScheduleProfileList = (struct openfmb::optimizermodule::SolarControlScheduleProfileList*)new struct openfmb::optimizermodule::SolarControlScheduleProfileList();
                offset = (*solarControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadControlScheduleProfileList = (struct openfmb::optimizermodule::LoadControlScheduleProfileList*)new struct openfmb::optimizermodule::LoadControlScheduleProfileList();
                offset = (*loadControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                requestedInterconnectionScheduleProfileList = (struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList*)new struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList();
                offset = (*requestedInterconnectionScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                requestedInterconnectionScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essControlScheduleProfileList = (struct openfmb::optimizermodule::ESSControlScheduleProfileList*)new struct openfmb::optimizermodule::ESSControlScheduleProfileList();
                offset = (*essControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                regulatorControlScheduleProfileList = (struct openfmb::optimizermodule::RegulatorControlScheduleProfileList*)new struct openfmb::optimizermodule::RegulatorControlScheduleProfileList();
                offset = (*regulatorControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                regulatorControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarControlScheduleProfileList = (struct openfmb::optimizermodule::SolarControlScheduleProfileList*)new struct openfmb::optimizermodule::SolarControlScheduleProfileList();
                offset = (*solarControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadControlScheduleProfileList = (struct openfmb::optimizermodule::LoadControlScheduleProfileList*)new struct openfmb::optimizermodule::LoadControlScheduleProfileList();
                offset = (*loadControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                requestedInterconnectionScheduleProfileList = (struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList*)new struct openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList();
                offset = (*requestedInterconnectionScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                requestedInterconnectionScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essControlScheduleProfileList = (struct openfmb::optimizermodule::ESSControlScheduleProfileList*)new struct openfmb::optimizermodule::ESSControlScheduleProfileList();
                offset = (*essControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedOptimizerScheduleProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::RequestedOptimizerScheduleProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::RequestedOptimizerScheduleProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::RequestedOptimizerScheduleProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("regulatorControlScheduleProfileList", fieldname, 35) == 0) && 
       (fieldname[35] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::RequestedOptimizerScheduleProfile,regulatorControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::RegulatorControlScheduleProfileList::get_field_def(&fieldname[36], field_def);
  }
  if ( (strncmp("solarControlScheduleProfileList", fieldname, 31) == 0) && 
       (fieldname[31] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::RequestedOptimizerScheduleProfile,solarControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::SolarControlScheduleProfileList::get_field_def(&fieldname[32], field_def);
  }
  if ( (strncmp("loadControlScheduleProfileList", fieldname, 30) == 0) && 
       (fieldname[30] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::RequestedOptimizerScheduleProfile,loadControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::LoadControlScheduleProfileList::get_field_def(&fieldname[31], field_def);
  }
  if ( (strncmp("requestedInterconnectionScheduleProfileList", fieldname, 43) == 0) && 
       (fieldname[43] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::RequestedOptimizerScheduleProfile,requestedInterconnectionScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::RequestedInterconnectionScheduleProfileList::get_field_def(&fieldname[44], field_def);
  }
  if ( (strncmp("essControlScheduleProfileList", fieldname, 29) == 0) && 
       (fieldname[29] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::RequestedOptimizerScheduleProfile,essControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::ESSControlScheduleProfileList::get_field_def(&fieldname[30], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlXCBR Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControlXCBR::RecloserControlXCBR()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlXCBR Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControlXCBR::RecloserControlXCBR( const RecloserControlXCBR & other )
  : LogicalNodeForControl()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlXCBR Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControlXCBR::~RecloserControlXCBR()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlXCBR Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserControlXCBR& openfmb::reclosermodule::RecloserControlXCBR::operator=( const openfmb::reclosermodule::RecloserControlXCBR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserControlXCBR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserControlXCBR init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControlXCBR::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::init();
  this->Pos = NULL;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlXCBR clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControlXCBR::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::clear();
  if (this->Pos != NULL) {
    /* clear struct: (*this->Pos) */
    (*this->Pos).clear( );
    delete this->Pos;
    this->Pos = NULL;
  }
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlXCBR copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControlXCBR::copy( const RecloserControlXCBR * copy_from )
{

  RecloserControlXCBR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::copy( copy_from );
  /* copy Pos */
  if (copy_from->Pos) {
    copy_to->Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
    (*copy_to->Pos).copy( &(*copy_from->Pos) );
  }
  else
    copy_to->Pos = NULL;

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlXCBR::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlXCBR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (Pos != NULL) {
          offset = (*Pos).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlXCBR::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlXCBR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForControl::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Pos != NULL) {
              offset = (*Pos).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Pos != NULL) {
              offset = (*Pos).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlXCBR::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlXCBR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlXCBR::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlXCBR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*Pos).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Pos = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*Pos).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Pos = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlXCBR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlXCBR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlXCBR get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserControlXCBR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForControl::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserControlXCBR,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ControlDPC::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventXCBR Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEventXCBR::RecloserEventXCBR()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventXCBR Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEventXCBR::RecloserEventXCBR( const RecloserEventXCBR & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventXCBR Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEventXCBR::~RecloserEventXCBR()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventXCBR Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserEventXCBR& openfmb::reclosermodule::RecloserEventXCBR::operator=( const openfmb::reclosermodule::RecloserEventXCBR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserEventXCBR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserEventXCBR init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEventXCBR::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventXCBR clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEventXCBR::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->Pos */
  this->Pos.clear( );
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventXCBR copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEventXCBR::copy( const RecloserEventXCBR * copy_from )
{

  RecloserEventXCBR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy Pos */
  copy_to->Pos.copy( &copy_from->Pos );

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventXCBR::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventXCBR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = Pos.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventXCBR::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventXCBR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventXCBR::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventXCBR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventXCBR::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventXCBR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventXCBR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventXCBR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventXCBR get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserEventXCBR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserEventXCBR,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusXCBR Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusXCBR::RecloserStatusXCBR()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusXCBR Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusXCBR::RecloserStatusXCBR( const RecloserStatusXCBR & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusXCBR Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusXCBR::~RecloserStatusXCBR()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusXCBR Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusXCBR& openfmb::reclosermodule::RecloserStatusXCBR::operator=( const openfmb::reclosermodule::RecloserStatusXCBR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserStatusXCBR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserStatusXCBR init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatusXCBR::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusXCBR clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatusXCBR::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->Pos */
  this->Pos.clear( );
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusXCBR copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatusXCBR::copy( const RecloserStatusXCBR * copy_from )
{

  RecloserStatusXCBR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy Pos */
  copy_to->Pos.copy( &copy_from->Pos );

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusXCBR::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusXCBR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = Pos.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusXCBR::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusXCBR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusXCBR::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusXCBR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusXCBR::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusXCBR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusXCBR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusXCBR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusXCBR get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserStatusXCBR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserStatusXCBR,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlXSWI Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchControlXSWI::SwitchControlXSWI()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlXSWI Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchControlXSWI::SwitchControlXSWI( const SwitchControlXSWI & other )
  : LogicalNodeForControl()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlXSWI Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchControlXSWI::~SwitchControlXSWI()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlXSWI Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchControlXSWI& openfmb::switchmodule::SwitchControlXSWI::operator=( const openfmb::switchmodule::SwitchControlXSWI & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchControlXSWI Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchControlXSWI init()
 ******************************************************************/
void openfmb::switchmodule::SwitchControlXSWI::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::init();
  this->Pos = NULL;
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlXSWI clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchControlXSWI::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::clear();
  if (this->Pos != NULL) {
    /* clear struct: (*this->Pos) */
    (*this->Pos).clear( );
    delete this->Pos;
    this->Pos = NULL;
  }
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlXSWI copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchControlXSWI::copy( const SwitchControlXSWI * copy_from )
{

  SwitchControlXSWI * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::copy( copy_from );
  /* copy Pos */
  if (copy_from->Pos) {
    copy_to->Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
    (*copy_to->Pos).copy( &(*copy_from->Pos) );
  }
  else
    copy_to->Pos = NULL;

}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlXSWI::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlXSWI::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (Pos != NULL) {
          offset = (*Pos).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlXSWI::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlXSWI::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForControl::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Pos != NULL) {
              offset = (*Pos).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Pos != NULL) {
              offset = (*Pos).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlXSWI::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlXSWI::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlXSWI::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlXSWI::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*Pos).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Pos = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*Pos).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Pos = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlXSWI::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlXSWI::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlXSWI get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchControlXSWI::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForControl::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchControlXSWI,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ControlDPC::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventXSWI Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchEventXSWI::SwitchEventXSWI()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventXSWI Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchEventXSWI::SwitchEventXSWI( const SwitchEventXSWI & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventXSWI Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchEventXSWI::~SwitchEventXSWI()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventXSWI Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchEventXSWI& openfmb::switchmodule::SwitchEventXSWI::operator=( const openfmb::switchmodule::SwitchEventXSWI & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchEventXSWI Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchEventXSWI init()
 ******************************************************************/
void openfmb::switchmodule::SwitchEventXSWI::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventXSWI clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchEventXSWI::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->Pos */
  this->Pos.clear( );
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventXSWI copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchEventXSWI::copy( const SwitchEventXSWI * copy_from )
{

  SwitchEventXSWI * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy Pos */
  copy_to->Pos.copy( &copy_from->Pos );

}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventXSWI::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventXSWI::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = Pos.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventXSWI::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventXSWI::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventXSWI::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventXSWI::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventXSWI::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventXSWI::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventXSWI::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventXSWI::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventXSWI get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchEventXSWI::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchEventXSWI,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusXSWI Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatusXSWI::SwitchStatusXSWI()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusXSWI Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatusXSWI::SwitchStatusXSWI( const SwitchStatusXSWI & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusXSWI Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatusXSWI::~SwitchStatusXSWI()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusXSWI Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchStatusXSWI& openfmb::switchmodule::SwitchStatusXSWI::operator=( const openfmb::switchmodule::SwitchStatusXSWI & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchStatusXSWI Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchStatusXSWI init()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatusXSWI::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusXSWI clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatusXSWI::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->Pos */
  this->Pos.clear( );
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusXSWI copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatusXSWI::copy( const SwitchStatusXSWI * copy_from )
{

  SwitchStatusXSWI * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy Pos */
  copy_to->Pos.copy( &copy_from->Pos );

}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusXSWI::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusXSWI::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = Pos.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusXSWI::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusXSWI::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusXSWI::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusXSWI::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusXSWI::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusXSWI::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusXSWI::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusXSWI::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusXSWI get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchStatusXSWI::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchStatusXSWI,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlXCBR Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerControlXCBR::BreakerControlXCBR()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlXCBR Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerControlXCBR::BreakerControlXCBR( const BreakerControlXCBR & other )
  : LogicalNodeForControl()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlXCBR Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerControlXCBR::~BreakerControlXCBR()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlXCBR Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerControlXCBR& openfmb::breakermodule::BreakerControlXCBR::operator=( const openfmb::breakermodule::BreakerControlXCBR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerControlXCBR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerControlXCBR init()
 ******************************************************************/
void openfmb::breakermodule::BreakerControlXCBR::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::init();
  this->Pos = NULL;
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlXCBR clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerControlXCBR::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::clear();
  if (this->Pos != NULL) {
    /* clear struct: (*this->Pos) */
    (*this->Pos).clear( );
    delete this->Pos;
    this->Pos = NULL;
  }
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlXCBR copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerControlXCBR::copy( const BreakerControlXCBR * copy_from )
{

  BreakerControlXCBR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::copy( copy_from );
  /* copy Pos */
  if (copy_from->Pos) {
    copy_to->Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
    (*copy_to->Pos).copy( &(*copy_from->Pos) );
  }
  else
    copy_to->Pos = NULL;

}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlXCBR::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlXCBR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (Pos != NULL) {
          offset = (*Pos).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlXCBR::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlXCBR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForControl::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Pos != NULL) {
              offset = (*Pos).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Pos != NULL) {
              offset = (*Pos).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlXCBR::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlXCBR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlXCBR::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlXCBR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*Pos).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Pos = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Pos = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*Pos).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Pos = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlXCBR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlXCBR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlXCBR get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerControlXCBR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForControl::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerControlXCBR,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ControlDPC::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventXCBR Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerEventXCBR::BreakerEventXCBR()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventXCBR Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerEventXCBR::BreakerEventXCBR( const BreakerEventXCBR & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventXCBR Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerEventXCBR::~BreakerEventXCBR()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventXCBR Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerEventXCBR& openfmb::breakermodule::BreakerEventXCBR::operator=( const openfmb::breakermodule::BreakerEventXCBR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerEventXCBR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerEventXCBR init()
 ******************************************************************/
void openfmb::breakermodule::BreakerEventXCBR::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventXCBR clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerEventXCBR::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->Pos */
  this->Pos.clear( );
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventXCBR copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerEventXCBR::copy( const BreakerEventXCBR * copy_from )
{

  BreakerEventXCBR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy Pos */
  copy_to->Pos.copy( &copy_from->Pos );

}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventXCBR::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventXCBR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = Pos.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventXCBR::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventXCBR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventXCBR::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventXCBR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventXCBR::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventXCBR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventXCBR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventXCBR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventXCBR get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerEventXCBR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerEventXCBR,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusXCBR Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatusXCBR::BreakerStatusXCBR()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusXCBR Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatusXCBR::BreakerStatusXCBR( const BreakerStatusXCBR & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusXCBR Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatusXCBR::~BreakerStatusXCBR()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusXCBR Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerStatusXCBR& openfmb::breakermodule::BreakerStatusXCBR::operator=( const openfmb::breakermodule::BreakerStatusXCBR & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerStatusXCBR Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerStatusXCBR init()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatusXCBR::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusXCBR clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatusXCBR::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->Pos */
  this->Pos.clear( );
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusXCBR copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatusXCBR::copy( const BreakerStatusXCBR * copy_from )
{

  BreakerStatusXCBR * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy Pos */
  copy_to->Pos.copy( &copy_from->Pos );

}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusXCBR::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusXCBR::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = Pos.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusXCBR::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusXCBR::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = Pos.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusXCBR::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusXCBR::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusXCBR::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusXCBR::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = Pos.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusXCBR::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusXCBR::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusXCBR get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerStatusXCBR::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Pos", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerStatusXCBR,Pos);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ASG Default Constructor
 ******************************************************************/
openfmb::commonmodule::ASG::ASG()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ASG Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ASG::ASG( const ASG & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ASG Destructor
 ******************************************************************/
openfmb::commonmodule::ASG::~ASG()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ASG Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ASG& openfmb::commonmodule::ASG::operator=( const openfmb::commonmodule::ASG & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ASG Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ASG init()
 ******************************************************************/
void openfmb::commonmodule::ASG::init()
{
  /* init struct: this->setMag */
  this->setMag.init( );
  this->units = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ASG clear()
 ******************************************************************/
void openfmb::commonmodule::ASG::clear()
{
  /* clear struct: this->setMag */
  this->setMag.clear( );
  if (this->units != NULL) {
    /* clear struct: (*this->units) */
    (*this->units).clear( );
    delete this->units;
    this->units = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ASG copy()
 ******************************************************************/
void openfmb::commonmodule::ASG::copy( const ASG * copy_from )
{

  ASG * copy_to = this;

  if ( ! copy_from ) return;


  /* copy setMag */
  copy_to->setMag.copy( &copy_from->setMag );

  /* copy units */
  if (copy_from->units) {
    copy_to->units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
    (*copy_to->units).copy( &(*copy_from->units) );
  }
  else
    copy_to->units = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::ASG::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ASG::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = setMag.get_marshal_size( offset, 0 );
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (units != NULL) {
          offset = (*units).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ASG::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ASG::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = setMag.marshal_cdr( buf, offset, stream_len, 1, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              offset = (*units).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = setMag.marshal_cdr( buf, offset, stream_len, 0, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              offset = (*units).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ASG::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ASG::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ASG::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ASG::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = setMag.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*units).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = setMag.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*units).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ASG::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ASG::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ASG get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ASG::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("setMag", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ASG,setMag);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::AnalogueValueCtl::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("units", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ASG,units);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::Unit::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::CMV Default Constructor
 ******************************************************************/
openfmb::commonmodule::CMV::CMV()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::CMV Copy Constructor
 ******************************************************************/
openfmb::commonmodule::CMV::CMV( const CMV & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::CMV Destructor
 ******************************************************************/
openfmb::commonmodule::CMV::~CMV()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::CMV Assignment Operator
 ******************************************************************/
openfmb::commonmodule::CMV& openfmb::commonmodule::CMV::operator=( const openfmb::commonmodule::CMV & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::CMV Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::CMV init()
 ******************************************************************/
void openfmb::commonmodule::CMV::init()
{
  /* init struct: this->cVal */
  this->cVal.init( );
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
  this->units = NULL;
}

/******************************************************************
 * openfmb::commonmodule::CMV clear()
 ******************************************************************/
void openfmb::commonmodule::CMV::clear()
{
  /* clear struct: this->cVal */
  this->cVal.clear( );
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
  if (this->units != NULL) {
    /* clear struct: (*this->units) */
    (*this->units).clear( );
    delete this->units;
    this->units = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::CMV copy()
 ******************************************************************/
void openfmb::commonmodule::CMV::copy( const CMV * copy_from )
{

  CMV * copy_to = this;

  if ( ! copy_from ) return;


  /* copy cVal */
  copy_to->cVal.copy( &copy_from->cVal );

  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

  /* copy units */
  if (copy_from->units) {
    copy_to->units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
    (*copy_to->units).copy( &(*copy_from->units) );
  }
  else
    copy_to->units = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::CMV::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::CMV::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = cVal.get_marshal_size( offset, 0 );
      /* q */
      offset += 2;
      /* t */
      offset += 8;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (units != NULL) {
          offset = (*units).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CMV::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::CMV::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = cVal.marshal_cdr( buf, offset, stream_len, 1, 0 );
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              offset = (*units).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = cVal.marshal_cdr( buf, offset, stream_len, 0, 0 );
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              offset = (*units).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CMV::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::CMV::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CMV::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::CMV::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = cVal.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*units).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = cVal.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*units).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CMV::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::CMV::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CMV get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::CMV::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("cVal", fieldname, 4) == 0) && 
       (fieldname[4] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::CMV,cVal);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::Vector::get_field_def(&fieldname[5], field_def);
  }
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::CMV,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::CMV,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::CMV,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::CMV,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("units", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::CMV,units);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::Unit::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlValue Default Constructor
 ******************************************************************/
openfmb::commonmodule::ControlValue::ControlValue()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ControlValue Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ControlValue::ControlValue( const ControlValue & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ControlValue Destructor
 ******************************************************************/
openfmb::commonmodule::ControlValue::~ControlValue()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ControlValue Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ControlValue& openfmb::commonmodule::ControlValue::operator=( const openfmb::commonmodule::ControlValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ControlValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ControlValue init()
 ******************************************************************/
void openfmb::commonmodule::ControlValue::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->modBlk = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ControlValue clear()
 ******************************************************************/
void openfmb::commonmodule::ControlValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  if (this->modBlk != NULL) {
    delete this->modBlk;
    this->modBlk = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ControlValue copy()
 ******************************************************************/
void openfmb::commonmodule::ControlValue::copy( const ControlValue * copy_from )
{

  ControlValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy modBlk */
  if (copy_from->modBlk) {
    copy_to->modBlk = (unsigned char*)new unsigned char();
    (*copy_to->modBlk) = (*copy_from->modBlk);
  }
  else
    copy_to->modBlk = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::ControlValue::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ControlValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 4; /* PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (modBlk != NULL) {
          /* (*modBlk) */
          offset += 1;
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValue::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (modBlk != NULL) {
              DDS_MARSH_PUT_BYTE(buf, offset, (*modBlk));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pidlen_offset = offset;
            pid_len = 0;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (modBlk != NULL) {
              DDS_MARSH_PUT_BYTE(buf, offset, (*modBlk));
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_SHORT(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValue::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                modBlk = (unsigned char*)new unsigned char();
                DDS_MARSH_GET_BYTE(buf, offset, (*modBlk), stream_len);
              }
              else {
                modBlk = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                modBlk = (unsigned char*)new unsigned char();
                DDS_MARSH_GET_BYTE(buf, offset, (*modBlk), stream_len);
              }
              else {
                modBlk = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ControlValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("modBlk", fieldname)==0) {
    field_def->kind       = 71;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ControlValue,modBlk);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ControlValue,modBlk);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlValueSource Default Constructor
 ******************************************************************/
openfmb::commonmodule::ControlValueSource::ControlValueSource()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ControlValueSource Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ControlValueSource::ControlValueSource( const ControlValueSource & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ControlValueSource Destructor
 ******************************************************************/
openfmb::commonmodule::ControlValueSource::~ControlValueSource()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ControlValueSource Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ControlValueSource& openfmb::commonmodule::ControlValueSource::operator=( const openfmb::commonmodule::ControlValueSource & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ControlValueSource Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ControlValueSource init()
 ******************************************************************/
void openfmb::commonmodule::ControlValueSource::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_ControlValueSource = 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlValueSource clear()
 ******************************************************************/
void openfmb::commonmodule::ControlValueSource::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_ControlValueSource NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::ControlValueSource copy()
 ******************************************************************/
void openfmb::commonmodule::ControlValueSource::copy( const ControlValueSource * copy_from )
{

  ControlValueSource * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_ControlValueSource */
  copy_to->__dummy_prevent_empty_class_ControlValueSource = copy_from->__dummy_prevent_empty_class_ControlValueSource;

}

/******************************************************************
 *  openfmb::commonmodule::ControlValueSource::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ControlValueSource::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_ControlValueSource */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValueSource::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlValueSource::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ControlValueSource);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ControlValueSource);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValueSource::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlValueSource::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValueSource::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlValueSource::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ControlValueSource, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ControlValueSource, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValueSource::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlValueSource::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlValueSource get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ControlValueSource::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_ControlValueSource", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ControlValueSource,__dummy_prevent_empty_class_ControlValueSource);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ControlValueSource,__dummy_prevent_empty_class_ControlValueSource);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::CSG Default Constructor
 ******************************************************************/
openfmb::commonmodule::CSG::CSG()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::CSG Copy Constructor
 ******************************************************************/
openfmb::commonmodule::CSG::CSG( const CSG & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::CSG Destructor
 ******************************************************************/
openfmb::commonmodule::CSG::~CSG()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::CSG Assignment Operator
 ******************************************************************/
openfmb::commonmodule::CSG& openfmb::commonmodule::CSG::operator=( const openfmb::commonmodule::CSG & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::CSG Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::CSG init()
 ******************************************************************/
void openfmb::commonmodule::CSG::init()
{
  /* init struct: this->xUnits */
  this->xUnits.init( );
  /* init struct: this->yUnits */
  this->yUnits.init( );
  this->zUnits = NULL;
  this->xDU = NULL;
  this->yDU = NULL;
  this->zD = NULL;
  this->zDU = NULL;
}

/******************************************************************
 * openfmb::commonmodule::CSG clear()
 ******************************************************************/
void openfmb::commonmodule::CSG::clear()
{
  /* clear sequence: this->crvPts */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->crvPts.size(); i_0++)
      {
        /* clear struct: this->crvPts[i_0] */
        this->crvPts[i_0].clear( );
      }
    this->crvPts.clear();
  }
  /* clear struct: this->xUnits */
  this->xUnits.clear( );
  /* clear struct: this->yUnits */
  this->yUnits.clear( );
  if (this->zUnits != NULL) {
    /* clear struct: (*this->zUnits) */
    (*this->zUnits).clear( );
    delete this->zUnits;
    this->zUnits = NULL;
  }
  /* clear sequence: this->xD */
  {
    unsigned int i_1;
    for (i_1 = 0; i_1 < this->xD.size(); i_1++)
      {
        /* clear string: this->xD[i_1] */
        if (this->xD[i_1] != NULL) {
          delete[] this->xD[i_1];
          this->xD[i_1] = NULL;
        }
      }
    this->xD.clear();
  }
  if (this->xDU != NULL) {
    /* clear sequence: (*this->xDU) */
    {
      unsigned int i_2;
      for (i_2 = 0; i_2 < (*this->xDU).size(); i_2++)
        {
          /* clear string: (*this->xDU)[i_2] */
          if ((*this->xDU)[i_2] != NULL) {
            delete[] (*this->xDU)[i_2];
            (*this->xDU)[i_2] = NULL;
          }
        }
      (*this->xDU).clear();
    }
    delete this->xDU;
    this->xDU = NULL;
  }
  /* clear sequence: this->yD */
  {
    unsigned int i_3;
    for (i_3 = 0; i_3 < this->yD.size(); i_3++)
      {
        /* clear string: this->yD[i_3] */
        if (this->yD[i_3] != NULL) {
          delete[] this->yD[i_3];
          this->yD[i_3] = NULL;
        }
      }
    this->yD.clear();
  }
  if (this->yDU != NULL) {
    /* clear sequence: (*this->yDU) */
    {
      unsigned int i_4;
      for (i_4 = 0; i_4 < (*this->yDU).size(); i_4++)
        {
          /* clear string: (*this->yDU)[i_4] */
          if ((*this->yDU)[i_4] != NULL) {
            delete[] (*this->yDU)[i_4];
            (*this->yDU)[i_4] = NULL;
          }
        }
      (*this->yDU).clear();
    }
    delete this->yDU;
    this->yDU = NULL;
  }
  if (this->zD != NULL) {
    /* clear sequence: (*this->zD) */
    {
      unsigned int i_5;
      for (i_5 = 0; i_5 < (*this->zD).size(); i_5++)
        {
          /* clear string: (*this->zD)[i_5] */
          if ((*this->zD)[i_5] != NULL) {
            delete[] (*this->zD)[i_5];
            (*this->zD)[i_5] = NULL;
          }
        }
      (*this->zD).clear();
    }
    delete this->zD;
    this->zD = NULL;
  }
  if (this->zDU != NULL) {
    /* clear sequence: (*this->zDU) */
    {
      unsigned int i_6;
      for (i_6 = 0; i_6 < (*this->zDU).size(); i_6++)
        {
          /* clear string: (*this->zDU)[i_6] */
          if ((*this->zDU)[i_6] != NULL) {
            delete[] (*this->zDU)[i_6];
            (*this->zDU)[i_6] = NULL;
          }
        }
      (*this->zDU).clear();
    }
    delete this->zDU;
    this->zDU = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::CSG copy()
 ******************************************************************/
void openfmb::commonmodule::CSG::copy( const CSG * copy_from )
{

  CSG * copy_to = this;

  if ( ! copy_from ) return;


  /* copy crvPts */
  copy_to->crvPts.resize(copy_from->crvPts.size());
  if ( copy_from->crvPts.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->crvPts.size(); i_1++)
        {
          copy_to->crvPts[i_1].copy( &copy_from->crvPts[i_1] );
        }
    }

  /* copy xUnits */
  copy_to->xUnits.copy( &copy_from->xUnits );

  /* copy yUnits */
  copy_to->yUnits.copy( &copy_from->yUnits );

  /* copy zUnits */
  if (copy_from->zUnits) {
    copy_to->zUnits = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
    (*copy_to->zUnits).copy( &(*copy_from->zUnits) );
  }
  else
    copy_to->zUnits = NULL;

  /* copy xD */
  copy_to->xD.resize(copy_from->xD.size());
  if ( copy_from->xD.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->xD.size(); i_1++)
        {
          if (copy_from->xD[i_1]) {
            copy_to->xD[i_1] = new char[strlen(copy_from->xD[i_1]) + 1];
            strcpy( copy_to->xD[i_1], copy_from->xD[i_1] );
          }
        }
    }

  /* copy xDU */
  if (copy_from->xDU) {
    copy_to->xDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
    (*copy_to->xDU).resize((*copy_from->xDU).size());
    if ( (*copy_from->xDU).size() )
      {
        unsigned int i_1;
        for (i_1 = 0; i_1 < (*copy_from->xDU).size(); i_1++)
          {
            if ((*copy_from->xDU)[i_1]) {
              (*copy_to->xDU)[i_1] = new char[strlen((*copy_from->xDU)[i_1]) + 1];
              strcpy( (*copy_to->xDU)[i_1], (*copy_from->xDU)[i_1] );
            }
          }
      }
  }
  else
    copy_to->xDU = NULL;

  /* copy yD */
  copy_to->yD.resize(copy_from->yD.size());
  if ( copy_from->yD.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->yD.size(); i_1++)
        {
          if (copy_from->yD[i_1]) {
            copy_to->yD[i_1] = new char[strlen(copy_from->yD[i_1]) + 1];
            strcpy( copy_to->yD[i_1], copy_from->yD[i_1] );
          }
        }
    }

  /* copy yDU */
  if (copy_from->yDU) {
    copy_to->yDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
    (*copy_to->yDU).resize((*copy_from->yDU).size());
    if ( (*copy_from->yDU).size() )
      {
        unsigned int i_1;
        for (i_1 = 0; i_1 < (*copy_from->yDU).size(); i_1++)
          {
            if ((*copy_from->yDU)[i_1]) {
              (*copy_to->yDU)[i_1] = new char[strlen((*copy_from->yDU)[i_1]) + 1];
              strcpy( (*copy_to->yDU)[i_1], (*copy_from->yDU)[i_1] );
            }
          }
      }
  }
  else
    copy_to->yDU = NULL;

  /* copy zD */
  if (copy_from->zD) {
    copy_to->zD = (openfmb::commonmodule::VisString255*)new openfmb::commonmodule::VisString255();
    (*copy_to->zD).resize((*copy_from->zD).size());
    if ( (*copy_from->zD).size() )
      {
        unsigned int i_1;
        for (i_1 = 0; i_1 < (*copy_from->zD).size(); i_1++)
          {
            if ((*copy_from->zD)[i_1]) {
              (*copy_to->zD)[i_1] = new char[strlen((*copy_from->zD)[i_1]) + 1];
              strcpy( (*copy_to->zD)[i_1], (*copy_from->zD)[i_1] );
            }
          }
      }
  }
  else
    copy_to->zD = NULL;

  /* copy zDU */
  if (copy_from->zDU) {
    copy_to->zDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
    (*copy_to->zDU).resize((*copy_from->zDU).size());
    if ( (*copy_from->zDU).size() )
      {
        unsigned int i_1;
        for (i_1 = 0; i_1 < (*copy_from->zDU).size(); i_1++)
          {
            if ((*copy_from->zDU)[i_1]) {
              (*copy_to->zDU)[i_1] = new char[strlen((*copy_from->zDU)[i_1]) + 1];
              strcpy( (*copy_to->zDU)[i_1], (*copy_from->zDU)[i_1] );
            }
          }
      }
  }
  else
    copy_to->zDU = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::CSG::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::CSG::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      /* crvPts*/
      /* crvPts.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < crvPts.size(); ii1++ ) {
           offset = crvPts[ii1].get_marshal_size( offset, 0 );
         }
      }
      offset = xUnits.get_marshal_size( offset, 0 );
      offset = yUnits.get_marshal_size( offset, 0 );
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (zUnits != NULL) {
          offset = (*zUnits).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      /* xD*/
      /* xD.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii6;
         for (ii6 = 0; ii6 < xD.size(); ii6++ ) {
           /* xD[ii6] */
           offset = (offset+3) & 0xfffffffc;/* align 4 */
           offset += 4;
           offset += (xD[ii6]==NULL)?1:(unsigned int)((strlen(xD[ii6])+1)*1);
         }
      }
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (xDU != NULL) {
          /* (*xDU)*/
          /* (*xDU).length */
          offset = (offset+3) & 0xfffffffc;/* align 4*/
          offset += 4;
          {
             unsigned int ii8;
             for (ii8 = 0; ii8 < (*xDU).size(); ii8++ ) {
               /* (*xDU)[ii8] */
               offset = (offset+3) & 0xfffffffc;/* align 4 */
               offset += 4;
               offset += ((*xDU)[ii8]==NULL)?1:(unsigned int)((strlen((*xDU)[ii8])+1)*1);
             }
          }
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      /* yD*/
      /* yD.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii10;
         for (ii10 = 0; ii10 < yD.size(); ii10++ ) {
           /* yD[ii10] */
           offset = (offset+3) & 0xfffffffc;/* align 4 */
           offset += 4;
           offset += (yD[ii10]==NULL)?1:(unsigned int)((strlen(yD[ii10])+1)*1);
         }
      }
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (yDU != NULL) {
          /* (*yDU)*/
          /* (*yDU).length */
          offset = (offset+3) & 0xfffffffc;/* align 4*/
          offset += 4;
          {
             unsigned int ii12;
             for (ii12 = 0; ii12 < (*yDU).size(); ii12++ ) {
               /* (*yDU)[ii12] */
               offset = (offset+3) & 0xfffffffc;/* align 4 */
               offset += 4;
               offset += ((*yDU)[ii12]==NULL)?1:(unsigned int)((strlen((*yDU)[ii12])+1)*1);
             }
          }
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (zD != NULL) {
          /* (*zD)*/
          /* (*zD).length */
          offset = (offset+3) & 0xfffffffc;/* align 4*/
          offset += 4;
          {
             unsigned int ii14;
             for (ii14 = 0; ii14 < (*zD).size(); ii14++ ) {
               /* (*zD)[ii14] */
               offset = (offset+3) & 0xfffffffc;/* align 4 */
               offset += 4;
               offset += ((*zD)[ii14]==NULL)?1:(unsigned int)((strlen((*zD)[ii14])+1)*1);
             }
          }
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (zDU != NULL) {
          /* (*zDU)*/
          /* (*zDU).length */
          offset = (offset+3) & 0xfffffffc;/* align 4*/
          offset += 4;
          {
             unsigned int ii16;
             for (ii16 = 0; ii16 < (*zDU).size(); ii16++ ) {
               /* (*zDU)[ii16] */
               offset = (offset+3) & 0xfffffffc;/* align 4 */
               offset += 4;
               offset += ((*zDU)[ii16]==NULL)?1:(unsigned int)((strlen((*zDU)[ii16])+1)*1);
             }
          }
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CSG::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::CSG::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* crvPts */
          {
            unsigned int sl = (unsigned int)crvPts.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < crvPts.size(); i1++)
            {
              offset = crvPts[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* crvPts */
          offset = xUnits.marshal_cdr( buf, offset, stream_len, 1, 0 );
          offset = yUnits.marshal_cdr( buf, offset, stream_len, 1, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zUnits != NULL) {
              offset = (*zUnits).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          /* xD */
          {
            unsigned int sl = (unsigned int)xD.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i6;
          for (i6=0; i6 < xD.size(); i6++)
            {
              { int len = 1;
              if ( xD[i6] ) len += (int)strlen( xD[i6] );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, xD[i6], len);
              }
            } 
          }  /* xD */
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (xDU != NULL) {
              /* (*xDU) */
              {
                unsigned int sl = (unsigned int)(*xDU).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i8;
              for (i8=0; i8 < (*xDU).size(); i8++)
                {
                  { int len = 1;
                  if ( (*xDU)[i8] ) len += (int)strlen( (*xDU)[i8] );
                  DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*xDU)[i8], len);
                  }
                } 
              }  /* (*xDU) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          /* yD */
          {
            unsigned int sl = (unsigned int)yD.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i10;
          for (i10=0; i10 < yD.size(); i10++)
            {
              { int len = 1;
              if ( yD[i10] ) len += (int)strlen( yD[i10] );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, yD[i10], len);
              }
            } 
          }  /* yD */
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (yDU != NULL) {
              /* (*yDU) */
              {
                unsigned int sl = (unsigned int)(*yDU).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i12;
              for (i12=0; i12 < (*yDU).size(); i12++)
                {
                  { int len = 1;
                  if ( (*yDU)[i12] ) len += (int)strlen( (*yDU)[i12] );
                  DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*yDU)[i12], len);
                  }
                } 
              }  /* (*yDU) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zD != NULL) {
              /* (*zD) */
              {
                unsigned int sl = (unsigned int)(*zD).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i14;
              for (i14=0; i14 < (*zD).size(); i14++)
                {
                  { int len = 1;
                  if ( (*zD)[i14] ) len += (int)strlen( (*zD)[i14] );
                  DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*zD)[i14], len);
                  }
                } 
              }  /* (*zD) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zDU != NULL) {
              /* (*zDU) */
              {
                unsigned int sl = (unsigned int)(*zDU).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i16;
              for (i16=0; i16 < (*zDU).size(); i16++)
                {
                  { int len = 1;
                  if ( (*zDU)[i16] ) len += (int)strlen( (*zDU)[i16] );
                  DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*zDU)[i16], len);
                  }
                } 
              }  /* (*zDU) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          /* crvPts */
          {
            unsigned int sl = (unsigned int)crvPts.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < crvPts.size(); i1++)
            {
              offset = crvPts[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* crvPts */
          offset = xUnits.marshal_cdr( buf, offset, stream_len, 0, 0 );
          offset = yUnits.marshal_cdr( buf, offset, stream_len, 0, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zUnits != NULL) {
              offset = (*zUnits).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          /* xD */
          {
            unsigned int sl = (unsigned int)xD.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i6;
          for (i6=0; i6 < xD.size(); i6++)
            {
              { int len = 1;
              if ( xD[i6] ) len += (int)strlen( xD[i6] );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, xD[i6], len);
              }
            } 
          }  /* xD */
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (xDU != NULL) {
              /* (*xDU) */
              {
                unsigned int sl = (unsigned int)(*xDU).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i8;
              for (i8=0; i8 < (*xDU).size(); i8++)
                {
                  { int len = 1;
                  if ( (*xDU)[i8] ) len += (int)strlen( (*xDU)[i8] );
                  DDS_MARSH_PUT_LONG(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*xDU)[i8], len);
                  }
                } 
              }  /* (*xDU) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          /* yD */
          {
            unsigned int sl = (unsigned int)yD.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i10;
          for (i10=0; i10 < yD.size(); i10++)
            {
              { int len = 1;
              if ( yD[i10] ) len += (int)strlen( yD[i10] );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, yD[i10], len);
              }
            } 
          }  /* yD */
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (yDU != NULL) {
              /* (*yDU) */
              {
                unsigned int sl = (unsigned int)(*yDU).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i12;
              for (i12=0; i12 < (*yDU).size(); i12++)
                {
                  { int len = 1;
                  if ( (*yDU)[i12] ) len += (int)strlen( (*yDU)[i12] );
                  DDS_MARSH_PUT_LONG(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*yDU)[i12], len);
                  }
                } 
              }  /* (*yDU) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zD != NULL) {
              /* (*zD) */
              {
                unsigned int sl = (unsigned int)(*zD).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i14;
              for (i14=0; i14 < (*zD).size(); i14++)
                {
                  { int len = 1;
                  if ( (*zD)[i14] ) len += (int)strlen( (*zD)[i14] );
                  DDS_MARSH_PUT_LONG(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*zD)[i14], len);
                  }
                } 
              }  /* (*zD) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (zDU != NULL) {
              /* (*zDU) */
              {
                unsigned int sl = (unsigned int)(*zDU).size();
                DDS_MARSH_PUT_LONG(buf, offset, sl);
              }
               {              unsigned int    i16;
              for (i16=0; i16 < (*zDU).size(); i16++)
                {
                  { int len = 1;
                  if ( (*zDU)[i16] ) len += (int)strlen( (*zDU)[i16] );
                  DDS_MARSH_PUT_LONG(buf, offset, len);
                  DDS_MARSH_PUT_STR(buf, offset, (*zDU)[i16], len);
                  }
                } 
              }  /* (*zDU) */
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CSG::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::CSG::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CSG::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::CSG::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            crvPts.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < crvPts.capacity(); ii1++)
            {
              offset = crvPts[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* crvPts */
          offset = xUnits.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          offset = yUnits.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zUnits = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*zUnits).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                zUnits = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            xD.resize(sl);
          }
           {          unsigned int    ii6;
          for (ii6=0; ii6 < xD.capacity(); ii6++)
            {
              { int len;
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
              xD[ii6] = new char[len];
              DDS_MARSH_GET_STR(buf, offset, xD[ii6], len, stream_len);
              }
            } 
          }  /* xD */
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                xDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
                  (*xDU).resize(sl);
                }
                 {                unsigned int    ii7;
                for (ii7=0; ii7 < (*xDU).capacity(); ii7++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                    (*xDU)[ii7] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*xDU)[ii7], len, stream_len);
                    }
                  } 
                }  /* (*xDU) */
              }
              else {
                xDU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            yD.resize(sl);
          }
           {          unsigned int    ii8;
          for (ii8=0; ii8 < yD.capacity(); ii8++)
            {
              { int len;
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
              yD[ii8] = new char[len];
              DDS_MARSH_GET_STR(buf, offset, yD[ii8], len, stream_len);
              }
            } 
          }  /* yD */
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                yDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
                  (*yDU).resize(sl);
                }
                 {                unsigned int    ii9;
                for (ii9=0; ii9 < (*yDU).capacity(); ii9++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                    (*yDU)[ii9] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*yDU)[ii9], len, stream_len);
                    }
                  } 
                }  /* (*yDU) */
              }
              else {
                yDU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zD = (openfmb::commonmodule::VisString255*)new openfmb::commonmodule::VisString255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
                  (*zD).resize(sl);
                }
                 {                unsigned int    ii10;
                for (ii10=0; ii10 < (*zD).capacity(); ii10++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                    (*zD)[ii10] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*zD)[ii10], len, stream_len);
                    }
                  } 
                }  /* (*zD) */
              }
              else {
                zD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
                  (*zDU).resize(sl);
                }
                 {                unsigned int    ii11;
                for (ii11=0; ii11 < (*zDU).capacity(); ii11++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                    (*zDU)[ii11] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*zDU)[ii11], len, stream_len);
                    }
                  } 
                }  /* (*zDU) */
              }
              else {
                zDU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            crvPts.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < crvPts.capacity(); ii1++)
            {
              offset = crvPts[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* crvPts */
          offset = xUnits.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          offset = yUnits.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zUnits = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*zUnits).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                zUnits = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            xD.resize(sl);
          }
           {          unsigned int    ii6;
          for (ii6=0; ii6 < xD.capacity(); ii6++)
            {
              { int len;
              DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
              xD[ii6] = new char[len];
              DDS_MARSH_GET_STR(buf, offset, xD[ii6], len, stream_len);
              }
            } 
          }  /* xD */
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                xDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
                  (*xDU).resize(sl);
                }
                 {                unsigned int    ii7;
                for (ii7=0; ii7 < (*xDU).capacity(); ii7++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                    (*xDU)[ii7] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*xDU)[ii7], len, stream_len);
                    }
                  } 
                }  /* (*xDU) */
              }
              else {
                xDU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            yD.resize(sl);
          }
           {          unsigned int    ii8;
          for (ii8=0; ii8 < yD.capacity(); ii8++)
            {
              { int len;
              DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
              yD[ii8] = new char[len];
              DDS_MARSH_GET_STR(buf, offset, yD[ii8], len, stream_len);
              }
            } 
          }  /* yD */
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                yDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
                  (*yDU).resize(sl);
                }
                 {                unsigned int    ii9;
                for (ii9=0; ii9 < (*yDU).capacity(); ii9++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                    (*yDU)[ii9] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*yDU)[ii9], len, stream_len);
                    }
                  } 
                }  /* (*yDU) */
              }
              else {
                yDU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zD = (openfmb::commonmodule::VisString255*)new openfmb::commonmodule::VisString255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
                  (*zD).resize(sl);
                }
                 {                unsigned int    ii10;
                for (ii10=0; ii10 < (*zD).capacity(); ii10++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                    (*zD)[ii10] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*zD)[ii10], len, stream_len);
                    }
                  } 
                }  /* (*zD) */
              }
              else {
                zD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                zDU = (openfmb::commonmodule::Unicode255*)new openfmb::commonmodule::Unicode255();
                {
                  unsigned int sl;
                  DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
                  (*zDU).resize(sl);
                }
                 {                unsigned int    ii11;
                for (ii11=0; ii11 < (*zDU).capacity(); ii11++)
                  {
                    { int len;
                    DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                    (*zDU)[ii11] = new char[len];
                    DDS_MARSH_GET_STR(buf, offset, (*zDU)[ii11], len, stream_len);
                    }
                  } 
                }  /* (*zDU) */
              }
              else {
                zDU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CSG::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::CSG::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::CSG get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::CSG::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("xUnits", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::CSG,xUnits);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::Unit::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("yUnits", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::CSG,yUnits);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::Unit::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("zUnits", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::CSG,zUnits);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::Unit::get_field_def(&fieldname[7], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::DEL Default Constructor
 ******************************************************************/
openfmb::commonmodule::DEL::DEL()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::DEL Copy Constructor
 ******************************************************************/
openfmb::commonmodule::DEL::DEL( const DEL & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::DEL Destructor
 ******************************************************************/
openfmb::commonmodule::DEL::~DEL()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::DEL Assignment Operator
 ******************************************************************/
openfmb::commonmodule::DEL& openfmb::commonmodule::DEL::operator=( const openfmb::commonmodule::DEL & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::DEL Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::DEL init()
 ******************************************************************/
void openfmb::commonmodule::DEL::init()
{
  this->phsAB = NULL;
  this->phsBC = NULL;
  this->phsCA = NULL;
}

/******************************************************************
 * openfmb::commonmodule::DEL clear()
 ******************************************************************/
void openfmb::commonmodule::DEL::clear()
{
  if (this->phsAB != NULL) {
    /* clear struct: (*this->phsAB) */
    (*this->phsAB).clear( );
    delete this->phsAB;
    this->phsAB = NULL;
  }
  if (this->phsBC != NULL) {
    /* clear struct: (*this->phsBC) */
    (*this->phsBC).clear( );
    delete this->phsBC;
    this->phsBC = NULL;
  }
  if (this->phsCA != NULL) {
    /* clear struct: (*this->phsCA) */
    (*this->phsCA).clear( );
    delete this->phsCA;
    this->phsCA = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::DEL copy()
 ******************************************************************/
void openfmb::commonmodule::DEL::copy( const DEL * copy_from )
{

  DEL * copy_to = this;

  if ( ! copy_from ) return;


  /* copy phsAB */
  if (copy_from->phsAB) {
    copy_to->phsAB = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->phsAB).copy( &(*copy_from->phsAB) );
  }
  else
    copy_to->phsAB = NULL;

  /* copy phsBC */
  if (copy_from->phsBC) {
    copy_to->phsBC = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->phsBC).copy( &(*copy_from->phsBC) );
  }
  else
    copy_to->phsBC = NULL;

  /* copy phsCA */
  if (copy_from->phsCA) {
    copy_to->phsCA = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->phsCA).copy( &(*copy_from->phsCA) );
  }
  else
    copy_to->phsCA = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::DEL::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::DEL::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (phsAB != NULL) {
          offset = (*phsAB).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (phsBC != NULL) {
          offset = (*phsBC).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (phsCA != NULL) {
          offset = (*phsCA).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DEL::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::DEL::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsAB != NULL) {
              offset = (*phsAB).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsBC != NULL) {
              offset = (*phsBC).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsCA != NULL) {
              offset = (*phsCA).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsAB != NULL) {
              offset = (*phsAB).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsBC != NULL) {
              offset = (*phsBC).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsCA != NULL) {
              offset = (*phsCA).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DEL::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::DEL::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DEL::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::DEL::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsAB = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsAB).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsAB = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsBC = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsBC).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsBC = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsCA = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsCA).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsCA = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsAB = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsAB).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsAB = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsBC = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsBC).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsBC = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsCA = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsCA).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsCA = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DEL::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::DEL::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::DEL get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::DEL::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("phsAB", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::DEL,phsAB);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("phsBC", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::DEL,phsBC);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("phsCA", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::DEL,phsCA);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::EventValue Default Constructor
 ******************************************************************/
openfmb::commonmodule::EventValue::EventValue()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::EventValue Copy Constructor
 ******************************************************************/
openfmb::commonmodule::EventValue::EventValue( const EventValue & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::EventValue Destructor
 ******************************************************************/
openfmb::commonmodule::EventValue::~EventValue()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::EventValue Assignment Operator
 ******************************************************************/
openfmb::commonmodule::EventValue& openfmb::commonmodule::EventValue::operator=( const openfmb::commonmodule::EventValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::EventValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::EventValue init()
 ******************************************************************/
void openfmb::commonmodule::EventValue::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_EventValue = 0;
}

/******************************************************************
 * openfmb::commonmodule::EventValue clear()
 ******************************************************************/
void openfmb::commonmodule::EventValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_EventValue NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::EventValue copy()
 ******************************************************************/
void openfmb::commonmodule::EventValue::copy( const EventValue * copy_from )
{

  EventValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_EventValue */
  copy_to->__dummy_prevent_empty_class_EventValue = copy_from->__dummy_prevent_empty_class_EventValue;

}

/******************************************************************
 *  openfmb::commonmodule::EventValue::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::EventValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_EventValue */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValue::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::EventValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_EventValue);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_EventValue);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValue::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::EventValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::EventValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_EventValue, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_EventValue, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::EventValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::EventValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_EventValue", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::EventValue,__dummy_prevent_empty_class_EventValue);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::EventValue,__dummy_prevent_empty_class_EventValue);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::EventValueSource Default Constructor
 ******************************************************************/
openfmb::commonmodule::EventValueSource::EventValueSource()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::EventValueSource Copy Constructor
 ******************************************************************/
openfmb::commonmodule::EventValueSource::EventValueSource( const EventValueSource & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::EventValueSource Destructor
 ******************************************************************/
openfmb::commonmodule::EventValueSource::~EventValueSource()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::EventValueSource Assignment Operator
 ******************************************************************/
openfmb::commonmodule::EventValueSource& openfmb::commonmodule::EventValueSource::operator=( const openfmb::commonmodule::EventValueSource & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::EventValueSource Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::EventValueSource init()
 ******************************************************************/
void openfmb::commonmodule::EventValueSource::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_EventValueSource = 0;
}

/******************************************************************
 * openfmb::commonmodule::EventValueSource clear()
 ******************************************************************/
void openfmb::commonmodule::EventValueSource::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_EventValueSource NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::EventValueSource copy()
 ******************************************************************/
void openfmb::commonmodule::EventValueSource::copy( const EventValueSource * copy_from )
{

  EventValueSource * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_EventValueSource */
  copy_to->__dummy_prevent_empty_class_EventValueSource = copy_from->__dummy_prevent_empty_class_EventValueSource;

}

/******************************************************************
 *  openfmb::commonmodule::EventValueSource::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::EventValueSource::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_EventValueSource */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValueSource::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::EventValueSource::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_EventValueSource);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_EventValueSource);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValueSource::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::EventValueSource::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValueSource::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::EventValueSource::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_EventValueSource, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_EventValueSource, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValueSource::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::EventValueSource::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventValueSource get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::EventValueSource::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_EventValueSource", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::EventValueSource,__dummy_prevent_empty_class_EventValueSource);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::EventValueSource,__dummy_prevent_empty_class_EventValueSource);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ForecastValue Default Constructor
 ******************************************************************/
openfmb::commonmodule::ForecastValue::ForecastValue()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ForecastValue Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ForecastValue::ForecastValue( const ForecastValue & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ForecastValue Destructor
 ******************************************************************/
openfmb::commonmodule::ForecastValue::~ForecastValue()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ForecastValue Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ForecastValue& openfmb::commonmodule::ForecastValue::operator=( const openfmb::commonmodule::ForecastValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ForecastValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ForecastValue init()
 ******************************************************************/
void openfmb::commonmodule::ForecastValue::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_ForecastValue = 0;
}

/******************************************************************
 * openfmb::commonmodule::ForecastValue clear()
 ******************************************************************/
void openfmb::commonmodule::ForecastValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_ForecastValue NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValue copy()
 ******************************************************************/
void openfmb::commonmodule::ForecastValue::copy( const ForecastValue * copy_from )
{

  ForecastValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_ForecastValue */
  copy_to->__dummy_prevent_empty_class_ForecastValue = copy_from->__dummy_prevent_empty_class_ForecastValue;

}

/******************************************************************
 *  openfmb::commonmodule::ForecastValue::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ForecastValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_ForecastValue */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValue::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ForecastValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValue);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValue);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValue::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ForecastValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ForecastValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValue, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValue, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ForecastValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ForecastValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_ForecastValue", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ForecastValue,__dummy_prevent_empty_class_ForecastValue);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ForecastValue,__dummy_prevent_empty_class_ForecastValue);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ForecastValueSource Default Constructor
 ******************************************************************/
openfmb::commonmodule::ForecastValueSource::ForecastValueSource()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ForecastValueSource Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ForecastValueSource::ForecastValueSource( const ForecastValueSource & other )
  : IdentifiedObject()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ForecastValueSource Destructor
 ******************************************************************/
openfmb::commonmodule::ForecastValueSource::~ForecastValueSource()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ForecastValueSource Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ForecastValueSource& openfmb::commonmodule::ForecastValueSource::operator=( const openfmb::commonmodule::ForecastValueSource & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ForecastValueSource Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ForecastValueSource init()
 ******************************************************************/
void openfmb::commonmodule::ForecastValueSource::init()
{
  /* init PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::init();
  this->__dummy_prevent_empty_class_ForecastValueSource = 0;
}

/******************************************************************
 * openfmb::commonmodule::ForecastValueSource clear()
 ******************************************************************/
void openfmb::commonmodule::ForecastValueSource::clear()
{
  /* clear PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_ForecastValueSource NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValueSource copy()
 ******************************************************************/
void openfmb::commonmodule::ForecastValueSource::copy( const ForecastValueSource * copy_from )
{

  ForecastValueSource * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::IdentifiedObject */
  openfmb::commonmodule::IdentifiedObject::copy( copy_from );
  /* copy __dummy_prevent_empty_class_ForecastValueSource */
  copy_to->__dummy_prevent_empty_class_ForecastValueSource = copy_from->__dummy_prevent_empty_class_ForecastValueSource;

}

/******************************************************************
 *  openfmb::commonmodule::ForecastValueSource::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ForecastValueSource::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_ForecastValueSource */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValueSource::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ForecastValueSource::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::IdentifiedObject::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValueSource);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValueSource);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValueSource::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ForecastValueSource::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValueSource::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ForecastValueSource::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::IdentifiedObject::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValueSource, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ForecastValueSource, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValueSource::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ForecastValueSource::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastValueSource get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ForecastValueSource::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::IdentifiedObject::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_ForecastValueSource", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ForecastValueSource,__dummy_prevent_empty_class_ForecastValueSource);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ForecastValueSource,__dummy_prevent_empty_class_ForecastValueSource);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::GenerationEventZGEN Default Constructor
 ******************************************************************/
openfmb::commonmodule::GenerationEventZGEN::GenerationEventZGEN()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::GenerationEventZGEN Copy Constructor
 ******************************************************************/
openfmb::commonmodule::GenerationEventZGEN::GenerationEventZGEN( const GenerationEventZGEN & other )
  : GenerationEventAndStatusZGEN()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::GenerationEventZGEN Destructor
 ******************************************************************/
openfmb::commonmodule::GenerationEventZGEN::~GenerationEventZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::GenerationEventZGEN Assignment Operator
 ******************************************************************/
openfmb::commonmodule::GenerationEventZGEN& openfmb::commonmodule::GenerationEventZGEN::operator=( const openfmb::commonmodule::GenerationEventZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::GenerationEventZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::GenerationEventZGEN init()
 ******************************************************************/
void openfmb::commonmodule::GenerationEventZGEN::init()
{
  /* init PARENT: openfmb::generationmodule::GenerationEventAndStatusZGEN */
  openfmb::generationmodule::GenerationEventAndStatusZGEN::init();
  this->__dummy_prevent_empty_class_GenerationEventZGEN = 0;
}

/******************************************************************
 * openfmb::commonmodule::GenerationEventZGEN clear()
 ******************************************************************/
void openfmb::commonmodule::GenerationEventZGEN::clear()
{
  /* clear PARENT: openfmb::generationmodule::GenerationEventAndStatusZGEN */
  openfmb::generationmodule::GenerationEventAndStatusZGEN::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_GenerationEventZGEN NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::GenerationEventZGEN copy()
 ******************************************************************/
void openfmb::commonmodule::GenerationEventZGEN::copy( const GenerationEventZGEN * copy_from )
{

  GenerationEventZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::generationmodule::GenerationEventAndStatusZGEN */
  openfmb::generationmodule::GenerationEventAndStatusZGEN::copy( copy_from );
  /* copy __dummy_prevent_empty_class_GenerationEventZGEN */
  copy_to->__dummy_prevent_empty_class_GenerationEventZGEN = copy_from->__dummy_prevent_empty_class_GenerationEventZGEN;

}

/******************************************************************
 *  openfmb::commonmodule::GenerationEventZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::GenerationEventZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_GenerationEventZGEN */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationEventZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::GenerationEventZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationEventZGEN);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationEventZGEN);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationEventZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::GenerationEventZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationEventZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::GenerationEventZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationEventZGEN, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationEventZGEN, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationEventZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::GenerationEventZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationEventZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::GenerationEventZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::generationmodule::GenerationEventAndStatusZGEN::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_GenerationEventZGEN", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::GenerationEventZGEN,__dummy_prevent_empty_class_GenerationEventZGEN);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::GenerationEventZGEN,__dummy_prevent_empty_class_GenerationEventZGEN);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::GenerationStatusZGEN Default Constructor
 ******************************************************************/
openfmb::commonmodule::GenerationStatusZGEN::GenerationStatusZGEN()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::GenerationStatusZGEN Copy Constructor
 ******************************************************************/
openfmb::commonmodule::GenerationStatusZGEN::GenerationStatusZGEN( const GenerationStatusZGEN & other )
  : GenerationEventAndStatusZGEN()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::GenerationStatusZGEN Destructor
 ******************************************************************/
openfmb::commonmodule::GenerationStatusZGEN::~GenerationStatusZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::GenerationStatusZGEN Assignment Operator
 ******************************************************************/
openfmb::commonmodule::GenerationStatusZGEN& openfmb::commonmodule::GenerationStatusZGEN::operator=( const openfmb::commonmodule::GenerationStatusZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::GenerationStatusZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::GenerationStatusZGEN init()
 ******************************************************************/
void openfmb::commonmodule::GenerationStatusZGEN::init()
{
  /* init PARENT: openfmb::generationmodule::GenerationEventAndStatusZGEN */
  openfmb::generationmodule::GenerationEventAndStatusZGEN::init();
  this->__dummy_prevent_empty_class_GenerationStatusZGEN = 0;
}

/******************************************************************
 * openfmb::commonmodule::GenerationStatusZGEN clear()
 ******************************************************************/
void openfmb::commonmodule::GenerationStatusZGEN::clear()
{
  /* clear PARENT: openfmb::generationmodule::GenerationEventAndStatusZGEN */
  openfmb::generationmodule::GenerationEventAndStatusZGEN::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_GenerationStatusZGEN NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::GenerationStatusZGEN copy()
 ******************************************************************/
void openfmb::commonmodule::GenerationStatusZGEN::copy( const GenerationStatusZGEN * copy_from )
{

  GenerationStatusZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::generationmodule::GenerationEventAndStatusZGEN */
  openfmb::generationmodule::GenerationEventAndStatusZGEN::copy( copy_from );
  /* copy __dummy_prevent_empty_class_GenerationStatusZGEN */
  copy_to->__dummy_prevent_empty_class_GenerationStatusZGEN = copy_from->__dummy_prevent_empty_class_GenerationStatusZGEN;

}

/******************************************************************
 *  openfmb::commonmodule::GenerationStatusZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::GenerationStatusZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_GenerationStatusZGEN */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationStatusZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::GenerationStatusZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationStatusZGEN);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationStatusZGEN);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationStatusZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::GenerationStatusZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationStatusZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::GenerationStatusZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::generationmodule::GenerationEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationStatusZGEN, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_GenerationStatusZGEN, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationStatusZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::GenerationStatusZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationStatusZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::GenerationStatusZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::generationmodule::GenerationEventAndStatusZGEN::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_GenerationStatusZGEN", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::GenerationStatusZGEN,__dummy_prevent_empty_class_GenerationStatusZGEN);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::GenerationStatusZGEN,__dummy_prevent_empty_class_GenerationStatusZGEN);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::InverterEventAndStatusZGEN Default Constructor
 ******************************************************************/
openfmb::commonmodule::InverterEventAndStatusZGEN::InverterEventAndStatusZGEN()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::InverterEventAndStatusZGEN Copy Constructor
 ******************************************************************/
openfmb::commonmodule::InverterEventAndStatusZGEN::InverterEventAndStatusZGEN( const InverterEventAndStatusZGEN & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::InverterEventAndStatusZGEN Destructor
 ******************************************************************/
openfmb::commonmodule::InverterEventAndStatusZGEN::~InverterEventAndStatusZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::InverterEventAndStatusZGEN Assignment Operator
 ******************************************************************/
openfmb::commonmodule::InverterEventAndStatusZGEN& openfmb::commonmodule::InverterEventAndStatusZGEN::operator=( const openfmb::commonmodule::InverterEventAndStatusZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::InverterEventAndStatusZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::InverterEventAndStatusZGEN init()
 ******************************************************************/
void openfmb::commonmodule::InverterEventAndStatusZGEN::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
  this->GnSynSt = NULL;
  this->ParSt = NULL;
  this->RampLodSw = NULL;
  this->DCPwrSt = NULL;
  this->EmgStop = NULL;
  this->GnCtl = NULL;
}

/******************************************************************
 * openfmb::commonmodule::InverterEventAndStatusZGEN clear()
 ******************************************************************/
void openfmb::commonmodule::InverterEventAndStatusZGEN::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->GnOpSt */
  this->GnOpSt.clear( );
  if (this->GnSynSt != NULL) {
    /* clear struct: (*this->GnSynSt) */
    (*this->GnSynSt).clear( );
    delete this->GnSynSt;
    this->GnSynSt = NULL;
  }
  if (this->ParSt != NULL) {
    /* clear struct: (*this->ParSt) */
    (*this->ParSt).clear( );
    delete this->ParSt;
    this->ParSt = NULL;
  }
  if (this->RampLodSw != NULL) {
    /* clear struct: (*this->RampLodSw) */
    (*this->RampLodSw).clear( );
    delete this->RampLodSw;
    this->RampLodSw = NULL;
  }
  if (this->DCPwrSt != NULL) {
    /* clear struct: (*this->DCPwrSt) */
    (*this->DCPwrSt).clear( );
    delete this->DCPwrSt;
    this->DCPwrSt = NULL;
  }
  if (this->EmgStop != NULL) {
    /* clear struct: (*this->EmgStop) */
    (*this->EmgStop).clear( );
    delete this->EmgStop;
    this->EmgStop = NULL;
  }
  if (this->GnCtl != NULL) {
    /* clear struct: (*this->GnCtl) */
    (*this->GnCtl).clear( );
    delete this->GnCtl;
    this->GnCtl = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::InverterEventAndStatusZGEN copy()
 ******************************************************************/
void openfmb::commonmodule::InverterEventAndStatusZGEN::copy( const InverterEventAndStatusZGEN * copy_from )
{

  InverterEventAndStatusZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy GnOpSt */
  copy_to->GnOpSt.copy( &copy_from->GnOpSt );

  /* copy GnSynSt */
  if (copy_from->GnSynSt) {
    copy_to->GnSynSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->GnSynSt).copy( &(*copy_from->GnSynSt) );
  }
  else
    copy_to->GnSynSt = NULL;

  /* copy ParSt */
  if (copy_from->ParSt) {
    copy_to->ParSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->ParSt).copy( &(*copy_from->ParSt) );
  }
  else
    copy_to->ParSt = NULL;

  /* copy RampLodSw */
  if (copy_from->RampLodSw) {
    copy_to->RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->RampLodSw).copy( &(*copy_from->RampLodSw) );
  }
  else
    copy_to->RampLodSw = NULL;

  /* copy DCPwrSt */
  if (copy_from->DCPwrSt) {
    copy_to->DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->DCPwrSt).copy( &(*copy_from->DCPwrSt) );
  }
  else
    copy_to->DCPwrSt = NULL;

  /* copy EmgStop */
  if (copy_from->EmgStop) {
    copy_to->EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->EmgStop).copy( &(*copy_from->EmgStop) );
  }
  else
    copy_to->EmgStop = NULL;

  /* copy GnCtl */
  if (copy_from->GnCtl) {
    copy_to->GnCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
    (*copy_to->GnCtl).copy( &(*copy_from->GnCtl) );
  }
  else
    copy_to->GnCtl = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = GnOpSt.get_marshal_size( offset, 0 );
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GnSynSt != NULL) {
          offset = (*GnSynSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (ParSt != NULL) {
          offset = (*ParSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (RampLodSw != NULL) {
          offset = (*RampLodSw).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (DCPwrSt != NULL) {
          offset = (*DCPwrSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (EmgStop != NULL) {
          offset = (*EmgStop).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GnCtl != NULL) {
          offset = (*GnCtl).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = GnOpSt.marshal_cdr( buf, offset, stream_len, 1, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnSynSt != NULL) {
              offset = (*GnSynSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ParSt != NULL) {
              offset = (*ParSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (RampLodSw != NULL) {
              offset = (*RampLodSw).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DCPwrSt != NULL) {
              offset = (*DCPwrSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (EmgStop != NULL) {
              offset = (*EmgStop).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 11;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnCtl != NULL) {
              offset = (*GnCtl).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = GnOpSt.marshal_cdr( buf, offset, stream_len, 0, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnSynSt != NULL) {
              offset = (*GnSynSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ParSt != NULL) {
              offset = (*ParSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (RampLodSw != NULL) {
              offset = (*RampLodSw).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (DCPwrSt != NULL) {
              offset = (*DCPwrSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (EmgStop != NULL) {
              offset = (*EmgStop).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 11;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnCtl != NULL) {
              offset = (*GnCtl).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = GnOpSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnSynSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*GnSynSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnSynSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ParSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*ParSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ParSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*RampLodSw).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                RampLodSw = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*DCPwrSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DCPwrSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*EmgStop).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                EmgStop = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 11) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
                offset = (*GnCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = GnOpSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnSynSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*GnSynSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnSynSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ParSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*ParSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ParSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                RampLodSw = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*RampLodSw).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                RampLodSw = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                DCPwrSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*DCPwrSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                DCPwrSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                EmgStop = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*EmgStop).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                EmgStop = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 11) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnCtl = (struct openfmb::commonmodule::StatusDPS*)new struct openfmb::commonmodule::StatusDPS();
                offset = (*GnCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::InverterEventAndStatusZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::InverterEventAndStatusZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("GnOpSt", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::InverterEventAndStatusZGEN,GnOpSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::ENS_DERGeneratorStateKind::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("GnSynSt", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::InverterEventAndStatusZGEN,GnSynSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("ParSt", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::InverterEventAndStatusZGEN,ParSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("RampLodSw", fieldname, 9) == 0) && 
       (fieldname[9] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::InverterEventAndStatusZGEN,RampLodSw);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[10], field_def);
  }
  if ( (strncmp("DCPwrSt", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::InverterEventAndStatusZGEN,DCPwrSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("EmgStop", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::InverterEventAndStatusZGEN,EmgStop);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[8], field_def);
  }
  if ( (strncmp("GnCtl", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::InverterEventAndStatusZGEN,GnCtl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusDPS::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::MeasurementIED Default Constructor
 ******************************************************************/
openfmb::commonmodule::MeasurementIED::MeasurementIED()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::MeasurementIED Copy Constructor
 ******************************************************************/
openfmb::commonmodule::MeasurementIED::MeasurementIED( const MeasurementIED & other )
  : MeasurementValueSource()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::MeasurementIED Destructor
 ******************************************************************/
openfmb::commonmodule::MeasurementIED::~MeasurementIED()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::MeasurementIED Assignment Operator
 ******************************************************************/
openfmb::commonmodule::MeasurementIED& openfmb::commonmodule::MeasurementIED::operator=( const openfmb::commonmodule::MeasurementIED & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::MeasurementIED Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::MeasurementIED init()
 ******************************************************************/
void openfmb::commonmodule::MeasurementIED::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValueSource */
  openfmb::commonmodule::MeasurementValueSource::init();
  this->sourceApplicationID = NULL;
  this->sourceDateTime = 0;
}

/******************************************************************
 * openfmb::commonmodule::MeasurementIED clear()
 ******************************************************************/
void openfmb::commonmodule::MeasurementIED::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValueSource */
  openfmb::commonmodule::MeasurementValueSource::clear();
  /* clear string: this->sourceApplicationID */
  if (this->sourceApplicationID != NULL) {
    delete[] this->sourceApplicationID;
    this->sourceApplicationID = NULL;
  }
  /* clear basic type: this->sourceDateTime NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementIED copy()
 ******************************************************************/
void openfmb::commonmodule::MeasurementIED::copy( const MeasurementIED * copy_from )
{

  MeasurementIED * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValueSource */
  openfmb::commonmodule::MeasurementValueSource::copy( copy_from );
  /* copy sourceApplicationID */
  if (copy_from->sourceApplicationID) {
    copy_to->sourceApplicationID = new char[strlen(copy_from->sourceApplicationID) + 1];
    strcpy( copy_to->sourceApplicationID, copy_from->sourceApplicationID );
  }

  /* copy sourceDateTime */
  copy_to->sourceDateTime = copy_from->sourceDateTime;

}

/******************************************************************
 *  openfmb::commonmodule::MeasurementIED::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::MeasurementIED::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
      /* sourceDateTime */
      offset = (offset+7) & 0xfffffff8; /* align 8*/
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementIED::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MeasurementIED::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValueSource::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG_AND_REORDER(buf, offset, sourceDateTime);
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG(buf, offset, sourceDateTime);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementIED::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MeasurementIED::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementValueSource::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementIED::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MeasurementIED::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG_AND_REORDER(buf, offset, sourceDateTime, stream_len);
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG(buf, offset, sourceDateTime, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementIED::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MeasurementIED::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementValueSource::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MeasurementIED get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::MeasurementIED::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValueSource::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("sourceApplicationID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::MeasurementIED,sourceApplicationID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::MeasurementIED,sourceApplicationID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sourceDateTime", fieldname)==0) {
    field_def->kind       = 17;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::MeasurementIED,sourceDateTime);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::MeasurementIED,sourceDateTime);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::MV Default Constructor
 ******************************************************************/
openfmb::commonmodule::MV::MV()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::MV Copy Constructor
 ******************************************************************/
openfmb::commonmodule::MV::MV( const MV & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::MV Destructor
 ******************************************************************/
openfmb::commonmodule::MV::~MV()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::MV Assignment Operator
 ******************************************************************/
openfmb::commonmodule::MV& openfmb::commonmodule::MV::operator=( const openfmb::commonmodule::MV & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::MV Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::MV init()
 ******************************************************************/
void openfmb::commonmodule::MV::init()
{
  /* init struct: this->mag */
  this->mag.init( );
  /* init array: this->q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        this->q[i_1] = 0;
      }
  }
  /* init array: this->t */
  {
    int i_2;
    for (i_2 = 0; i_2 < 8; i_2++)
      {
        this->t[i_2] = 0;
      }
  }
  this->units = NULL;
}

/******************************************************************
 * openfmb::commonmodule::MV clear()
 ******************************************************************/
void openfmb::commonmodule::MV::clear()
{
  /* clear struct: this->mag */
  this->mag.clear( );
  /* clear array: this->q */
  {
    int i_0;
    for (i_0 = 0; i_0 < 2; i_0++)
      {
        /* clear basic type: this->q[i_0] NOOP */
      }
  }
  /* clear array: this->t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        /* clear basic type: this->t[i_1] NOOP */
      }
  }
  if (this->units != NULL) {
    /* clear struct: (*this->units) */
    (*this->units).clear( );
    delete this->units;
    this->units = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::MV copy()
 ******************************************************************/
void openfmb::commonmodule::MV::copy( const MV * copy_from )
{

  MV * copy_to = this;

  if ( ! copy_from ) return;


  /* copy mag */
  copy_to->mag.copy( &copy_from->mag );

  /* copy q */
  {
    int i_1;
    for (i_1 = 0; i_1 < 2; i_1++)
      {
        copy_to->q[i_1] = copy_from->q[i_1];
      }
  }

  /* copy t */
  {
    int i_1;
    for (i_1 = 0; i_1 < 8; i_1++)
      {
        copy_to->t[i_1] = copy_from->t[i_1];
      }
  }

  /* copy units */
  if (copy_from->units) {
    copy_to->units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
    (*copy_to->units).copy( &(*copy_from->units) );
  }
  else
    copy_to->units = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::MV::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::MV::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = mag.get_marshal_size( offset, 0 );
      /* q */
      offset += 2;
      /* t */
      offset += 8;
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (units != NULL) {
          offset = (*units).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MV::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MV::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = mag.marshal_cdr( buf, offset, stream_len, 1, 0 );
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              offset = (*units).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = mag.marshal_cdr( buf, offset, stream_len, 0, 0 );
          memcpy(&buf[offset], q, 2);
          offset+=2;
          memcpy(&buf[offset], t, 8);
          offset+=8;
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (units != NULL) {
              offset = (*units).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MV::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MV::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MV::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::MV::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = mag.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*units).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = mag.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          memcpy(q, &buf[offset], 2);
          offset+=2;
          memcpy(t, &buf[offset], 8);
          offset+=8;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                units = (struct openfmb::commonmodule::Unit*)new struct openfmb::commonmodule::Unit();
                offset = (*units).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                units = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MV::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::MV::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::MV get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::MV::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("mag", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::MV,mag);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::AnalogueValue::get_field_def(&fieldname[4], field_def);
  }
  if (strcmp("q", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 2;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::MV,q);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::MV,q);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("t", fieldname)==0) {
    field_def->kind       = 15;
    field_def->elem_kind  = 9;
    field_def->elem_count = 8;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::MV,t);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::MV,t);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("units", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::MV,units);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::Unit::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusIED Default Constructor
 ******************************************************************/
openfmb::commonmodule::StatusIED::StatusIED()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::StatusIED Copy Constructor
 ******************************************************************/
openfmb::commonmodule::StatusIED::StatusIED( const StatusIED & other )
  : StatusValueSource()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::StatusIED Destructor
 ******************************************************************/
openfmb::commonmodule::StatusIED::~StatusIED()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::StatusIED Assignment Operator
 ******************************************************************/
openfmb::commonmodule::StatusIED& openfmb::commonmodule::StatusIED::operator=( const openfmb::commonmodule::StatusIED & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::StatusIED Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::StatusIED init()
 ******************************************************************/
void openfmb::commonmodule::StatusIED::init()
{
  /* init PARENT: openfmb::commonmodule::StatusValueSource */
  openfmb::commonmodule::StatusValueSource::init();
  this->sourceApplicationID = NULL;
  this->sourceDateTime = 0;
}

/******************************************************************
 * openfmb::commonmodule::StatusIED clear()
 ******************************************************************/
void openfmb::commonmodule::StatusIED::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusValueSource */
  openfmb::commonmodule::StatusValueSource::clear();
  /* clear string: this->sourceApplicationID */
  if (this->sourceApplicationID != NULL) {
    delete[] this->sourceApplicationID;
    this->sourceApplicationID = NULL;
  }
  /* clear basic type: this->sourceDateTime NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::StatusIED copy()
 ******************************************************************/
void openfmb::commonmodule::StatusIED::copy( const StatusIED * copy_from )
{

  StatusIED * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusValueSource */
  openfmb::commonmodule::StatusValueSource::copy( copy_from );
  /* copy sourceApplicationID */
  if (copy_from->sourceApplicationID) {
    copy_to->sourceApplicationID = new char[strlen(copy_from->sourceApplicationID) + 1];
    strcpy( copy_to->sourceApplicationID, copy_from->sourceApplicationID );
  }

  /* copy sourceDateTime */
  copy_to->sourceDateTime = copy_from->sourceDateTime;

}

/******************************************************************
 *  openfmb::commonmodule::StatusIED::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::StatusIED::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::StatusValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
      /* sourceDateTime */
      offset = (offset+7) & 0xfffffff8; /* align 8*/
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusIED::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusIED::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusValueSource::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG_AND_REORDER(buf, offset, sourceDateTime);
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG(buf, offset, sourceDateTime);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusIED::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusIED::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::StatusValueSource::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusIED::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::StatusIED::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG_AND_REORDER(buf, offset, sourceDateTime, stream_len);
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG(buf, offset, sourceDateTime, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusIED::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::StatusIED::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::StatusValueSource::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::StatusIED get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::StatusIED::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusValueSource::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("sourceApplicationID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusIED,sourceApplicationID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusIED,sourceApplicationID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sourceDateTime", fieldname)==0) {
    field_def->kind       = 17;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::StatusIED,sourceDateTime);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::StatusIED,sourceDateTime);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::WYE Default Constructor
 ******************************************************************/
openfmb::commonmodule::WYE::WYE()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::WYE Copy Constructor
 ******************************************************************/
openfmb::commonmodule::WYE::WYE( const WYE & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::WYE Destructor
 ******************************************************************/
openfmb::commonmodule::WYE::~WYE()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::WYE Assignment Operator
 ******************************************************************/
openfmb::commonmodule::WYE& openfmb::commonmodule::WYE::operator=( const openfmb::commonmodule::WYE & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::WYE Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::WYE init()
 ******************************************************************/
void openfmb::commonmodule::WYE::init()
{
  this->phsA = NULL;
  this->phsB = NULL;
  this->phsC = NULL;
  this->neut = NULL;
  this->net = NULL;
}

/******************************************************************
 * openfmb::commonmodule::WYE clear()
 ******************************************************************/
void openfmb::commonmodule::WYE::clear()
{
  if (this->phsA != NULL) {
    /* clear struct: (*this->phsA) */
    (*this->phsA).clear( );
    delete this->phsA;
    this->phsA = NULL;
  }
  if (this->phsB != NULL) {
    /* clear struct: (*this->phsB) */
    (*this->phsB).clear( );
    delete this->phsB;
    this->phsB = NULL;
  }
  if (this->phsC != NULL) {
    /* clear struct: (*this->phsC) */
    (*this->phsC).clear( );
    delete this->phsC;
    this->phsC = NULL;
  }
  if (this->neut != NULL) {
    /* clear struct: (*this->neut) */
    (*this->neut).clear( );
    delete this->neut;
    this->neut = NULL;
  }
  if (this->net != NULL) {
    /* clear struct: (*this->net) */
    (*this->net).clear( );
    delete this->net;
    this->net = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::WYE copy()
 ******************************************************************/
void openfmb::commonmodule::WYE::copy( const WYE * copy_from )
{

  WYE * copy_to = this;

  if ( ! copy_from ) return;


  /* copy phsA */
  if (copy_from->phsA) {
    copy_to->phsA = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->phsA).copy( &(*copy_from->phsA) );
  }
  else
    copy_to->phsA = NULL;

  /* copy phsB */
  if (copy_from->phsB) {
    copy_to->phsB = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->phsB).copy( &(*copy_from->phsB) );
  }
  else
    copy_to->phsB = NULL;

  /* copy phsC */
  if (copy_from->phsC) {
    copy_to->phsC = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->phsC).copy( &(*copy_from->phsC) );
  }
  else
    copy_to->phsC = NULL;

  /* copy neut */
  if (copy_from->neut) {
    copy_to->neut = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->neut).copy( &(*copy_from->neut) );
  }
  else
    copy_to->neut = NULL;

  /* copy net */
  if (copy_from->net) {
    copy_to->net = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
    (*copy_to->net).copy( &(*copy_from->net) );
  }
  else
    copy_to->net = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::WYE::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::WYE::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (phsA != NULL) {
          offset = (*phsA).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (phsB != NULL) {
          offset = (*phsB).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (phsC != NULL) {
          offset = (*phsC).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (neut != NULL) {
          offset = (*neut).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (net != NULL) {
          offset = (*net).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::WYE::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::WYE::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsA != NULL) {
              offset = (*phsA).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsB != NULL) {
              offset = (*phsB).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsC != NULL) {
              offset = (*phsC).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (neut != NULL) {
              offset = (*neut).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (net != NULL) {
              offset = (*net).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsA != NULL) {
              offset = (*phsA).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsB != NULL) {
              offset = (*phsB).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (phsC != NULL) {
              offset = (*phsC).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (neut != NULL) {
              offset = (*neut).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (net != NULL) {
              offset = (*net).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::WYE::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::WYE::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::WYE::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::WYE::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsA = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsA).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsA = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsB = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsB).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsB = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsC = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsC).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsC = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                neut = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*neut).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                neut = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                net = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*net).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                net = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsA = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsA).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsA = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsB = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsB).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsB = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                phsC = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*phsC).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                phsC = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                neut = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*neut).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                neut = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                net = (struct openfmb::commonmodule::CMV*)new struct openfmb::commonmodule::CMV();
                offset = (*net).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                net = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::WYE::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::WYE::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::WYE get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::WYE::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("phsA", fieldname, 4) == 0) && 
       (fieldname[4] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::WYE,phsA);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[5], field_def);
  }
  if ( (strncmp("phsB", fieldname, 4) == 0) && 
       (fieldname[4] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::WYE,phsB);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[5], field_def);
  }
  if ( (strncmp("phsC", fieldname, 4) == 0) && 
       (fieldname[4] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::WYE,phsC);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[5], field_def);
  }
  if ( (strncmp("neut", fieldname, 4) == 0) && 
       (fieldname[4] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::WYE,neut);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[5], field_def);
  }
  if ( (strncmp("net", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::WYE,net);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CMV::get_field_def(&fieldname[4], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::EssEventZBAT Default Constructor
 ******************************************************************/
openfmb::essmodule::EssEventZBAT::EssEventZBAT()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::EssEventZBAT Copy Constructor
 ******************************************************************/
openfmb::essmodule::EssEventZBAT::EssEventZBAT( const EssEventZBAT & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::EssEventZBAT Destructor
 ******************************************************************/
openfmb::essmodule::EssEventZBAT::~EssEventZBAT()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::EssEventZBAT Assignment Operator
 ******************************************************************/
openfmb::essmodule::EssEventZBAT& openfmb::essmodule::EssEventZBAT::operator=( const openfmb::essmodule::EssEventZBAT & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::EssEventZBAT Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::EssEventZBAT init()
 ******************************************************************/
void openfmb::essmodule::EssEventZBAT::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
  this->BatHi = NULL;
  this->BatLo = NULL;
  this->SocAhr = NULL;
  this->BatSt = NULL;
  this->Stdby = NULL;
  this->GriMod = NULL;
}

/******************************************************************
 * openfmb::essmodule::EssEventZBAT clear()
 ******************************************************************/
void openfmb::essmodule::EssEventZBAT::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  if (this->BatHi != NULL) {
    /* clear struct: (*this->BatHi) */
    (*this->BatHi).clear( );
    delete this->BatHi;
    this->BatHi = NULL;
  }
  if (this->BatLo != NULL) {
    /* clear struct: (*this->BatLo) */
    (*this->BatLo).clear( );
    delete this->BatLo;
    this->BatLo = NULL;
  }
  if (this->SocAhr != NULL) {
    /* clear struct: (*this->SocAhr) */
    (*this->SocAhr).clear( );
    delete this->SocAhr;
    this->SocAhr = NULL;
  }
  if (this->BatSt != NULL) {
    /* clear struct: (*this->BatSt) */
    (*this->BatSt).clear( );
    delete this->BatSt;
    this->BatSt = NULL;
  }
  if (this->Stdby != NULL) {
    /* clear struct: (*this->Stdby) */
    (*this->Stdby).clear( );
    delete this->Stdby;
    this->Stdby = NULL;
  }
  if (this->GriMod != NULL) {
    /* clear struct: (*this->GriMod) */
    (*this->GriMod).clear( );
    delete this->GriMod;
    this->GriMod = NULL;
  }
}

/******************************************************************
 *  openfmb::essmodule::EssEventZBAT copy()
 ******************************************************************/
void openfmb::essmodule::EssEventZBAT::copy( const EssEventZBAT * copy_from )
{

  EssEventZBAT * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy BatHi */
  if (copy_from->BatHi) {
    copy_to->BatHi = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->BatHi).copy( &(*copy_from->BatHi) );
  }
  else
    copy_to->BatHi = NULL;

  /* copy BatLo */
  if (copy_from->BatLo) {
    copy_to->BatLo = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->BatLo).copy( &(*copy_from->BatLo) );
  }
  else
    copy_to->BatLo = NULL;

  /* copy SocAhr */
  if (copy_from->SocAhr) {
    copy_to->SocAhr = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
    (*copy_to->SocAhr).copy( &(*copy_from->SocAhr) );
  }
  else
    copy_to->SocAhr = NULL;

  /* copy BatSt */
  if (copy_from->BatSt) {
    copy_to->BatSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->BatSt).copy( &(*copy_from->BatSt) );
  }
  else
    copy_to->BatSt = NULL;

  /* copy Stdby */
  if (copy_from->Stdby) {
    copy_to->Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->Stdby).copy( &(*copy_from->Stdby) );
  }
  else
    copy_to->Stdby = NULL;

  /* copy GriMod */
  if (copy_from->GriMod) {
    copy_to->GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
    (*copy_to->GriMod).copy( &(*copy_from->GriMod) );
  }
  else
    copy_to->GriMod = NULL;

}

/******************************************************************
 *  openfmb::essmodule::EssEventZBAT::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::EssEventZBAT::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (BatHi != NULL) {
          offset = (*BatHi).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (BatLo != NULL) {
          offset = (*BatLo).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (SocAhr != NULL) {
          offset = (*SocAhr).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (BatSt != NULL) {
          offset = (*BatSt).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (Stdby != NULL) {
          offset = (*Stdby).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GriMod != NULL) {
          offset = (*GriMod).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssEventZBAT::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::EssEventZBAT::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (BatHi != NULL) {
              offset = (*BatHi).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (BatLo != NULL) {
              offset = (*BatLo).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SocAhr != NULL) {
              offset = (*SocAhr).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (BatSt != NULL) {
              offset = (*BatSt).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Stdby != NULL) {
              offset = (*Stdby).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (BatHi != NULL) {
              offset = (*BatHi).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (BatLo != NULL) {
              offset = (*BatLo).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SocAhr != NULL) {
              offset = (*SocAhr).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (BatSt != NULL) {
              offset = (*BatSt).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Stdby != NULL) {
              offset = (*Stdby).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssEventZBAT::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::EssEventZBAT::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssEventZBAT::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::EssEventZBAT::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                BatHi = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*BatHi).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                BatHi = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                BatLo = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*BatLo).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                BatLo = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SocAhr = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
                offset = (*SocAhr).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SocAhr = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                BatSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*BatSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                BatSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*Stdby).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Stdby = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                BatHi = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*BatHi).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                BatHi = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                BatLo = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*BatLo).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                BatLo = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SocAhr = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
                offset = (*SocAhr).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SocAhr = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                BatSt = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*BatSt).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                BatSt = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*Stdby).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Stdby = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssEventZBAT::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::EssEventZBAT::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssEventZBAT get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::EssEventZBAT::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("BatHi", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssEventZBAT,BatHi);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("BatLo", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssEventZBAT,BatLo);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("SocAhr", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssEventZBAT,SocAhr);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::MV::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("BatSt", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssEventZBAT,BatSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("Stdby", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssEventZBAT,Stdby);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("GriMod", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssEventZBAT,GriMod);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ENG_GridConnectModeKind::get_field_def(&fieldname[7], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGEN Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSEventZGEN::ESSEventZGEN()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGEN Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSEventZGEN::ESSEventZGEN( const ESSEventZGEN & other )
  : InverterEventAndStatusZGEN()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGEN Destructor
 ******************************************************************/
openfmb::essmodule::ESSEventZGEN::~ESSEventZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGEN Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSEventZGEN& openfmb::essmodule::ESSEventZGEN::operator=( const openfmb::essmodule::ESSEventZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSEventZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSEventZGEN init()
 ******************************************************************/
void openfmb::essmodule::ESSEventZGEN::init()
{
  /* init PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::init();
  this->__dummy_prevent_empty_class_ESSEventZGEN = 0;
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGEN clear()
 ******************************************************************/
void openfmb::essmodule::ESSEventZGEN::clear()
{
  /* clear PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_ESSEventZGEN NOOP */
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGEN copy()
 ******************************************************************/
void openfmb::essmodule::ESSEventZGEN::copy( const ESSEventZGEN * copy_from )
{

  ESSEventZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::copy( copy_from );
  /* copy __dummy_prevent_empty_class_ESSEventZGEN */
  copy_to->__dummy_prevent_empty_class_ESSEventZGEN = copy_from->__dummy_prevent_empty_class_ESSEventZGEN;

}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_ESSEventZGEN */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGEN);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGEN);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGEN, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGEN, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSEventZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::InverterEventAndStatusZGEN::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_ESSEventZGEN", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ESSEventZGEN,__dummy_prevent_empty_class_ESSEventZGEN);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ESSEventZGEN,__dummy_prevent_empty_class_ESSEventZGEN);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGLD Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSEventZGLD::ESSEventZGLD()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGLD Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSEventZGLD::ESSEventZGLD( const ESSEventZGLD & other )
  : LoadEventAndStatusZGLD()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGLD Destructor
 ******************************************************************/
openfmb::essmodule::ESSEventZGLD::~ESSEventZGLD()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGLD Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSEventZGLD& openfmb::essmodule::ESSEventZGLD::operator=( const openfmb::essmodule::ESSEventZGLD & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSEventZGLD Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSEventZGLD init()
 ******************************************************************/
void openfmb::essmodule::ESSEventZGLD::init()
{
  /* init PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::init();
  this->__dummy_prevent_empty_class_ESSEventZGLD = 0;
}

/******************************************************************
 * openfmb::essmodule::ESSEventZGLD clear()
 ******************************************************************/
void openfmb::essmodule::ESSEventZGLD::clear()
{
  /* clear PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_ESSEventZGLD NOOP */
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGLD copy()
 ******************************************************************/
void openfmb::essmodule::ESSEventZGLD::copy( const ESSEventZGLD * copy_from )
{

  ESSEventZGLD * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::copy( copy_from );
  /* copy __dummy_prevent_empty_class_ESSEventZGLD */
  copy_to->__dummy_prevent_empty_class_ESSEventZGLD = copy_from->__dummy_prevent_empty_class_ESSEventZGLD;

}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGLD::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGLD::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_ESSEventZGLD */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGLD::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGLD::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGLD);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGLD);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGLD::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGLD::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGLD::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGLD::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGLD, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSEventZGLD, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGLD::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEventZGLD::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventZGLD get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSEventZGLD::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::loadmodule::LoadEventAndStatusZGLD::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_ESSEventZGLD", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ESSEventZGLD,__dummy_prevent_empty_class_ESSEventZGLD);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ESSEventZGLD,__dummy_prevent_empty_class_ESSEventZGLD);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::EssStatusZBAT Default Constructor
 ******************************************************************/
openfmb::essmodule::EssStatusZBAT::EssStatusZBAT()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::EssStatusZBAT Copy Constructor
 ******************************************************************/
openfmb::essmodule::EssStatusZBAT::EssStatusZBAT( const EssStatusZBAT & other )
  : LogicalNodeForEventAndStatus()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::EssStatusZBAT Destructor
 ******************************************************************/
openfmb::essmodule::EssStatusZBAT::~EssStatusZBAT()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::EssStatusZBAT Assignment Operator
 ******************************************************************/
openfmb::essmodule::EssStatusZBAT& openfmb::essmodule::EssStatusZBAT::operator=( const openfmb::essmodule::EssStatusZBAT & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::EssStatusZBAT Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::EssStatusZBAT init()
 ******************************************************************/
void openfmb::essmodule::EssStatusZBAT::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::init();
  /* init struct: this->BatSt */
  this->BatSt.init( );
  this->Stdby = NULL;
  this->GriMod = NULL;
  this->SocAhr = NULL;
}

/******************************************************************
 * openfmb::essmodule::EssStatusZBAT clear()
 ******************************************************************/
void openfmb::essmodule::EssStatusZBAT::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::clear();
  /* clear struct: this->BatSt */
  this->BatSt.clear( );
  if (this->Stdby != NULL) {
    /* clear struct: (*this->Stdby) */
    (*this->Stdby).clear( );
    delete this->Stdby;
    this->Stdby = NULL;
  }
  if (this->GriMod != NULL) {
    /* clear struct: (*this->GriMod) */
    (*this->GriMod).clear( );
    delete this->GriMod;
    this->GriMod = NULL;
  }
  if (this->SocAhr != NULL) {
    /* clear struct: (*this->SocAhr) */
    (*this->SocAhr).clear( );
    delete this->SocAhr;
    this->SocAhr = NULL;
  }
}

/******************************************************************
 *  openfmb::essmodule::EssStatusZBAT copy()
 ******************************************************************/
void openfmb::essmodule::EssStatusZBAT::copy( const EssStatusZBAT * copy_from )
{

  EssStatusZBAT * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForEventAndStatus */
  openfmb::commonmodule::LogicalNodeForEventAndStatus::copy( copy_from );
  /* copy BatSt */
  copy_to->BatSt.copy( &copy_from->BatSt );

  /* copy Stdby */
  if (copy_from->Stdby) {
    copy_to->Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
    (*copy_to->Stdby).copy( &(*copy_from->Stdby) );
  }
  else
    copy_to->Stdby = NULL;

  /* copy GriMod */
  if (copy_from->GriMod) {
    copy_to->GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
    (*copy_to->GriMod).copy( &(*copy_from->GriMod) );
  }
  else
    copy_to->GriMod = NULL;

  /* copy SocAhr */
  if (copy_from->SocAhr) {
    copy_to->SocAhr = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
    (*copy_to->SocAhr).copy( &(*copy_from->SocAhr) );
  }
  else
    copy_to->SocAhr = NULL;

}

/******************************************************************
 *  openfmb::essmodule::EssStatusZBAT::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::EssStatusZBAT::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::get_marshal_size(offset, just_keys);
      offset = BatSt.get_marshal_size( offset, 0 );
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (Stdby != NULL) {
          offset = (*Stdby).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GriMod != NULL) {
          offset = (*GriMod).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (SocAhr != NULL) {
          offset = (*SocAhr).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssStatusZBAT::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::EssStatusZBAT::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = BatSt.marshal_cdr( buf, offset, stream_len, 1, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Stdby != NULL) {
              offset = (*Stdby).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SocAhr != NULL) {
              offset = (*SocAhr).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          offset = BatSt.marshal_cdr( buf, offset, stream_len, 0, 0 );
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Stdby != NULL) {
              offset = (*Stdby).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (SocAhr != NULL) {
              offset = (*SocAhr).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssStatusZBAT::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::EssStatusZBAT::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssStatusZBAT::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::EssStatusZBAT::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForEventAndStatus::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = BatSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*Stdby).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Stdby = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SocAhr = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
                offset = (*SocAhr).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SocAhr = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          offset = BatSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Stdby = (struct openfmb::commonmodule::StatusSPS*)new struct openfmb::commonmodule::StatusSPS();
                offset = (*Stdby).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Stdby = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                SocAhr = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
                offset = (*SocAhr).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                SocAhr = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssStatusZBAT::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::EssStatusZBAT::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssStatusZBAT get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::EssStatusZBAT::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForEventAndStatus::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("BatSt", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssStatusZBAT,BatSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("Stdby", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssStatusZBAT,Stdby);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::StatusSPS::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("GriMod", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssStatusZBAT,GriMod);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ENG_GridConnectModeKind::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("SocAhr", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssStatusZBAT,SocAhr);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::MV::get_field_def(&fieldname[7], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGEN Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatusZGEN::ESSStatusZGEN()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGEN Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatusZGEN::ESSStatusZGEN( const ESSStatusZGEN & other )
  : InverterEventAndStatusZGEN()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGEN Destructor
 ******************************************************************/
openfmb::essmodule::ESSStatusZGEN::~ESSStatusZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGEN Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSStatusZGEN& openfmb::essmodule::ESSStatusZGEN::operator=( const openfmb::essmodule::ESSStatusZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSStatusZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSStatusZGEN init()
 ******************************************************************/
void openfmb::essmodule::ESSStatusZGEN::init()
{
  /* init PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::init();
  this->__dummy_prevent_empty_class_ESSStatusZGEN = 0;
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGEN clear()
 ******************************************************************/
void openfmb::essmodule::ESSStatusZGEN::clear()
{
  /* clear PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_ESSStatusZGEN NOOP */
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGEN copy()
 ******************************************************************/
void openfmb::essmodule::ESSStatusZGEN::copy( const ESSStatusZGEN * copy_from )
{

  ESSStatusZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::copy( copy_from );
  /* copy __dummy_prevent_empty_class_ESSStatusZGEN */
  copy_to->__dummy_prevent_empty_class_ESSStatusZGEN = copy_from->__dummy_prevent_empty_class_ESSStatusZGEN;

}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_ESSStatusZGEN */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGEN);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGEN);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGEN, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGEN, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSStatusZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::InverterEventAndStatusZGEN::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_ESSStatusZGEN", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ESSStatusZGEN,__dummy_prevent_empty_class_ESSStatusZGEN);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ESSStatusZGEN,__dummy_prevent_empty_class_ESSStatusZGEN);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGLD Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatusZGLD::ESSStatusZGLD()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGLD Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatusZGLD::ESSStatusZGLD( const ESSStatusZGLD & other )
  : LoadEventAndStatusZGLD()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGLD Destructor
 ******************************************************************/
openfmb::essmodule::ESSStatusZGLD::~ESSStatusZGLD()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGLD Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSStatusZGLD& openfmb::essmodule::ESSStatusZGLD::operator=( const openfmb::essmodule::ESSStatusZGLD & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSStatusZGLD Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSStatusZGLD init()
 ******************************************************************/
void openfmb::essmodule::ESSStatusZGLD::init()
{
  /* init PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::init();
  this->__dummy_prevent_empty_class_ESSStatusZGLD = 0;
}

/******************************************************************
 * openfmb::essmodule::ESSStatusZGLD clear()
 ******************************************************************/
void openfmb::essmodule::ESSStatusZGLD::clear()
{
  /* clear PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_ESSStatusZGLD NOOP */
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGLD copy()
 ******************************************************************/
void openfmb::essmodule::ESSStatusZGLD::copy( const ESSStatusZGLD * copy_from )
{

  ESSStatusZGLD * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::loadmodule::LoadEventAndStatusZGLD */
  openfmb::loadmodule::LoadEventAndStatusZGLD::copy( copy_from );
  /* copy __dummy_prevent_empty_class_ESSStatusZGLD */
  copy_to->__dummy_prevent_empty_class_ESSStatusZGLD = copy_from->__dummy_prevent_empty_class_ESSStatusZGLD;

}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGLD::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGLD::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_ESSStatusZGLD */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGLD::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGLD::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::loadmodule::LoadEventAndStatusZGLD::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGLD);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGLD);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGLD::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGLD::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGLD::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGLD::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::loadmodule::LoadEventAndStatusZGLD::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGLD, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_ESSStatusZGLD, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGLD::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatusZGLD::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusZGLD get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSStatusZGLD::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::loadmodule::LoadEventAndStatusZGLD::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_ESSStatusZGLD", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ESSStatusZGLD,__dummy_prevent_empty_class_ESSStatusZGLD);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ESSStatusZGLD,__dummy_prevent_empty_class_ESSStatusZGLD);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationEvent Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationEvent::GenerationEvent()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationEvent Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationEvent::GenerationEvent( const GenerationEvent & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationEvent Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationEvent::~GenerationEvent()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationEvent Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationEvent& openfmb::generationmodule::GenerationEvent::operator=( const openfmb::generationmodule::GenerationEvent & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationEvent Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationEvent init()
 ******************************************************************/
void openfmb::generationmodule::GenerationEvent::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
  this->generationEventZGEN = NULL;
}

/******************************************************************
 * openfmb::generationmodule::GenerationEvent clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationEvent::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  if (this->generationEventZGEN != NULL) {
    /* clear struct: (*this->generationEventZGEN) */
    (*this->generationEventZGEN).clear( );
    delete this->generationEventZGEN;
    this->generationEventZGEN = NULL;
  }
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEvent copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationEvent::copy( const GenerationEvent * copy_from )
{

  GenerationEvent * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy generationEventZGEN */
  if (copy_from->generationEventZGEN) {
    copy_to->generationEventZGEN = (struct openfmb::commonmodule::GenerationEventZGEN*)new struct openfmb::commonmodule::GenerationEventZGEN();
    (*copy_to->generationEventZGEN).copy( &(*copy_from->generationEventZGEN) );
  }
  else
    copy_to->generationEventZGEN = NULL;

}

/******************************************************************
 *  openfmb::generationmodule::GenerationEvent::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationEvent::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (generationEventZGEN != NULL) {
          offset = (*generationEventZGEN).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEvent::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationEvent::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (generationEventZGEN != NULL) {
              offset = (*generationEventZGEN).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (generationEventZGEN != NULL) {
              offset = (*generationEventZGEN).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEvent::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationEvent::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEvent::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationEvent::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                generationEventZGEN = (struct openfmb::commonmodule::GenerationEventZGEN*)new struct openfmb::commonmodule::GenerationEventZGEN();
                offset = (*generationEventZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                generationEventZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                generationEventZGEN = (struct openfmb::commonmodule::GenerationEventZGEN*)new struct openfmb::commonmodule::GenerationEventZGEN();
                offset = (*generationEventZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                generationEventZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEvent::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationEvent::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEvent get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationEvent::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("generationEventZGEN", fieldname, 19) == 0) && 
       (fieldname[19] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEvent,generationEventZGEN);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::GenerationEventZGEN::get_field_def(&fieldname[20], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatus Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationStatus::GenerationStatus()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatus Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationStatus::GenerationStatus( const GenerationStatus & other )
  : StatusValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatus Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationStatus::~GenerationStatus()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatus Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationStatus& openfmb::generationmodule::GenerationStatus::operator=( const openfmb::generationmodule::GenerationStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationStatus init()
 ******************************************************************/
void openfmb::generationmodule::GenerationStatus::init()
{
  /* init PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::init();
  this->generationStatusZGEN = NULL;
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatus clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::clear();
  if (this->generationStatusZGEN != NULL) {
    /* clear struct: (*this->generationStatusZGEN) */
    (*this->generationStatusZGEN).clear( );
    delete this->generationStatusZGEN;
    this->generationStatusZGEN = NULL;
  }
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatus copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationStatus::copy( const GenerationStatus * copy_from )
{

  GenerationStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::copy( copy_from );
  /* copy generationStatusZGEN */
  if (copy_from->generationStatusZGEN) {
    copy_to->generationStatusZGEN = (struct openfmb::commonmodule::GenerationStatusZGEN*)new struct openfmb::commonmodule::GenerationStatusZGEN();
    (*copy_to->generationStatusZGEN).copy( &(*copy_from->generationStatusZGEN) );
  }
  else
    copy_to->generationStatusZGEN = NULL;

}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatus::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (generationStatusZGEN != NULL) {
          offset = (*generationStatusZGEN).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatus::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (generationStatusZGEN != NULL) {
              offset = (*generationStatusZGEN).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (generationStatusZGEN != NULL) {
              offset = (*generationStatusZGEN).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                generationStatusZGEN = (struct openfmb::commonmodule::GenerationStatusZGEN*)new struct openfmb::commonmodule::GenerationStatusZGEN();
                offset = (*generationStatusZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                generationStatusZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                generationStatusZGEN = (struct openfmb::commonmodule::GenerationStatusZGEN*)new struct openfmb::commonmodule::GenerationStatusZGEN();
                offset = (*generationStatusZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                generationStatusZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("generationStatusZGEN", fieldname, 20) == 0) && 
       (fieldname[20] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationStatus,generationStatusZGEN);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::GenerationStatusZGEN::get_field_def(&fieldname[21], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatusProfile Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationStatusProfile::GenerationStatusProfile()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatusProfile Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationStatusProfile::GenerationStatusProfile( const GenerationStatusProfile & other )
  : StatusIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatusProfile Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationStatusProfile::~GenerationStatusProfile()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatusProfile Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationStatusProfile& openfmb::generationmodule::GenerationStatusProfile::operator=( const openfmb::generationmodule::GenerationStatusProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationStatusProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationStatusProfile init()
 ******************************************************************/
void openfmb::generationmodule::GenerationStatusProfile::init()
{
  /* init PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::init();
  /* init struct: this->generationStatus */
  this->generationStatus.init( );
}

/******************************************************************
 * openfmb::generationmodule::GenerationStatusProfile clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationStatusProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::clear();
  /* clear struct: this->generationStatus */
  this->generationStatus.clear( );
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatusProfile copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationStatusProfile::copy( const GenerationStatusProfile * copy_from )
{

  GenerationStatusProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::copy( copy_from );
  /* copy generationStatus */
  copy_to->generationStatus.copy( &copy_from->generationStatus );

}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatusProfile::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatusProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
      offset = generationStatus.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatusProfile::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatusProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = generationStatus.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = generationStatus.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatusProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatusProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::StatusIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatusProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatusProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = generationStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = generationStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatusProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationStatusProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::StatusIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationStatusProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationStatusProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("generationStatus", fieldname, 16) == 0) && 
       (fieldname[16] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationStatusProfile,generationStatus);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::generationmodule::GenerationStatus::get_field_def(&fieldname[17], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadEvent Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEvent::LoadEvent()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadEvent Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEvent::LoadEvent( const LoadEvent & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadEvent Destructor
 ******************************************************************/
openfmb::loadmodule::LoadEvent::~LoadEvent()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadEvent Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadEvent& openfmb::loadmodule::LoadEvent::operator=( const openfmb::loadmodule::LoadEvent & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadEvent Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadEvent init()
 ******************************************************************/
void openfmb::loadmodule::LoadEvent::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
  this->loadEventZGLD = NULL;
}

/******************************************************************
 * openfmb::loadmodule::LoadEvent clear()
 ******************************************************************/
void openfmb::loadmodule::LoadEvent::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  if (this->loadEventZGLD != NULL) {
    /* clear struct: (*this->loadEventZGLD) */
    (*this->loadEventZGLD).clear( );
    delete this->loadEventZGLD;
    this->loadEventZGLD = NULL;
  }
}

/******************************************************************
 *  openfmb::loadmodule::LoadEvent copy()
 ******************************************************************/
void openfmb::loadmodule::LoadEvent::copy( const LoadEvent * copy_from )
{

  LoadEvent * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy loadEventZGLD */
  if (copy_from->loadEventZGLD) {
    copy_to->loadEventZGLD = (struct openfmb::loadmodule::LoadEventZGLD*)new struct openfmb::loadmodule::LoadEventZGLD();
    (*copy_to->loadEventZGLD).copy( &(*copy_from->loadEventZGLD) );
  }
  else
    copy_to->loadEventZGLD = NULL;

}

/******************************************************************
 *  openfmb::loadmodule::LoadEvent::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadEvent::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (loadEventZGLD != NULL) {
          offset = (*loadEventZGLD).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEvent::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEvent::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadEventZGLD != NULL) {
              offset = (*loadEventZGLD).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadEventZGLD != NULL) {
              offset = (*loadEventZGLD).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEvent::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEvent::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEvent::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEvent::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadEventZGLD = (struct openfmb::loadmodule::LoadEventZGLD*)new struct openfmb::loadmodule::LoadEventZGLD();
                offset = (*loadEventZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadEventZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadEventZGLD = (struct openfmb::loadmodule::LoadEventZGLD*)new struct openfmb::loadmodule::LoadEventZGLD();
                offset = (*loadEventZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadEventZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEvent::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEvent::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEvent get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadEvent::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("loadEventZGLD", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEvent,loadEventZGLD);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::loadmodule::LoadEventZGLD::get_field_def(&fieldname[14], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadStatus Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadStatus::LoadStatus()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadStatus Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadStatus::LoadStatus( const LoadStatus & other )
  : StatusValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadStatus Destructor
 ******************************************************************/
openfmb::loadmodule::LoadStatus::~LoadStatus()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadStatus Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadStatus& openfmb::loadmodule::LoadStatus::operator=( const openfmb::loadmodule::LoadStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadStatus init()
 ******************************************************************/
void openfmb::loadmodule::LoadStatus::init()
{
  /* init PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::init();
  this->loadStatusZGLD = NULL;
}

/******************************************************************
 * openfmb::loadmodule::LoadStatus clear()
 ******************************************************************/
void openfmb::loadmodule::LoadStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::clear();
  if (this->loadStatusZGLD != NULL) {
    /* clear struct: (*this->loadStatusZGLD) */
    (*this->loadStatusZGLD).clear( );
    delete this->loadStatusZGLD;
    this->loadStatusZGLD = NULL;
  }
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatus copy()
 ******************************************************************/
void openfmb::loadmodule::LoadStatus::copy( const LoadStatus * copy_from )
{

  LoadStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::copy( copy_from );
  /* copy loadStatusZGLD */
  if (copy_from->loadStatusZGLD) {
    copy_to->loadStatusZGLD = (struct openfmb::loadmodule::LoadStatusZGLD*)new struct openfmb::loadmodule::LoadStatusZGLD();
    (*copy_to->loadStatusZGLD).copy( &(*copy_from->loadStatusZGLD) );
  }
  else
    copy_to->loadStatusZGLD = NULL;

}

/******************************************************************
 *  openfmb::loadmodule::LoadStatus::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (loadStatusZGLD != NULL) {
          offset = (*loadStatusZGLD).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatus::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadStatusZGLD != NULL) {
              offset = (*loadStatusZGLD).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadStatusZGLD != NULL) {
              offset = (*loadStatusZGLD).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadStatusZGLD = (struct openfmb::loadmodule::LoadStatusZGLD*)new struct openfmb::loadmodule::LoadStatusZGLD();
                offset = (*loadStatusZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadStatusZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadStatusZGLD = (struct openfmb::loadmodule::LoadStatusZGLD*)new struct openfmb::loadmodule::LoadStatusZGLD();
                offset = (*loadStatusZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadStatusZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("loadStatusZGLD", fieldname, 14) == 0) && 
       (fieldname[14] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadStatus,loadStatusZGLD);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::loadmodule::LoadStatusZGLD::get_field_def(&fieldname[15], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusProfile Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadStatusProfile::LoadStatusProfile()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusProfile Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadStatusProfile::LoadStatusProfile( const LoadStatusProfile & other )
  : StatusIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusProfile Destructor
 ******************************************************************/
openfmb::loadmodule::LoadStatusProfile::~LoadStatusProfile()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusProfile Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadStatusProfile& openfmb::loadmodule::LoadStatusProfile::operator=( const openfmb::loadmodule::LoadStatusProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadStatusProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadStatusProfile init()
 ******************************************************************/
void openfmb::loadmodule::LoadStatusProfile::init()
{
  /* init PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::init();
  /* init struct: this->loadStatus */
  this->loadStatus.init( );
}

/******************************************************************
 * openfmb::loadmodule::LoadStatusProfile clear()
 ******************************************************************/
void openfmb::loadmodule::LoadStatusProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::clear();
  /* clear struct: this->loadStatus */
  this->loadStatus.clear( );
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusProfile copy()
 ******************************************************************/
void openfmb::loadmodule::LoadStatusProfile::copy( const LoadStatusProfile * copy_from )
{

  LoadStatusProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::copy( copy_from );
  /* copy loadStatus */
  copy_to->loadStatus.copy( &copy_from->loadStatus );

}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusProfile::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
      offset = loadStatus.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusProfile::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = loadStatus.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = loadStatus.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::StatusIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = loadStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = loadStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadStatusProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::StatusIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadStatusProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadStatusProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("loadStatus", fieldname, 10) == 0) && 
       (fieldname[10] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadStatusProfile,loadStatus);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::loadmodule::LoadStatus::get_field_def(&fieldname[11], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::optimizermodule::PlannedOptimizerScheduleProfile Default Constructor
 ******************************************************************/
openfmb::optimizermodule::PlannedOptimizerScheduleProfile::PlannedOptimizerScheduleProfile()
{
  init();
}

/******************************************************************
 * openfmb::optimizermodule::PlannedOptimizerScheduleProfile Copy Constructor
 ******************************************************************/
openfmb::optimizermodule::PlannedOptimizerScheduleProfile::PlannedOptimizerScheduleProfile( const PlannedOptimizerScheduleProfile & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::optimizermodule::PlannedOptimizerScheduleProfile Destructor
 ******************************************************************/
openfmb::optimizermodule::PlannedOptimizerScheduleProfile::~PlannedOptimizerScheduleProfile()
{
  clear();
}

/******************************************************************
 * openfmb::optimizermodule::PlannedOptimizerScheduleProfile Assignment Operator
 ******************************************************************/
openfmb::optimizermodule::PlannedOptimizerScheduleProfile& openfmb::optimizermodule::PlannedOptimizerScheduleProfile::operator=( const openfmb::optimizermodule::PlannedOptimizerScheduleProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::optimizermodule::::PlannedOptimizerScheduleProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::optimizermodule::PlannedOptimizerScheduleProfile init()
 ******************************************************************/
void openfmb::optimizermodule::PlannedOptimizerScheduleProfile::init()
{
  this->regulatorControlScheduleProfileList = NULL;
  this->solarControlScheduleProfileList = NULL;
  this->plannedInterconnectionScheduleProfileList = NULL;
  this->loadControlScheduleProfileList = NULL;
  this->essControlScheduleProfileList = NULL;
}

/******************************************************************
 * openfmb::optimizermodule::PlannedOptimizerScheduleProfile clear()
 ******************************************************************/
void openfmb::optimizermodule::PlannedOptimizerScheduleProfile::clear()
{
  if (this->regulatorControlScheduleProfileList != NULL) {
    /* clear struct: (*this->regulatorControlScheduleProfileList) */
    (*this->regulatorControlScheduleProfileList).clear( );
    delete this->regulatorControlScheduleProfileList;
    this->regulatorControlScheduleProfileList = NULL;
  }
  if (this->solarControlScheduleProfileList != NULL) {
    /* clear struct: (*this->solarControlScheduleProfileList) */
    (*this->solarControlScheduleProfileList).clear( );
    delete this->solarControlScheduleProfileList;
    this->solarControlScheduleProfileList = NULL;
  }
  if (this->plannedInterconnectionScheduleProfileList != NULL) {
    /* clear struct: (*this->plannedInterconnectionScheduleProfileList) */
    (*this->plannedInterconnectionScheduleProfileList).clear( );
    delete this->plannedInterconnectionScheduleProfileList;
    this->plannedInterconnectionScheduleProfileList = NULL;
  }
  if (this->loadControlScheduleProfileList != NULL) {
    /* clear struct: (*this->loadControlScheduleProfileList) */
    (*this->loadControlScheduleProfileList).clear( );
    delete this->loadControlScheduleProfileList;
    this->loadControlScheduleProfileList = NULL;
  }
  if (this->essControlScheduleProfileList != NULL) {
    /* clear struct: (*this->essControlScheduleProfileList) */
    (*this->essControlScheduleProfileList).clear( );
    delete this->essControlScheduleProfileList;
    this->essControlScheduleProfileList = NULL;
  }
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedOptimizerScheduleProfile copy()
 ******************************************************************/
void openfmb::optimizermodule::PlannedOptimizerScheduleProfile::copy( const PlannedOptimizerScheduleProfile * copy_from )
{

  PlannedOptimizerScheduleProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy regulatorControlScheduleProfileList */
  if (copy_from->regulatorControlScheduleProfileList) {
    copy_to->regulatorControlScheduleProfileList = (struct openfmb::optimizermodule::RegulatorControlScheduleProfileList*)new struct openfmb::optimizermodule::RegulatorControlScheduleProfileList();
    (*copy_to->regulatorControlScheduleProfileList).copy( &(*copy_from->regulatorControlScheduleProfileList) );
  }
  else
    copy_to->regulatorControlScheduleProfileList = NULL;

  /* copy solarControlScheduleProfileList */
  if (copy_from->solarControlScheduleProfileList) {
    copy_to->solarControlScheduleProfileList = (struct openfmb::optimizermodule::SolarControlScheduleProfileList*)new struct openfmb::optimizermodule::SolarControlScheduleProfileList();
    (*copy_to->solarControlScheduleProfileList).copy( &(*copy_from->solarControlScheduleProfileList) );
  }
  else
    copy_to->solarControlScheduleProfileList = NULL;

  /* copy plannedInterconnectionScheduleProfileList */
  if (copy_from->plannedInterconnectionScheduleProfileList) {
    copy_to->plannedInterconnectionScheduleProfileList = (struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList*)new struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList();
    (*copy_to->plannedInterconnectionScheduleProfileList).copy( &(*copy_from->plannedInterconnectionScheduleProfileList) );
  }
  else
    copy_to->plannedInterconnectionScheduleProfileList = NULL;

  /* copy loadControlScheduleProfileList */
  if (copy_from->loadControlScheduleProfileList) {
    copy_to->loadControlScheduleProfileList = (struct openfmb::optimizermodule::LoadControlScheduleProfileList*)new struct openfmb::optimizermodule::LoadControlScheduleProfileList();
    (*copy_to->loadControlScheduleProfileList).copy( &(*copy_from->loadControlScheduleProfileList) );
  }
  else
    copy_to->loadControlScheduleProfileList = NULL;

  /* copy essControlScheduleProfileList */
  if (copy_from->essControlScheduleProfileList) {
    copy_to->essControlScheduleProfileList = (struct openfmb::optimizermodule::ESSControlScheduleProfileList*)new struct openfmb::optimizermodule::ESSControlScheduleProfileList();
    (*copy_to->essControlScheduleProfileList).copy( &(*copy_from->essControlScheduleProfileList) );
  }
  else
    copy_to->essControlScheduleProfileList = NULL;

}

/******************************************************************
 *  openfmb::optimizermodule::PlannedOptimizerScheduleProfile::get_marshal_size()
 ******************************************************************/
int openfmb::optimizermodule::PlannedOptimizerScheduleProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (regulatorControlScheduleProfileList != NULL) {
          offset = (*regulatorControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (solarControlScheduleProfileList != NULL) {
          offset = (*solarControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (plannedInterconnectionScheduleProfileList != NULL) {
          offset = (*plannedInterconnectionScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (loadControlScheduleProfileList != NULL) {
          offset = (*loadControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essControlScheduleProfileList != NULL) {
          offset = (*essControlScheduleProfileList).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedOptimizerScheduleProfile::marshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::PlannedOptimizerScheduleProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (regulatorControlScheduleProfileList != NULL) {
              offset = (*regulatorControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarControlScheduleProfileList != NULL) {
              offset = (*solarControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (plannedInterconnectionScheduleProfileList != NULL) {
              offset = (*plannedInterconnectionScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadControlScheduleProfileList != NULL) {
              offset = (*loadControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essControlScheduleProfileList != NULL) {
              offset = (*essControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (regulatorControlScheduleProfileList != NULL) {
              offset = (*regulatorControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 1;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarControlScheduleProfileList != NULL) {
              offset = (*solarControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 2;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (plannedInterconnectionScheduleProfileList != NULL) {
              offset = (*plannedInterconnectionScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 3;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (loadControlScheduleProfileList != NULL) {
              offset = (*loadControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essControlScheduleProfileList != NULL) {
              offset = (*essControlScheduleProfileList).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedOptimizerScheduleProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::PlannedOptimizerScheduleProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedOptimizerScheduleProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::optimizermodule::PlannedOptimizerScheduleProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                regulatorControlScheduleProfileList = (struct openfmb::optimizermodule::RegulatorControlScheduleProfileList*)new struct openfmb::optimizermodule::RegulatorControlScheduleProfileList();
                offset = (*regulatorControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                regulatorControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarControlScheduleProfileList = (struct openfmb::optimizermodule::SolarControlScheduleProfileList*)new struct openfmb::optimizermodule::SolarControlScheduleProfileList();
                offset = (*solarControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                plannedInterconnectionScheduleProfileList = (struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList*)new struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList();
                offset = (*plannedInterconnectionScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                plannedInterconnectionScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadControlScheduleProfileList = (struct openfmb::optimizermodule::LoadControlScheduleProfileList*)new struct openfmb::optimizermodule::LoadControlScheduleProfileList();
                offset = (*loadControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essControlScheduleProfileList = (struct openfmb::optimizermodule::ESSControlScheduleProfileList*)new struct openfmb::optimizermodule::ESSControlScheduleProfileList();
                offset = (*essControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 0) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                regulatorControlScheduleProfileList = (struct openfmb::optimizermodule::RegulatorControlScheduleProfileList*)new struct openfmb::optimizermodule::RegulatorControlScheduleProfileList();
                offset = (*regulatorControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                regulatorControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 1) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarControlScheduleProfileList = (struct openfmb::optimizermodule::SolarControlScheduleProfileList*)new struct openfmb::optimizermodule::SolarControlScheduleProfileList();
                offset = (*solarControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 2) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                plannedInterconnectionScheduleProfileList = (struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList*)new struct openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList();
                offset = (*plannedInterconnectionScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                plannedInterconnectionScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 3) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                loadControlScheduleProfileList = (struct openfmb::optimizermodule::LoadControlScheduleProfileList*)new struct openfmb::optimizermodule::LoadControlScheduleProfileList();
                offset = (*loadControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                loadControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essControlScheduleProfileList = (struct openfmb::optimizermodule::ESSControlScheduleProfileList*)new struct openfmb::optimizermodule::ESSControlScheduleProfileList();
                offset = (*essControlScheduleProfileList).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essControlScheduleProfileList = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedOptimizerScheduleProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::optimizermodule::PlannedOptimizerScheduleProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::optimizermodule::PlannedOptimizerScheduleProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::optimizermodule::PlannedOptimizerScheduleProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("regulatorControlScheduleProfileList", fieldname, 35) == 0) && 
       (fieldname[35] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::PlannedOptimizerScheduleProfile,regulatorControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::RegulatorControlScheduleProfileList::get_field_def(&fieldname[36], field_def);
  }
  if ( (strncmp("solarControlScheduleProfileList", fieldname, 31) == 0) && 
       (fieldname[31] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::PlannedOptimizerScheduleProfile,solarControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::SolarControlScheduleProfileList::get_field_def(&fieldname[32], field_def);
  }
  if ( (strncmp("plannedInterconnectionScheduleProfileList", fieldname, 41) == 0) && 
       (fieldname[41] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::PlannedOptimizerScheduleProfile,plannedInterconnectionScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::PlannedInterconnectionScheduleProfileList::get_field_def(&fieldname[42], field_def);
  }
  if ( (strncmp("loadControlScheduleProfileList", fieldname, 30) == 0) && 
       (fieldname[30] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::PlannedOptimizerScheduleProfile,loadControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::LoadControlScheduleProfileList::get_field_def(&fieldname[31], field_def);
  }
  if ( (strncmp("essControlScheduleProfileList", fieldname, 29) == 0) && 
       (fieldname[29] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::optimizermodule::PlannedOptimizerScheduleProfile,essControlScheduleProfileList);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::optimizermodule::ESSControlScheduleProfileList::get_field_def(&fieldname[30], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControl Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControl::RecloserControl()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControl Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControl::RecloserControl( const RecloserControl & other )
  : ControlValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControl Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControl::~RecloserControl()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControl Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserControl& openfmb::reclosermodule::RecloserControl::operator=( const openfmb::reclosermodule::RecloserControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserControl init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControl::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::init();
  this->check = NULL;
  /* init struct: this->recloserControlXCBR */
  this->recloserControlXCBR.init( );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControl clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::clear();
  if (this->check != NULL) {
    /* clear struct: (*this->check) */
    (*this->check).clear( );
    delete this->check;
    this->check = NULL;
  }
  /* clear struct: this->recloserControlXCBR */
  this->recloserControlXCBR.clear( );
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControl copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControl::copy( const RecloserControl * copy_from )
{

  RecloserControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::copy( copy_from );
  /* copy check */
  if (copy_from->check) {
    copy_to->check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
    (*copy_to->check).copy( &(*copy_from->check) );
  }
  else
    copy_to->check = NULL;

  /* copy recloserControlXCBR */
  copy_to->recloserControlXCBR.copy( &copy_from->recloserControlXCBR );

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControl::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (check != NULL) {
          offset = (*check).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = recloserControlXCBR.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControl::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          offset = recloserControlXCBR.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          offset = recloserControlXCBR.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControl::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = recloserControlXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = recloserControlXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("check", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserControl,check);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CheckConditions::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("recloserControlXCBR", fieldname, 19) == 0) && 
       (fieldname[19] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserControl,recloserControlXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::reclosermodule::RecloserControlXCBR::get_field_def(&fieldname[20], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEvent Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEvent::RecloserEvent()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEvent Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEvent::RecloserEvent( const RecloserEvent & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEvent Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEvent::~RecloserEvent()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEvent Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserEvent& openfmb::reclosermodule::RecloserEvent::operator=( const openfmb::reclosermodule::RecloserEvent & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserEvent Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserEvent init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEvent::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEvent clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEvent::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  /* clear struct: this->recloserEventXCBR */
  this->recloserEventXCBR.clear( );
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEvent copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEvent::copy( const RecloserEvent * copy_from )
{

  RecloserEvent * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy recloserEventXCBR */
  copy_to->recloserEventXCBR.copy( &copy_from->recloserEventXCBR );

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEvent::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEvent::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = recloserEventXCBR.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEvent::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEvent::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = recloserEventXCBR.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = recloserEventXCBR.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEvent::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEvent::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEvent::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEvent::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = recloserEventXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = recloserEventXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEvent::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEvent::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEvent get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserEvent::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("recloserEventXCBR", fieldname, 17) == 0) && 
       (fieldname[17] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserEvent,recloserEventXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::reclosermodule::RecloserEventXCBR::get_field_def(&fieldname[18], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatus Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatus::RecloserStatus()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatus Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatus::RecloserStatus( const RecloserStatus & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatus Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatus::~RecloserStatus()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatus Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserStatus& openfmb::reclosermodule::RecloserStatus::operator=( const openfmb::reclosermodule::RecloserStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserStatus init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatus::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
  this->recloserStatusXCBR = NULL;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatus clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  if (this->recloserStatusXCBR != NULL) {
    /* clear struct: (*this->recloserStatusXCBR) */
    (*this->recloserStatusXCBR).clear( );
    delete this->recloserStatusXCBR;
    this->recloserStatusXCBR = NULL;
  }
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatus copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatus::copy( const RecloserStatus * copy_from )
{

  RecloserStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy recloserStatusXCBR */
  if (copy_from->recloserStatusXCBR) {
    copy_to->recloserStatusXCBR = (struct openfmb::reclosermodule::RecloserStatusXCBR*)new struct openfmb::reclosermodule::RecloserStatusXCBR();
    (*copy_to->recloserStatusXCBR).copy( &(*copy_from->recloserStatusXCBR) );
  }
  else
    copy_to->recloserStatusXCBR = NULL;

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatus::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (recloserStatusXCBR != NULL) {
          offset = (*recloserStatusXCBR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatus::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (recloserStatusXCBR != NULL) {
              offset = (*recloserStatusXCBR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (recloserStatusXCBR != NULL) {
              offset = (*recloserStatusXCBR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                recloserStatusXCBR = (struct openfmb::reclosermodule::RecloserStatusXCBR*)new struct openfmb::reclosermodule::RecloserStatusXCBR();
                offset = (*recloserStatusXCBR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                recloserStatusXCBR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                recloserStatusXCBR = (struct openfmb::reclosermodule::RecloserStatusXCBR*)new struct openfmb::reclosermodule::RecloserStatusXCBR();
                offset = (*recloserStatusXCBR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                recloserStatusXCBR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("recloserStatusXCBR", fieldname, 18) == 0) && 
       (fieldname[18] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserStatus,recloserStatusXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::reclosermodule::RecloserStatusXCBR::get_field_def(&fieldname[19], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarEventZGEN Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarEventZGEN::SolarEventZGEN()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarEventZGEN Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarEventZGEN::SolarEventZGEN( const SolarEventZGEN & other )
  : InverterEventAndStatusZGEN()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarEventZGEN Destructor
 ******************************************************************/
openfmb::solarmodule::SolarEventZGEN::~SolarEventZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarEventZGEN Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarEventZGEN& openfmb::solarmodule::SolarEventZGEN::operator=( const openfmb::solarmodule::SolarEventZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarEventZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarEventZGEN init()
 ******************************************************************/
void openfmb::solarmodule::SolarEventZGEN::init()
{
  /* init PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::init();
  this->GriMod = NULL;
  /* init struct: this->SolarSt */
  this->SolarSt.init( );
}

/******************************************************************
 * openfmb::solarmodule::SolarEventZGEN clear()
 ******************************************************************/
void openfmb::solarmodule::SolarEventZGEN::clear()
{
  /* clear PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::clear();
  if (this->GriMod != NULL) {
    /* clear struct: (*this->GriMod) */
    (*this->GriMod).clear( );
    delete this->GriMod;
    this->GriMod = NULL;
  }
  /* clear struct: this->SolarSt */
  this->SolarSt.clear( );
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventZGEN copy()
 ******************************************************************/
void openfmb::solarmodule::SolarEventZGEN::copy( const SolarEventZGEN * copy_from )
{

  SolarEventZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::copy( copy_from );
  /* copy GriMod */
  if (copy_from->GriMod) {
    copy_to->GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
    (*copy_to->GriMod).copy( &(*copy_from->GriMod) );
  }
  else
    copy_to->GriMod = NULL;

  /* copy SolarSt */
  copy_to->SolarSt.copy( &copy_from->SolarSt );

}

/******************************************************************
 *  openfmb::solarmodule::SolarEventZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarEventZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GriMod != NULL) {
          offset = (*GriMod).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = SolarSt.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarEventZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 12;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          offset = SolarSt.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 12;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          offset = SolarSt.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarEventZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarEventZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 12) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = SolarSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 12) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = SolarSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarEventZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarEventZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::InverterEventAndStatusZGEN::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("GriMod", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarEventZGEN,GriMod);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ENG_GridConnectModeKind::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("SolarSt", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarEventZGEN,SolarSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::ENS_SolarStateKind::get_field_def(&fieldname[8], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusZGEN Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarStatusZGEN::SolarStatusZGEN()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusZGEN Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarStatusZGEN::SolarStatusZGEN( const SolarStatusZGEN & other )
  : InverterEventAndStatusZGEN()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusZGEN Destructor
 ******************************************************************/
openfmb::solarmodule::SolarStatusZGEN::~SolarStatusZGEN()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusZGEN Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarStatusZGEN& openfmb::solarmodule::SolarStatusZGEN::operator=( const openfmb::solarmodule::SolarStatusZGEN & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarStatusZGEN Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarStatusZGEN init()
 ******************************************************************/
void openfmb::solarmodule::SolarStatusZGEN::init()
{
  /* init PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::init();
  this->GriMod = NULL;
  /* init struct: this->SolarSt */
  this->SolarSt.init( );
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusZGEN clear()
 ******************************************************************/
void openfmb::solarmodule::SolarStatusZGEN::clear()
{
  /* clear PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::clear();
  if (this->GriMod != NULL) {
    /* clear struct: (*this->GriMod) */
    (*this->GriMod).clear( );
    delete this->GriMod;
    this->GriMod = NULL;
  }
  /* clear struct: this->SolarSt */
  this->SolarSt.clear( );
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusZGEN copy()
 ******************************************************************/
void openfmb::solarmodule::SolarStatusZGEN::copy( const SolarStatusZGEN * copy_from )
{

  SolarStatusZGEN * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::InverterEventAndStatusZGEN */
  openfmb::commonmodule::InverterEventAndStatusZGEN::copy( copy_from );
  /* copy GriMod */
  if (copy_from->GriMod) {
    copy_to->GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
    (*copy_to->GriMod).copy( &(*copy_from->GriMod) );
  }
  else
    copy_to->GriMod = NULL;

  /* copy SolarSt */
  copy_to->SolarSt.copy( &copy_from->SolarSt );

}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusZGEN::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusZGEN::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GriMod != NULL) {
          offset = (*GriMod).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = SolarSt.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusZGEN::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusZGEN::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::InverterEventAndStatusZGEN::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 12;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          offset = SolarSt.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 12;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GriMod != NULL) {
              offset = (*GriMod).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          offset = SolarSt.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusZGEN::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusZGEN::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusZGEN::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusZGEN::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::InverterEventAndStatusZGEN::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 12) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = SolarSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 12) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GriMod = (struct openfmb::commonmodule::ENG_GridConnectModeKind*)new struct openfmb::commonmodule::ENG_GridConnectModeKind();
                offset = (*GriMod).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GriMod = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = SolarSt.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusZGEN::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusZGEN::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusZGEN get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarStatusZGEN::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::InverterEventAndStatusZGEN::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("GriMod", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarStatusZGEN,GriMod);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ENG_GridConnectModeKind::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("SolarSt", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarStatusZGEN,SolarSt);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::ENS_SolarStateKind::get_field_def(&fieldname[8], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchControl Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchControl::SwitchControl()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchControl Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchControl::SwitchControl( const SwitchControl & other )
  : ControlValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchControl Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchControl::~SwitchControl()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchControl Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchControl& openfmb::switchmodule::SwitchControl::operator=( const openfmb::switchmodule::SwitchControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchControl init()
 ******************************************************************/
void openfmb::switchmodule::SwitchControl::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::init();
  this->check = NULL;
  this->switchControlXSWI = NULL;
}

/******************************************************************
 * openfmb::switchmodule::SwitchControl clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::clear();
  if (this->check != NULL) {
    /* clear struct: (*this->check) */
    (*this->check).clear( );
    delete this->check;
    this->check = NULL;
  }
  if (this->switchControlXSWI != NULL) {
    /* clear struct: (*this->switchControlXSWI) */
    (*this->switchControlXSWI).clear( );
    delete this->switchControlXSWI;
    this->switchControlXSWI = NULL;
  }
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControl copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchControl::copy( const SwitchControl * copy_from )
{

  SwitchControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::copy( copy_from );
  /* copy check */
  if (copy_from->check) {
    copy_to->check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
    (*copy_to->check).copy( &(*copy_from->check) );
  }
  else
    copy_to->check = NULL;

  /* copy switchControlXSWI */
  if (copy_from->switchControlXSWI) {
    copy_to->switchControlXSWI = (struct openfmb::switchmodule::SwitchControlXSWI*)new struct openfmb::switchmodule::SwitchControlXSWI();
    (*copy_to->switchControlXSWI).copy( &(*copy_from->switchControlXSWI) );
  }
  else
    copy_to->switchControlXSWI = NULL;

}

/******************************************************************
 *  openfmb::switchmodule::SwitchControl::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (check != NULL) {
          offset = (*check).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (switchControlXSWI != NULL) {
          offset = (*switchControlXSWI).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControl::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (switchControlXSWI != NULL) {
              offset = (*switchControlXSWI).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (switchControlXSWI != NULL) {
              offset = (*switchControlXSWI).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControl::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                switchControlXSWI = (struct openfmb::switchmodule::SwitchControlXSWI*)new struct openfmb::switchmodule::SwitchControlXSWI();
                offset = (*switchControlXSWI).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                switchControlXSWI = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                switchControlXSWI = (struct openfmb::switchmodule::SwitchControlXSWI*)new struct openfmb::switchmodule::SwitchControlXSWI();
                offset = (*switchControlXSWI).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                switchControlXSWI = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("check", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchControl,check);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CheckConditions::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("switchControlXSWI", fieldname, 17) == 0) && 
       (fieldname[17] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchControl,switchControlXSWI);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::switchmodule::SwitchControlXSWI::get_field_def(&fieldname[18], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchEvent Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchEvent::SwitchEvent()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEvent Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchEvent::SwitchEvent( const SwitchEvent & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchEvent Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchEvent::~SwitchEvent()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEvent Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchEvent& openfmb::switchmodule::SwitchEvent::operator=( const openfmb::switchmodule::SwitchEvent & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchEvent Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchEvent init()
 ******************************************************************/
void openfmb::switchmodule::SwitchEvent::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEvent clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchEvent::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  /* clear struct: this->switchEventXCBR */
  this->switchEventXCBR.clear( );
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEvent copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchEvent::copy( const SwitchEvent * copy_from )
{

  SwitchEvent * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy switchEventXCBR */
  copy_to->switchEventXCBR.copy( &copy_from->switchEventXCBR );

}

/******************************************************************
 *  openfmb::switchmodule::SwitchEvent::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchEvent::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = switchEventXCBR.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEvent::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchEvent::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = switchEventXCBR.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = switchEventXCBR.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEvent::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchEvent::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEvent::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchEvent::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = switchEventXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = switchEventXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEvent::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchEvent::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEvent get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchEvent::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("switchEventXCBR", fieldname, 15) == 0) && 
       (fieldname[15] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchEvent,switchEventXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::switchmodule::SwitchEventXSWI::get_field_def(&fieldname[16], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatus Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatus::SwitchStatus()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatus Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatus::SwitchStatus( const SwitchStatus & other )
  : StatusValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatus Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatus::~SwitchStatus()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatus Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchStatus& openfmb::switchmodule::SwitchStatus::operator=( const openfmb::switchmodule::SwitchStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchStatus init()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatus::init()
{
  /* init PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatus clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::clear();
  /* clear struct: this->switchStatusXCBR */
  this->switchStatusXCBR.clear( );
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatus copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatus::copy( const SwitchStatus * copy_from )
{

  SwitchStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::copy( copy_from );
  /* copy switchStatusXCBR */
  copy_to->switchStatusXCBR.copy( &copy_from->switchStatusXCBR );

}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatus::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
      offset = switchStatusXCBR.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatus::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = switchStatusXCBR.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = switchStatusXCBR.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = switchStatusXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = switchStatusXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("switchStatusXCBR", fieldname, 16) == 0) && 
       (fieldname[16] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchStatus,switchStatusXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::switchmodule::SwitchStatusXSWI::get_field_def(&fieldname[17], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerControl Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerControl::BreakerControl()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerControl Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerControl::BreakerControl( const BreakerControl & other )
  : ControlValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerControl Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerControl::~BreakerControl()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerControl Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerControl& openfmb::breakermodule::BreakerControl::operator=( const openfmb::breakermodule::BreakerControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerControl init()
 ******************************************************************/
void openfmb::breakermodule::BreakerControl::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::init();
  this->check = NULL;
  /* init struct: this->breakerControlXCBR */
  this->breakerControlXCBR.init( );
}

/******************************************************************
 * openfmb::breakermodule::BreakerControl clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::clear();
  if (this->check != NULL) {
    /* clear struct: (*this->check) */
    (*this->check).clear( );
    delete this->check;
    this->check = NULL;
  }
  /* clear struct: this->breakerControlXCBR */
  this->breakerControlXCBR.clear( );
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControl copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerControl::copy( const BreakerControl * copy_from )
{

  BreakerControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::copy( copy_from );
  /* copy check */
  if (copy_from->check) {
    copy_to->check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
    (*copy_to->check).copy( &(*copy_from->check) );
  }
  else
    copy_to->check = NULL;

  /* copy breakerControlXCBR */
  copy_to->breakerControlXCBR.copy( &copy_from->breakerControlXCBR );

}

/******************************************************************
 *  openfmb::breakermodule::BreakerControl::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (check != NULL) {
          offset = (*check).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = breakerControlXCBR.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControl::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          offset = breakerControlXCBR.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          offset = breakerControlXCBR.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControl::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = breakerControlXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = breakerControlXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("check", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerControl,check);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CheckConditions::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("breakerControlXCBR", fieldname, 18) == 0) && 
       (fieldname[18] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerControl,breakerControlXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::breakermodule::BreakerControlXCBR::get_field_def(&fieldname[19], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerEvent Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerEvent::BreakerEvent()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEvent Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerEvent::BreakerEvent( const BreakerEvent & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerEvent Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerEvent::~BreakerEvent()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEvent Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerEvent& openfmb::breakermodule::BreakerEvent::operator=( const openfmb::breakermodule::BreakerEvent & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerEvent Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerEvent init()
 ******************************************************************/
void openfmb::breakermodule::BreakerEvent::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEvent clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerEvent::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  /* clear struct: this->breakerEventXCBR */
  this->breakerEventXCBR.clear( );
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEvent copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerEvent::copy( const BreakerEvent * copy_from )
{

  BreakerEvent * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy breakerEventXCBR */
  copy_to->breakerEventXCBR.copy( &copy_from->breakerEventXCBR );

}

/******************************************************************
 *  openfmb::breakermodule::BreakerEvent::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerEvent::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = breakerEventXCBR.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEvent::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerEvent::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = breakerEventXCBR.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = breakerEventXCBR.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEvent::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerEvent::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEvent::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerEvent::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = breakerEventXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = breakerEventXCBR.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEvent::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerEvent::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEvent get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerEvent::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("breakerEventXCBR", fieldname, 16) == 0) && 
       (fieldname[16] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerEvent,breakerEventXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::breakermodule::BreakerEventXCBR::get_field_def(&fieldname[17], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatus Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatus::BreakerStatus()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatus Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatus::BreakerStatus( const BreakerStatus & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatus Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatus::~BreakerStatus()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatus Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerStatus& openfmb::breakermodule::BreakerStatus::operator=( const openfmb::breakermodule::BreakerStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerStatus init()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatus::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
  this->breakerStatusXCBR = NULL;
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatus clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  if (this->breakerStatusXCBR != NULL) {
    /* clear struct: (*this->breakerStatusXCBR) */
    (*this->breakerStatusXCBR).clear( );
    delete this->breakerStatusXCBR;
    this->breakerStatusXCBR = NULL;
  }
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatus copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatus::copy( const BreakerStatus * copy_from )
{

  BreakerStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy breakerStatusXCBR */
  if (copy_from->breakerStatusXCBR) {
    copy_to->breakerStatusXCBR = (struct openfmb::breakermodule::BreakerStatusXCBR*)new struct openfmb::breakermodule::BreakerStatusXCBR();
    (*copy_to->breakerStatusXCBR).copy( &(*copy_from->breakerStatusXCBR) );
  }
  else
    copy_to->breakerStatusXCBR = NULL;

}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatus::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (breakerStatusXCBR != NULL) {
          offset = (*breakerStatusXCBR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatus::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (breakerStatusXCBR != NULL) {
              offset = (*breakerStatusXCBR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (breakerStatusXCBR != NULL) {
              offset = (*breakerStatusXCBR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                breakerStatusXCBR = (struct openfmb::breakermodule::BreakerStatusXCBR*)new struct openfmb::breakermodule::BreakerStatusXCBR();
                offset = (*breakerStatusXCBR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                breakerStatusXCBR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                breakerStatusXCBR = (struct openfmb::breakermodule::BreakerStatusXCBR*)new struct openfmb::breakermodule::BreakerStatusXCBR();
                offset = (*breakerStatusXCBR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                breakerStatusXCBR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("breakerStatusXCBR", fieldname, 17) == 0) && 
       (fieldname[17] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerStatus,breakerStatusXCBR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::breakermodule::BreakerStatusXCBR::get_field_def(&fieldname[18], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlIED Default Constructor
 ******************************************************************/
openfmb::commonmodule::ControlIED::ControlIED()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ControlIED Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ControlIED::ControlIED( const ControlIED & other )
  : ControlValueSource()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ControlIED Destructor
 ******************************************************************/
openfmb::commonmodule::ControlIED::~ControlIED()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ControlIED Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ControlIED& openfmb::commonmodule::ControlIED::operator=( const openfmb::commonmodule::ControlIED & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ControlIED Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ControlIED init()
 ******************************************************************/
void openfmb::commonmodule::ControlIED::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValueSource */
  openfmb::commonmodule::ControlValueSource::init();
  this->sourceApplicationID = NULL;
  this->sourceDateTime = 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlIED clear()
 ******************************************************************/
void openfmb::commonmodule::ControlIED::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValueSource */
  openfmb::commonmodule::ControlValueSource::clear();
  /* clear string: this->sourceApplicationID */
  if (this->sourceApplicationID != NULL) {
    delete[] this->sourceApplicationID;
    this->sourceApplicationID = NULL;
  }
  /* clear basic type: this->sourceDateTime NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::ControlIED copy()
 ******************************************************************/
void openfmb::commonmodule::ControlIED::copy( const ControlIED * copy_from )
{

  ControlIED * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValueSource */
  openfmb::commonmodule::ControlValueSource::copy( copy_from );
  /* copy sourceApplicationID */
  if (copy_from->sourceApplicationID) {
    copy_to->sourceApplicationID = new char[strlen(copy_from->sourceApplicationID) + 1];
    strcpy( copy_to->sourceApplicationID, copy_from->sourceApplicationID );
  }

  /* copy sourceDateTime */
  copy_to->sourceDateTime = copy_from->sourceDateTime;

}

/******************************************************************
 *  openfmb::commonmodule::ControlIED::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ControlIED::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValueSource::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
      /* sourceDateTime */
      offset = (offset+7) & 0xfffffff8; /* align 8*/
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlIED::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlIED::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValueSource::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG_AND_REORDER(buf, offset, sourceDateTime);
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG(buf, offset, sourceDateTime);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlIED::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlIED::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlIED::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlIED::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG_AND_REORDER(buf, offset, sourceDateTime, stream_len);
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG(buf, offset, sourceDateTime, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlIED::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlIED::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlIED get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ControlIED::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValueSource::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("sourceApplicationID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ControlIED,sourceApplicationID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ControlIED,sourceApplicationID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sourceDateTime", fieldname)==0) {
    field_def->kind       = 17;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ControlIED,sourceDateTime);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ControlIED,sourceDateTime);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlScheduleFSCH Default Constructor
 ******************************************************************/
openfmb::commonmodule::ControlScheduleFSCH::ControlScheduleFSCH()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ControlScheduleFSCH Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ControlScheduleFSCH::ControlScheduleFSCH( const ControlScheduleFSCH & other )
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ControlScheduleFSCH Destructor
 ******************************************************************/
openfmb::commonmodule::ControlScheduleFSCH::~ControlScheduleFSCH()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ControlScheduleFSCH Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ControlScheduleFSCH& openfmb::commonmodule::ControlScheduleFSCH::operator=( const openfmb::commonmodule::ControlScheduleFSCH & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ControlScheduleFSCH Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ControlScheduleFSCH init()
 ******************************************************************/
void openfmb::commonmodule::ControlScheduleFSCH::init()
{
  /* init struct: this->ValACSG */
  this->ValACSG.init( );
}

/******************************************************************
 * openfmb::commonmodule::ControlScheduleFSCH clear()
 ******************************************************************/
void openfmb::commonmodule::ControlScheduleFSCH::clear()
{
  /* clear struct: this->ValACSG */
  this->ValACSG.clear( );
}

/******************************************************************
 *  openfmb::commonmodule::ControlScheduleFSCH copy()
 ******************************************************************/
void openfmb::commonmodule::ControlScheduleFSCH::copy( const ControlScheduleFSCH * copy_from )
{

  ControlScheduleFSCH * copy_to = this;

  if ( ! copy_from ) return;


  /* copy ValACSG */
  copy_to->ValACSG.copy( &copy_from->ValACSG );

}

/******************************************************************
 *  openfmb::commonmodule::ControlScheduleFSCH::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ControlScheduleFSCH::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
    }
  else
    {
      offset = ValACSG.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlScheduleFSCH::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlScheduleFSCH::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = ValACSG.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = ValACSG.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlScheduleFSCH::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlScheduleFSCH::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlScheduleFSCH::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlScheduleFSCH::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = ValACSG.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = ValACSG.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlScheduleFSCH::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlScheduleFSCH::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlScheduleFSCH get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ControlScheduleFSCH::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
  if ( (strncmp("ValACSG", fieldname, 7) == 0) && 
       (fieldname[7] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ControlScheduleFSCH,ValACSG);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::CSG::get_field_def(&fieldname[8], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::EventIED Default Constructor
 ******************************************************************/
openfmb::commonmodule::EventIED::EventIED()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::EventIED Copy Constructor
 ******************************************************************/
openfmb::commonmodule::EventIED::EventIED( const EventIED & other )
  : EventValueSource()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::EventIED Destructor
 ******************************************************************/
openfmb::commonmodule::EventIED::~EventIED()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::EventIED Assignment Operator
 ******************************************************************/
openfmb::commonmodule::EventIED& openfmb::commonmodule::EventIED::operator=( const openfmb::commonmodule::EventIED & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::EventIED Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::EventIED init()
 ******************************************************************/
void openfmb::commonmodule::EventIED::init()
{
  /* init PARENT: openfmb::commonmodule::EventValueSource */
  openfmb::commonmodule::EventValueSource::init();
  this->sourceApplicationID = NULL;
  this->sourceDateTime = 0;
}

/******************************************************************
 * openfmb::commonmodule::EventIED clear()
 ******************************************************************/
void openfmb::commonmodule::EventIED::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValueSource */
  openfmb::commonmodule::EventValueSource::clear();
  /* clear string: this->sourceApplicationID */
  if (this->sourceApplicationID != NULL) {
    delete[] this->sourceApplicationID;
    this->sourceApplicationID = NULL;
  }
  /* clear basic type: this->sourceDateTime NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::EventIED copy()
 ******************************************************************/
void openfmb::commonmodule::EventIED::copy( const EventIED * copy_from )
{

  EventIED * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValueSource */
  openfmb::commonmodule::EventValueSource::copy( copy_from );
  /* copy sourceApplicationID */
  if (copy_from->sourceApplicationID) {
    copy_to->sourceApplicationID = new char[strlen(copy_from->sourceApplicationID) + 1];
    strcpy( copy_to->sourceApplicationID, copy_from->sourceApplicationID );
  }

  /* copy sourceDateTime */
  copy_to->sourceDateTime = copy_from->sourceDateTime;

}

/******************************************************************
 *  openfmb::commonmodule::EventIED::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::EventIED::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::EventValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
      /* sourceDateTime */
      offset = (offset+7) & 0xfffffff8; /* align 8*/
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventIED::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::EventIED::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValueSource::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG_AND_REORDER(buf, offset, sourceDateTime);
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG(buf, offset, sourceDateTime);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventIED::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::EventIED::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventValueSource::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventIED::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::EventIED::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG_AND_REORDER(buf, offset, sourceDateTime, stream_len);
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG(buf, offset, sourceDateTime, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventIED::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::EventIED::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventValueSource::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::EventIED get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::EventIED::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValueSource::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("sourceApplicationID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::EventIED,sourceApplicationID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::EventIED,sourceApplicationID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sourceDateTime", fieldname)==0) {
    field_def->kind       = 17;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::EventIED,sourceDateTime);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::EventIED,sourceDateTime);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ForecastIED Default Constructor
 ******************************************************************/
openfmb::commonmodule::ForecastIED::ForecastIED()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ForecastIED Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ForecastIED::ForecastIED( const ForecastIED & other )
  : ForecastValueSource()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ForecastIED Destructor
 ******************************************************************/
openfmb::commonmodule::ForecastIED::~ForecastIED()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ForecastIED Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ForecastIED& openfmb::commonmodule::ForecastIED::operator=( const openfmb::commonmodule::ForecastIED & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ForecastIED Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ForecastIED init()
 ******************************************************************/
void openfmb::commonmodule::ForecastIED::init()
{
  /* init PARENT: openfmb::commonmodule::ForecastValueSource */
  openfmb::commonmodule::ForecastValueSource::init();
  this->sourceApplicationID = NULL;
  this->sourceDateTime = 0;
}

/******************************************************************
 * openfmb::commonmodule::ForecastIED clear()
 ******************************************************************/
void openfmb::commonmodule::ForecastIED::clear()
{
  /* clear PARENT: openfmb::commonmodule::ForecastValueSource */
  openfmb::commonmodule::ForecastValueSource::clear();
  /* clear string: this->sourceApplicationID */
  if (this->sourceApplicationID != NULL) {
    delete[] this->sourceApplicationID;
    this->sourceApplicationID = NULL;
  }
  /* clear basic type: this->sourceDateTime NOOP */
}

/******************************************************************
 *  openfmb::commonmodule::ForecastIED copy()
 ******************************************************************/
void openfmb::commonmodule::ForecastIED::copy( const ForecastIED * copy_from )
{

  ForecastIED * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ForecastValueSource */
  openfmb::commonmodule::ForecastValueSource::copy( copy_from );
  /* copy sourceApplicationID */
  if (copy_from->sourceApplicationID) {
    copy_to->sourceApplicationID = new char[strlen(copy_from->sourceApplicationID) + 1];
    strcpy( copy_to->sourceApplicationID, copy_from->sourceApplicationID );
  }

  /* copy sourceDateTime */
  copy_to->sourceDateTime = copy_from->sourceDateTime;

}

/******************************************************************
 *  openfmb::commonmodule::ForecastIED::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ForecastIED::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ForecastValueSource::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ForecastValueSource::get_marshal_size(offset, just_keys);
      /* sourceApplicationID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (sourceApplicationID==NULL)?1:(unsigned int)((strlen(sourceApplicationID)+1)*1);
      /* sourceDateTime */
      offset = (offset+7) & 0xfffffff8; /* align 8*/
      offset += 8;
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastIED::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ForecastIED::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ForecastValueSource::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG_AND_REORDER(buf, offset, sourceDateTime);
        }
      else
        {
          { int len = 1;
          if ( sourceApplicationID ) len += (int)strlen( sourceApplicationID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, sourceApplicationID, len);
          }
          DDS_MARSH_PUT_LONGLONG(buf, offset, sourceDateTime);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastIED::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ForecastIED::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastIED::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ForecastIED::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ForecastValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ForecastValueSource::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG_AND_REORDER(buf, offset, sourceDateTime, stream_len);
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          sourceApplicationID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, sourceApplicationID, len, stream_len);
          }
          DDS_MARSH_GET_LONGLONG(buf, offset, sourceDateTime, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastIED::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ForecastIED::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ForecastIED get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ForecastIED::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ForecastValueSource::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("sourceApplicationID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ForecastIED,sourceApplicationID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ForecastIED,sourceApplicationID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if (strcmp("sourceDateTime", fieldname)==0) {
    field_def->kind       = 17;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::commonmodule::ForecastIED,sourceDateTime);
    } else
      field_def->offset  += s_offsetof(struct openfmb::commonmodule::ForecastIED,sourceDateTime);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMXU Default Constructor
 ******************************************************************/
openfmb::commonmodule::ReadingMMXU::ReadingMMXU()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMXU Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ReadingMMXU::ReadingMMXU( const ReadingMMXU & other )
  : LogicalNode()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMXU Destructor
 ******************************************************************/
openfmb::commonmodule::ReadingMMXU::~ReadingMMXU()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMXU Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ReadingMMXU& openfmb::commonmodule::ReadingMMXU::operator=( const openfmb::commonmodule::ReadingMMXU & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ReadingMMXU Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ReadingMMXU init()
 ******************************************************************/
void openfmb::commonmodule::ReadingMMXU::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::init();
  this->Hz = NULL;
  this->PPV = NULL;
  this->ClcMth = NULL;
  this->PhV = NULL;
  this->A = NULL;
  this->W = NULL;
  this->VAr = NULL;
  this->VA = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ReadingMMXU clear()
 ******************************************************************/
void openfmb::commonmodule::ReadingMMXU::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::clear();
  if (this->Hz != NULL) {
    /* clear struct: (*this->Hz) */
    (*this->Hz).clear( );
    delete this->Hz;
    this->Hz = NULL;
  }
  if (this->PPV != NULL) {
    /* clear struct: (*this->PPV) */
    (*this->PPV).clear( );
    delete this->PPV;
    this->PPV = NULL;
  }
  if (this->ClcMth != NULL) {
    /* clear struct: (*this->ClcMth) */
    (*this->ClcMth).clear( );
    delete this->ClcMth;
    this->ClcMth = NULL;
  }
  if (this->PhV != NULL) {
    /* clear struct: (*this->PhV) */
    (*this->PhV).clear( );
    delete this->PhV;
    this->PhV = NULL;
  }
  if (this->A != NULL) {
    /* clear struct: (*this->A) */
    (*this->A).clear( );
    delete this->A;
    this->A = NULL;
  }
  if (this->W != NULL) {
    /* clear struct: (*this->W) */
    (*this->W).clear( );
    delete this->W;
    this->W = NULL;
  }
  if (this->VAr != NULL) {
    /* clear struct: (*this->VAr) */
    (*this->VAr).clear( );
    delete this->VAr;
    this->VAr = NULL;
  }
  if (this->VA != NULL) {
    /* clear struct: (*this->VA) */
    (*this->VA).clear( );
    delete this->VA;
    this->VA = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMXU copy()
 ******************************************************************/
void openfmb::commonmodule::ReadingMMXU::copy( const ReadingMMXU * copy_from )
{

  ReadingMMXU * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNode */
  openfmb::commonmodule::LogicalNode::copy( copy_from );
  /* copy Hz */
  if (copy_from->Hz) {
    copy_to->Hz = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
    (*copy_to->Hz).copy( &(*copy_from->Hz) );
  }
  else
    copy_to->Hz = NULL;

  /* copy PPV */
  if (copy_from->PPV) {
    copy_to->PPV = (struct openfmb::commonmodule::DEL*)new struct openfmb::commonmodule::DEL();
    (*copy_to->PPV).copy( &(*copy_from->PPV) );
  }
  else
    copy_to->PPV = NULL;

  /* copy ClcMth */
  if (copy_from->ClcMth) {
    copy_to->ClcMth = (struct openfmb::commonmodule::ENG_CalcMethodKind*)new struct openfmb::commonmodule::ENG_CalcMethodKind();
    (*copy_to->ClcMth).copy( &(*copy_from->ClcMth) );
  }
  else
    copy_to->ClcMth = NULL;

  /* copy PhV */
  if (copy_from->PhV) {
    copy_to->PhV = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
    (*copy_to->PhV).copy( &(*copy_from->PhV) );
  }
  else
    copy_to->PhV = NULL;

  /* copy A */
  if (copy_from->A) {
    copy_to->A = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
    (*copy_to->A).copy( &(*copy_from->A) );
  }
  else
    copy_to->A = NULL;

  /* copy W */
  if (copy_from->W) {
    copy_to->W = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
    (*copy_to->W).copy( &(*copy_from->W) );
  }
  else
    copy_to->W = NULL;

  /* copy VAr */
  if (copy_from->VAr) {
    copy_to->VAr = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
    (*copy_to->VAr).copy( &(*copy_from->VAr) );
  }
  else
    copy_to->VAr = NULL;

  /* copy VA */
  if (copy_from->VA) {
    copy_to->VA = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
    (*copy_to->VA).copy( &(*copy_from->VA) );
  }
  else
    copy_to->VA = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMXU::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMXU::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (Hz != NULL) {
          offset = (*Hz).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (PPV != NULL) {
          offset = (*PPV).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (ClcMth != NULL) {
          offset = (*ClcMth).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (PhV != NULL) {
          offset = (*PhV).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (A != NULL) {
          offset = (*A).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (W != NULL) {
          offset = (*W).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (VAr != NULL) {
          offset = (*VAr).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (VA != NULL) {
          offset = (*VA).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMXU::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMXU::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNode::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Hz != NULL) {
              offset = (*Hz).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (PPV != NULL) {
              offset = (*PPV).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ClcMth != NULL) {
              offset = (*ClcMth).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (PhV != NULL) {
              offset = (*PhV).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (A != NULL) {
              offset = (*A).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (W != NULL) {
              offset = (*W).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (VAr != NULL) {
              offset = (*VAr).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 11;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (VA != NULL) {
              offset = (*VA).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (Hz != NULL) {
              offset = (*Hz).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (PPV != NULL) {
              offset = (*PPV).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (ClcMth != NULL) {
              offset = (*ClcMth).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (PhV != NULL) {
              offset = (*PhV).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (A != NULL) {
              offset = (*A).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 9;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (W != NULL) {
              offset = (*W).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 10;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (VAr != NULL) {
              offset = (*VAr).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 11;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (VA != NULL) {
              offset = (*VA).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMXU::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMXU::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMXU::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMXU::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNode::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Hz = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
                offset = (*Hz).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Hz = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                PPV = (struct openfmb::commonmodule::DEL*)new struct openfmb::commonmodule::DEL();
                offset = (*PPV).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                PPV = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ClcMth = (struct openfmb::commonmodule::ENG_CalcMethodKind*)new struct openfmb::commonmodule::ENG_CalcMethodKind();
                offset = (*ClcMth).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ClcMth = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                PhV = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*PhV).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                PhV = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                A = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*A).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                A = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                W = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*W).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                W = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                VAr = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*VAr).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                VAr = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 11) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                VA = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*VA).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                VA = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                Hz = (struct openfmb::commonmodule::MV*)new struct openfmb::commonmodule::MV();
                offset = (*Hz).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                Hz = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                PPV = (struct openfmb::commonmodule::DEL*)new struct openfmb::commonmodule::DEL();
                offset = (*PPV).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                PPV = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                ClcMth = (struct openfmb::commonmodule::ENG_CalcMethodKind*)new struct openfmb::commonmodule::ENG_CalcMethodKind();
                offset = (*ClcMth).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                ClcMth = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                PhV = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*PhV).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                PhV = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                A = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*A).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                A = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 9) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                W = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*W).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                W = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 10) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                VAr = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*VAr).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                VAr = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 11) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                VA = (struct openfmb::commonmodule::WYE*)new struct openfmb::commonmodule::WYE();
                offset = (*VA).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                VA = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMXU::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ReadingMMXU::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ReadingMMXU get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ReadingMMXU::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNode::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("Hz", fieldname, 2) == 0) && 
       (fieldname[2] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,Hz);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::MV::get_field_def(&fieldname[3], field_def);
  }
  if ( (strncmp("PPV", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,PPV);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::DEL::get_field_def(&fieldname[4], field_def);
  }
  if ( (strncmp("ClcMth", fieldname, 6) == 0) && 
       (fieldname[6] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,ClcMth);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ENG_CalcMethodKind::get_field_def(&fieldname[7], field_def);
  }
  if ( (strncmp("PhV", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,PhV);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::WYE::get_field_def(&fieldname[4], field_def);
  }
  if ( (strncmp("A", fieldname, 1) == 0) && 
       (fieldname[1] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,A);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::WYE::get_field_def(&fieldname[2], field_def);
  }
  if ( (strncmp("W", fieldname, 1) == 0) && 
       (fieldname[1] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,W);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::WYE::get_field_def(&fieldname[2], field_def);
  }
  if ( (strncmp("VAr", fieldname, 3) == 0) && 
       (fieldname[3] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,VAr);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::WYE::get_field_def(&fieldname[4], field_def);
  }
  if ( (strncmp("VA", fieldname, 2) == 0) && 
       (fieldname[2] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ReadingMMXU,VA);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::WYE::get_field_def(&fieldname[3], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSEvent Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSEvent::ESSEvent()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSEvent Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSEvent::ESSEvent( const ESSEvent & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSEvent Destructor
 ******************************************************************/
openfmb::essmodule::ESSEvent::~ESSEvent()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSEvent Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSEvent& openfmb::essmodule::ESSEvent::operator=( const openfmb::essmodule::ESSEvent & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSEvent Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSEvent init()
 ******************************************************************/
void openfmb::essmodule::ESSEvent::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
  this->essEventZBAT = NULL;
  this->essEventZGEN = NULL;
  this->essEventZGLD = NULL;
}

/******************************************************************
 * openfmb::essmodule::ESSEvent clear()
 ******************************************************************/
void openfmb::essmodule::ESSEvent::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  if (this->essEventZBAT != NULL) {
    /* clear struct: (*this->essEventZBAT) */
    (*this->essEventZBAT).clear( );
    delete this->essEventZBAT;
    this->essEventZBAT = NULL;
  }
  if (this->essEventZGEN != NULL) {
    /* clear struct: (*this->essEventZGEN) */
    (*this->essEventZGEN).clear( );
    delete this->essEventZGEN;
    this->essEventZGEN = NULL;
  }
  if (this->essEventZGLD != NULL) {
    /* clear struct: (*this->essEventZGLD) */
    (*this->essEventZGLD).clear( );
    delete this->essEventZGLD;
    this->essEventZGLD = NULL;
  }
}

/******************************************************************
 *  openfmb::essmodule::ESSEvent copy()
 ******************************************************************/
void openfmb::essmodule::ESSEvent::copy( const ESSEvent * copy_from )
{

  ESSEvent * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy essEventZBAT */
  if (copy_from->essEventZBAT) {
    copy_to->essEventZBAT = (struct openfmb::essmodule::EssEventZBAT*)new struct openfmb::essmodule::EssEventZBAT();
    (*copy_to->essEventZBAT).copy( &(*copy_from->essEventZBAT) );
  }
  else
    copy_to->essEventZBAT = NULL;

  /* copy essEventZGEN */
  if (copy_from->essEventZGEN) {
    copy_to->essEventZGEN = (struct openfmb::essmodule::ESSEventZGEN*)new struct openfmb::essmodule::ESSEventZGEN();
    (*copy_to->essEventZGEN).copy( &(*copy_from->essEventZGEN) );
  }
  else
    copy_to->essEventZGEN = NULL;

  /* copy essEventZGLD */
  if (copy_from->essEventZGLD) {
    copy_to->essEventZGLD = (struct openfmb::essmodule::ESSEventZGLD*)new struct openfmb::essmodule::ESSEventZGLD();
    (*copy_to->essEventZGLD).copy( &(*copy_from->essEventZGLD) );
  }
  else
    copy_to->essEventZGLD = NULL;

}

/******************************************************************
 *  openfmb::essmodule::ESSEvent::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSEvent::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essEventZBAT != NULL) {
          offset = (*essEventZBAT).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essEventZGEN != NULL) {
          offset = (*essEventZGEN).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essEventZGLD != NULL) {
          offset = (*essEventZGLD).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEvent::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEvent::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essEventZBAT != NULL) {
              offset = (*essEventZBAT).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essEventZGEN != NULL) {
              offset = (*essEventZGEN).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essEventZGLD != NULL) {
              offset = (*essEventZGLD).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essEventZBAT != NULL) {
              offset = (*essEventZBAT).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essEventZGEN != NULL) {
              offset = (*essEventZGEN).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essEventZGLD != NULL) {
              offset = (*essEventZGLD).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEvent::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEvent::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEvent::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEvent::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essEventZBAT = (struct openfmb::essmodule::EssEventZBAT*)new struct openfmb::essmodule::EssEventZBAT();
                offset = (*essEventZBAT).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essEventZBAT = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essEventZGEN = (struct openfmb::essmodule::ESSEventZGEN*)new struct openfmb::essmodule::ESSEventZGEN();
                offset = (*essEventZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essEventZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essEventZGLD = (struct openfmb::essmodule::ESSEventZGLD*)new struct openfmb::essmodule::ESSEventZGLD();
                offset = (*essEventZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essEventZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essEventZBAT = (struct openfmb::essmodule::EssEventZBAT*)new struct openfmb::essmodule::EssEventZBAT();
                offset = (*essEventZBAT).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essEventZBAT = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essEventZGEN = (struct openfmb::essmodule::ESSEventZGEN*)new struct openfmb::essmodule::ESSEventZGEN();
                offset = (*essEventZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essEventZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essEventZGLD = (struct openfmb::essmodule::ESSEventZGLD*)new struct openfmb::essmodule::ESSEventZGLD();
                offset = (*essEventZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essEventZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEvent::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEvent::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEvent get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSEvent::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("essEventZBAT", fieldname, 12) == 0) && 
       (fieldname[12] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSEvent,essEventZBAT);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::essmodule::EssEventZBAT::get_field_def(&fieldname[13], field_def);
  }
  if ( (strncmp("essEventZGEN", fieldname, 12) == 0) && 
       (fieldname[12] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSEvent,essEventZGEN);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::essmodule::ESSEventZGEN::get_field_def(&fieldname[13], field_def);
  }
  if ( (strncmp("essEventZGLD", fieldname, 12) == 0) && 
       (fieldname[12] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSEvent,essEventZGLD);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::essmodule::ESSEventZGLD::get_field_def(&fieldname[13], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSEventProfile Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSEventProfile::ESSEventProfile()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSEventProfile Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSEventProfile::ESSEventProfile( const ESSEventProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSEventProfile Destructor
 ******************************************************************/
openfmb::essmodule::ESSEventProfile::~ESSEventProfile()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSEventProfile Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSEventProfile& openfmb::essmodule::ESSEventProfile::operator=( const openfmb::essmodule::ESSEventProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSEventProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSEventProfile init()
 ******************************************************************/
void openfmb::essmodule::ESSEventProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
  /* init struct: this->essEvent */
  this->essEvent.init( );
}

/******************************************************************
 * openfmb::essmodule::ESSEventProfile clear()
 ******************************************************************/
void openfmb::essmodule::ESSEventProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  /* clear struct: this->essEvent */
  this->essEvent.clear( );
}

/******************************************************************
 *  openfmb::essmodule::ESSEventProfile copy()
 ******************************************************************/
void openfmb::essmodule::ESSEventProfile::copy( const ESSEventProfile * copy_from )
{

  ESSEventProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy essEvent */
  copy_to->essEvent.copy( &copy_from->essEvent );

}

/******************************************************************
 *  openfmb::essmodule::ESSEventProfile::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSEventProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = essEvent.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventProfile::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEventProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = essEvent.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = essEvent.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEventProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSEventProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = essEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = essEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSEventProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSEventProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSEventProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("essEvent", fieldname, 8) == 0) && 
       (fieldname[8] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSEventProfile,essEvent);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::essmodule::ESSEvent::get_field_def(&fieldname[9], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSReadingValue Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSReadingValue::ESSReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSReadingValue Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSReadingValue::ESSReadingValue( const ESSReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSReadingValue Destructor
 ******************************************************************/
openfmb::essmodule::ESSReadingValue::~ESSReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSReadingValue Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSReadingValue& openfmb::essmodule::ESSReadingValue::operator=( const openfmb::essmodule::ESSReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSReadingValue init()
 ******************************************************************/
void openfmb::essmodule::ESSReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::essmodule::ESSReadingValue clear()
 ******************************************************************/
void openfmb::essmodule::ESSReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingValue copy()
 ******************************************************************/
void openfmb::essmodule::ESSReadingValue::copy( const ESSReadingValue * copy_from )
{

  ESSReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::essmodule::ESSReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ESSReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ESSReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSStatus Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatus::ESSStatus()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSStatus Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatus::ESSStatus( const ESSStatus & other )
  : StatusValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSStatus Destructor
 ******************************************************************/
openfmb::essmodule::ESSStatus::~ESSStatus()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSStatus Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSStatus& openfmb::essmodule::ESSStatus::operator=( const openfmb::essmodule::ESSStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSStatus init()
 ******************************************************************/
void openfmb::essmodule::ESSStatus::init()
{
  /* init PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::init();
  this->essStatusZBAT = NULL;
  this->essStatusZGEN = NULL;
  this->essStatusZGLD = NULL;
}

/******************************************************************
 * openfmb::essmodule::ESSStatus clear()
 ******************************************************************/
void openfmb::essmodule::ESSStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::clear();
  if (this->essStatusZBAT != NULL) {
    /* clear struct: (*this->essStatusZBAT) */
    (*this->essStatusZBAT).clear( );
    delete this->essStatusZBAT;
    this->essStatusZBAT = NULL;
  }
  if (this->essStatusZGEN != NULL) {
    /* clear struct: (*this->essStatusZGEN) */
    (*this->essStatusZGEN).clear( );
    delete this->essStatusZGEN;
    this->essStatusZGEN = NULL;
  }
  if (this->essStatusZGLD != NULL) {
    /* clear struct: (*this->essStatusZGLD) */
    (*this->essStatusZGLD).clear( );
    delete this->essStatusZGLD;
    this->essStatusZGLD = NULL;
  }
}

/******************************************************************
 *  openfmb::essmodule::ESSStatus copy()
 ******************************************************************/
void openfmb::essmodule::ESSStatus::copy( const ESSStatus * copy_from )
{

  ESSStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::copy( copy_from );
  /* copy essStatusZBAT */
  if (copy_from->essStatusZBAT) {
    copy_to->essStatusZBAT = (struct openfmb::essmodule::EssStatusZBAT*)new struct openfmb::essmodule::EssStatusZBAT();
    (*copy_to->essStatusZBAT).copy( &(*copy_from->essStatusZBAT) );
  }
  else
    copy_to->essStatusZBAT = NULL;

  /* copy essStatusZGEN */
  if (copy_from->essStatusZGEN) {
    copy_to->essStatusZGEN = (struct openfmb::essmodule::ESSStatusZGEN*)new struct openfmb::essmodule::ESSStatusZGEN();
    (*copy_to->essStatusZGEN).copy( &(*copy_from->essStatusZGEN) );
  }
  else
    copy_to->essStatusZGEN = NULL;

  /* copy essStatusZGLD */
  if (copy_from->essStatusZGLD) {
    copy_to->essStatusZGLD = (struct openfmb::essmodule::ESSStatusZGLD*)new struct openfmb::essmodule::ESSStatusZGLD();
    (*copy_to->essStatusZGLD).copy( &(*copy_from->essStatusZGLD) );
  }
  else
    copy_to->essStatusZGLD = NULL;

}

/******************************************************************
 *  openfmb::essmodule::ESSStatus::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essStatusZBAT != NULL) {
          offset = (*essStatusZBAT).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essStatusZGEN != NULL) {
          offset = (*essStatusZGEN).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (essStatusZGLD != NULL) {
          offset = (*essStatusZGLD).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatus::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essStatusZBAT != NULL) {
              offset = (*essStatusZBAT).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essStatusZGEN != NULL) {
              offset = (*essStatusZGEN).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essStatusZGLD != NULL) {
              offset = (*essStatusZGLD).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essStatusZBAT != NULL) {
              offset = (*essStatusZBAT).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essStatusZGEN != NULL) {
              offset = (*essStatusZGEN).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (essStatusZGLD != NULL) {
              offset = (*essStatusZGLD).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essStatusZBAT = (struct openfmb::essmodule::EssStatusZBAT*)new struct openfmb::essmodule::EssStatusZBAT();
                offset = (*essStatusZBAT).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essStatusZBAT = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essStatusZGEN = (struct openfmb::essmodule::ESSStatusZGEN*)new struct openfmb::essmodule::ESSStatusZGEN();
                offset = (*essStatusZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essStatusZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essStatusZGLD = (struct openfmb::essmodule::ESSStatusZGLD*)new struct openfmb::essmodule::ESSStatusZGLD();
                offset = (*essStatusZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essStatusZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essStatusZBAT = (struct openfmb::essmodule::EssStatusZBAT*)new struct openfmb::essmodule::EssStatusZBAT();
                offset = (*essStatusZBAT).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essStatusZBAT = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essStatusZGEN = (struct openfmb::essmodule::ESSStatusZGEN*)new struct openfmb::essmodule::ESSStatusZGEN();
                offset = (*essStatusZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essStatusZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                essStatusZGLD = (struct openfmb::essmodule::ESSStatusZGLD*)new struct openfmb::essmodule::ESSStatusZGLD();
                offset = (*essStatusZGLD).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                essStatusZGLD = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("essStatusZBAT", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSStatus,essStatusZBAT);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::essmodule::EssStatusZBAT::get_field_def(&fieldname[14], field_def);
  }
  if ( (strncmp("essStatusZGEN", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSStatus,essStatusZGEN);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::essmodule::ESSStatusZGEN::get_field_def(&fieldname[14], field_def);
  }
  if ( (strncmp("essStatusZGLD", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSStatus,essStatusZGLD);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::essmodule::ESSStatusZGLD::get_field_def(&fieldname[14], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSStatusProfile Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatusProfile::ESSStatusProfile()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSStatusProfile Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSStatusProfile::ESSStatusProfile( const ESSStatusProfile & other )
  : StatusIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSStatusProfile Destructor
 ******************************************************************/
openfmb::essmodule::ESSStatusProfile::~ESSStatusProfile()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSStatusProfile Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSStatusProfile& openfmb::essmodule::ESSStatusProfile::operator=( const openfmb::essmodule::ESSStatusProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSStatusProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSStatusProfile init()
 ******************************************************************/
void openfmb::essmodule::ESSStatusProfile::init()
{
  /* init PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::init();
  /* init struct: this->essStatus */
  this->essStatus.init( );
}

/******************************************************************
 * openfmb::essmodule::ESSStatusProfile clear()
 ******************************************************************/
void openfmb::essmodule::ESSStatusProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::clear();
  /* clear struct: this->essStatus */
  this->essStatus.clear( );
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusProfile copy()
 ******************************************************************/
void openfmb::essmodule::ESSStatusProfile::copy( const ESSStatusProfile * copy_from )
{

  ESSStatusProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::copy( copy_from );
  /* copy essStatus */
  copy_to->essStatus.copy( &copy_from->essStatus );

}

/******************************************************************
 *  openfmb::essmodule::ESSStatusProfile::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSStatusProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
      offset = essStatus.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusProfile::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatusProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = essStatus.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = essStatus.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatusProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::StatusIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSStatusProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = essStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = essStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSStatusProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::StatusIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSStatusProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSStatusProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("essStatus", fieldname, 9) == 0) && 
       (fieldname[9] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSStatusProfile,essStatus);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::essmodule::ESSStatus::get_field_def(&fieldname[10], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingValue Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationReadingValue::GenerationReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingValue Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationReadingValue::GenerationReadingValue( const GenerationReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingValue Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationReadingValue::~GenerationReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingValue Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationReadingValue& openfmb::generationmodule::GenerationReadingValue::operator=( const openfmb::generationmodule::GenerationReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationReadingValue init()
 ******************************************************************/
void openfmb::generationmodule::GenerationReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingValue clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingValue copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationReadingValue::copy( const GenerationReadingValue * copy_from )
{

  GenerationReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::generationmodule::GenerationReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::generationmodule::GenerationReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingProfile Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationReadingProfile::GenerationReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingProfile Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationReadingProfile::GenerationReadingProfile( const GenerationReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingProfile Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationReadingProfile::~GenerationReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingProfile Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationReadingProfile& openfmb::generationmodule::GenerationReadingProfile::operator=( const openfmb::generationmodule::GenerationReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationReadingProfile init()
 ******************************************************************/
void openfmb::generationmodule::GenerationReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationReadingProfile clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->generationReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->generationReadingValue.size(); i_0++)
      {
        /* clear struct: this->generationReadingValue[i_0] */
        this->generationReadingValue[i_0].clear( );
      }
    this->generationReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingProfile copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationReadingProfile::copy( const GenerationReadingProfile * copy_from )
{

  GenerationReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy generationReadingValue */
  copy_to->generationReadingValue.resize(copy_from->generationReadingValue.size());
  if ( copy_from->generationReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->generationReadingValue.size(); i_1++)
        {
          copy_to->generationReadingValue[i_1].copy( &copy_from->generationReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* generationReadingValue*/
      /* generationReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < generationReadingValue.size(); ii1++ ) {
           offset = generationReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* generationReadingValue */
          {
            unsigned int sl = (unsigned int)generationReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < generationReadingValue.size(); i1++)
            {
              offset = generationReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* generationReadingValue */
        }
      else
        {
          /* generationReadingValue */
          {
            unsigned int sl = (unsigned int)generationReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < generationReadingValue.size(); i1++)
            {
              offset = generationReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* generationReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            generationReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < generationReadingValue.capacity(); ii1++)
            {
              offset = generationReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* generationReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            generationReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < generationReadingValue.capacity(); ii1++)
            {
              offset = generationReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* generationReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventProfile Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationEventProfile::GenerationEventProfile()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventProfile Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationEventProfile::GenerationEventProfile( const GenerationEventProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventProfile Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationEventProfile::~GenerationEventProfile()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventProfile Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationEventProfile& openfmb::generationmodule::GenerationEventProfile::operator=( const openfmb::generationmodule::GenerationEventProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationEventProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationEventProfile init()
 ******************************************************************/
void openfmb::generationmodule::GenerationEventProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
  /* init struct: this->generationEvent */
  this->generationEvent.init( );
}

/******************************************************************
 * openfmb::generationmodule::GenerationEventProfile clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationEventProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  /* clear struct: this->generationEvent */
  this->generationEvent.clear( );
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventProfile copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationEventProfile::copy( const GenerationEventProfile * copy_from )
{

  GenerationEventProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy generationEvent */
  copy_to->generationEvent.copy( &copy_from->generationEvent );

}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventProfile::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = generationEvent.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventProfile::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = generationEvent.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = generationEvent.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = generationEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = generationEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationEventProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationEventProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationEventProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("generationEvent", fieldname, 15) == 0) && 
       (fieldname[15] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationEventProfile,generationEvent);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::generationmodule::GenerationEvent::get_field_def(&fieldname[16], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadEventProfile Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEventProfile::LoadEventProfile()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadEventProfile Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadEventProfile::LoadEventProfile( const LoadEventProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadEventProfile Destructor
 ******************************************************************/
openfmb::loadmodule::LoadEventProfile::~LoadEventProfile()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadEventProfile Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadEventProfile& openfmb::loadmodule::LoadEventProfile::operator=( const openfmb::loadmodule::LoadEventProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadEventProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadEventProfile init()
 ******************************************************************/
void openfmb::loadmodule::LoadEventProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
  /* init struct: this->loadEvent */
  this->loadEvent.init( );
}

/******************************************************************
 * openfmb::loadmodule::LoadEventProfile clear()
 ******************************************************************/
void openfmb::loadmodule::LoadEventProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  /* clear struct: this->loadEvent */
  this->loadEvent.clear( );
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventProfile copy()
 ******************************************************************/
void openfmb::loadmodule::LoadEventProfile::copy( const LoadEventProfile * copy_from )
{

  LoadEventProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy loadEvent */
  copy_to->loadEvent.copy( &copy_from->loadEvent );

}

/******************************************************************
 *  openfmb::loadmodule::LoadEventProfile::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadEventProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = loadEvent.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventProfile::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEventProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = loadEvent.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = loadEvent.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEventProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadEventProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = loadEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = loadEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadEventProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadEventProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadEventProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("loadEvent", fieldname, 9) == 0) && 
       (fieldname[9] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadEventProfile,loadEvent);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::loadmodule::LoadEvent::get_field_def(&fieldname[10], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingValue Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadReadingValue::LoadReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingValue Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadReadingValue::LoadReadingValue( const LoadReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingValue Destructor
 ******************************************************************/
openfmb::loadmodule::LoadReadingValue::~LoadReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingValue Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadReadingValue& openfmb::loadmodule::LoadReadingValue::operator=( const openfmb::loadmodule::LoadReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadReadingValue init()
 ******************************************************************/
void openfmb::loadmodule::LoadReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingValue clear()
 ******************************************************************/
void openfmb::loadmodule::LoadReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingValue copy()
 ******************************************************************/
void openfmb::loadmodule::LoadReadingValue::copy( const LoadReadingValue * copy_from )
{

  LoadReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::loadmodule::LoadReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::loadmodule::LoadReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlProfile Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControlProfile::RecloserControlProfile()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlProfile Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControlProfile::RecloserControlProfile( const RecloserControlProfile & other )
  : ControlIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlProfile Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserControlProfile::~RecloserControlProfile()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlProfile Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserControlProfile& openfmb::reclosermodule::RecloserControlProfile::operator=( const openfmb::reclosermodule::RecloserControlProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserControlProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserControlProfile init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControlProfile::init()
{
  /* init PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::init();
  this->targetBreakerSystemID = NULL;
  /* init struct: this->recloserControl */
  this->recloserControl.init( );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserControlProfile clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControlProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::clear();
  /* clear string: this->targetBreakerSystemID */
  if (this->targetBreakerSystemID != NULL) {
    delete[] this->targetBreakerSystemID;
    this->targetBreakerSystemID = NULL;
  }
  /* clear struct: this->recloserControl */
  this->recloserControl.clear( );
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlProfile copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserControlProfile::copy( const RecloserControlProfile * copy_from )
{

  RecloserControlProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::copy( copy_from );
  /* copy targetBreakerSystemID */
  if (copy_from->targetBreakerSystemID) {
    copy_to->targetBreakerSystemID = new char[strlen(copy_from->targetBreakerSystemID) + 1];
    strcpy( copy_to->targetBreakerSystemID, copy_from->targetBreakerSystemID );
  }

  /* copy recloserControl */
  copy_to->recloserControl.copy( &copy_from->recloserControl );

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlProfile::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetBreakerSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetBreakerSystemID==NULL)?1:(unsigned int)((strlen(targetBreakerSystemID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetBreakerSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetBreakerSystemID==NULL)?1:(unsigned int)((strlen(targetBreakerSystemID)+1)*1);
      offset = recloserControl.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlProfile::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
          offset = recloserControl.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
          offset = recloserControl.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::ControlIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
          offset = recloserControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
          offset = recloserControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserControlProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::ControlIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserControlProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserControlProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlIED::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("targetBreakerSystemID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::reclosermodule::RecloserControlProfile,targetBreakerSystemID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::reclosermodule::RecloserControlProfile,targetBreakerSystemID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("recloserControl", fieldname, 15) == 0) && 
       (fieldname[15] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserControlProfile,recloserControl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::reclosermodule::RecloserControl::get_field_def(&fieldname[16], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventProfile Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEventProfile::RecloserEventProfile()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventProfile Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEventProfile::RecloserEventProfile( const RecloserEventProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventProfile Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserEventProfile::~RecloserEventProfile()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventProfile Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserEventProfile& openfmb::reclosermodule::RecloserEventProfile::operator=( const openfmb::reclosermodule::RecloserEventProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserEventProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserEventProfile init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEventProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserEventProfile clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEventProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  /* clear struct: this->recloserEvent */
  this->recloserEvent.clear( );
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventProfile copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserEventProfile::copy( const RecloserEventProfile * copy_from )
{

  RecloserEventProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy recloserEvent */
  copy_to->recloserEvent.copy( &copy_from->recloserEvent );

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventProfile::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = recloserEvent.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventProfile::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = recloserEvent.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = recloserEvent.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = recloserEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = recloserEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserEventProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserEventProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserEventProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("recloserEvent", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserEventProfile,recloserEvent);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::reclosermodule::RecloserEvent::get_field_def(&fieldname[14], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingValue Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingValue::RecloserReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingValue Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingValue::RecloserReadingValue( const RecloserReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingValue Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingValue::~RecloserReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingValue Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingValue& openfmb::reclosermodule::RecloserReadingValue::operator=( const openfmb::reclosermodule::RecloserReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserReadingValue init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingValue clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingValue copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserReadingValue::copy( const RecloserReadingValue * copy_from )
{

  RecloserReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::reclosermodule::RecloserReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::reclosermodule::RecloserReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusProfile Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusProfile::RecloserStatusProfile()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusProfile Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusProfile::RecloserStatusProfile( const RecloserStatusProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusProfile Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusProfile::~RecloserStatusProfile()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusProfile Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserStatusProfile& openfmb::reclosermodule::RecloserStatusProfile::operator=( const openfmb::reclosermodule::RecloserStatusProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserStatusProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserStatusProfile init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatusProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
  this->recloserStatus = NULL;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserStatusProfile clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatusProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  if (this->recloserStatus != NULL) {
    /* clear struct: (*this->recloserStatus) */
    (*this->recloserStatus).clear( );
    delete this->recloserStatus;
    this->recloserStatus = NULL;
  }
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusProfile copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserStatusProfile::copy( const RecloserStatusProfile * copy_from )
{

  RecloserStatusProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy recloserStatus */
  if (copy_from->recloserStatus) {
    copy_to->recloserStatus = (struct openfmb::reclosermodule::RecloserStatus*)new struct openfmb::reclosermodule::RecloserStatus();
    (*copy_to->recloserStatus).copy( &(*copy_from->recloserStatus) );
  }
  else
    copy_to->recloserStatus = NULL;

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusProfile::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (recloserStatus != NULL) {
          offset = (*recloserStatus).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusProfile::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (recloserStatus != NULL) {
              offset = (*recloserStatus).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (recloserStatus != NULL) {
              offset = (*recloserStatus).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                recloserStatus = (struct openfmb::reclosermodule::RecloserStatus*)new struct openfmb::reclosermodule::RecloserStatus();
                offset = (*recloserStatus).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                recloserStatus = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                recloserStatus = (struct openfmb::reclosermodule::RecloserStatus*)new struct openfmb::reclosermodule::RecloserStatus();
                offset = (*recloserStatus).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                recloserStatus = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserStatusProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserStatusProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserStatusProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("recloserStatus", fieldname, 14) == 0) && 
       (fieldname[14] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::reclosermodule::RecloserStatusProfile,recloserStatus);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::reclosermodule::RecloserStatus::get_field_def(&fieldname[15], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingValue Default Constructor
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingValue::RegulatorReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingValue Copy Constructor
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingValue::RegulatorReadingValue( const RegulatorReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingValue Destructor
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingValue::~RegulatorReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingValue Assignment Operator
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingValue& openfmb::regulatormodule::RegulatorReadingValue::operator=( const openfmb::regulatormodule::RegulatorReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::regulatormodule::::RegulatorReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingValue init()
 ******************************************************************/
void openfmb::regulatormodule::RegulatorReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingValue clear()
 ******************************************************************/
void openfmb::regulatormodule::RegulatorReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingValue copy()
 ******************************************************************/
void openfmb::regulatormodule::RegulatorReadingValue::copy( const RegulatorReadingValue * copy_from )
{

  RegulatorReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::regulatormodule::RegulatorReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::regulatormodule::RegulatorReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::regulatormodule::RegulatorReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::regulatormodule::RegulatorReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::regulatormodule::RegulatorReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingValue Default Constructor
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingValue::ResourceReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingValue Copy Constructor
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingValue::ResourceReadingValue( const ResourceReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingValue Destructor
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingValue::~ResourceReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingValue Assignment Operator
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingValue& openfmb::resourcemodule::ResourceReadingValue::operator=( const openfmb::resourcemodule::ResourceReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::resourcemodule::::ResourceReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::resourcemodule::ResourceReadingValue init()
 ******************************************************************/
void openfmb::resourcemodule::ResourceReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingValue clear()
 ******************************************************************/
void openfmb::resourcemodule::ResourceReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingValue copy()
 ******************************************************************/
void openfmb::resourcemodule::ResourceReadingValue::copy( const ResourceReadingValue * copy_from )
{

  ResourceReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::resourcemodule::ResourceReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::resourcemodule::ResourceReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::resourcemodule::ResourceReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::resourcemodule::ResourceReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::resourcemodule::ResourceReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarEvent Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarEvent::SolarEvent()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarEvent Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarEvent::SolarEvent( const SolarEvent & other )
  : EventValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarEvent Destructor
 ******************************************************************/
openfmb::solarmodule::SolarEvent::~SolarEvent()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarEvent Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarEvent& openfmb::solarmodule::SolarEvent::operator=( const openfmb::solarmodule::SolarEvent & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarEvent Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarEvent init()
 ******************************************************************/
void openfmb::solarmodule::SolarEvent::init()
{
  /* init PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::init();
  this->solarEventZGEN = NULL;
}

/******************************************************************
 * openfmb::solarmodule::SolarEvent clear()
 ******************************************************************/
void openfmb::solarmodule::SolarEvent::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::clear();
  if (this->solarEventZGEN != NULL) {
    /* clear struct: (*this->solarEventZGEN) */
    (*this->solarEventZGEN).clear( );
    delete this->solarEventZGEN;
    this->solarEventZGEN = NULL;
  }
}

/******************************************************************
 *  openfmb::solarmodule::SolarEvent copy()
 ******************************************************************/
void openfmb::solarmodule::SolarEvent::copy( const SolarEvent * copy_from )
{

  SolarEvent * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventValue */
  openfmb::commonmodule::EventValue::copy( copy_from );
  /* copy solarEventZGEN */
  if (copy_from->solarEventZGEN) {
    copy_to->solarEventZGEN = (struct openfmb::solarmodule::SolarEventZGEN*)new struct openfmb::solarmodule::SolarEventZGEN();
    (*copy_to->solarEventZGEN).copy( &(*copy_from->solarEventZGEN) );
  }
  else
    copy_to->solarEventZGEN = NULL;

}

/******************************************************************
 *  openfmb::solarmodule::SolarEvent::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarEvent::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (solarEventZGEN != NULL) {
          offset = (*solarEventZGEN).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEvent::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarEvent::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarEventZGEN != NULL) {
              offset = (*solarEventZGEN).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarEventZGEN != NULL) {
              offset = (*solarEventZGEN).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEvent::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarEvent::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEvent::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarEvent::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarEventZGEN = (struct openfmb::solarmodule::SolarEventZGEN*)new struct openfmb::solarmodule::SolarEventZGEN();
                offset = (*solarEventZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarEventZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarEventZGEN = (struct openfmb::solarmodule::SolarEventZGEN*)new struct openfmb::solarmodule::SolarEventZGEN();
                offset = (*solarEventZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarEventZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEvent::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarEvent::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEvent get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarEvent::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("solarEventZGEN", fieldname, 14) == 0) && 
       (fieldname[14] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarEvent,solarEventZGEN);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::solarmodule::SolarEventZGEN::get_field_def(&fieldname[15], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarEventProfile Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarEventProfile::SolarEventProfile()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarEventProfile Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarEventProfile::SolarEventProfile( const SolarEventProfile & other )
  : StatusIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarEventProfile Destructor
 ******************************************************************/
openfmb::solarmodule::SolarEventProfile::~SolarEventProfile()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarEventProfile Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarEventProfile& openfmb::solarmodule::SolarEventProfile::operator=( const openfmb::solarmodule::SolarEventProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarEventProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarEventProfile init()
 ******************************************************************/
void openfmb::solarmodule::SolarEventProfile::init()
{
  /* init PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::init();
  this->solarEvent = NULL;
}

/******************************************************************
 * openfmb::solarmodule::SolarEventProfile clear()
 ******************************************************************/
void openfmb::solarmodule::SolarEventProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::clear();
  if (this->solarEvent != NULL) {
    /* clear struct: (*this->solarEvent) */
    (*this->solarEvent).clear( );
    delete this->solarEvent;
    this->solarEvent = NULL;
  }
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventProfile copy()
 ******************************************************************/
void openfmb::solarmodule::SolarEventProfile::copy( const SolarEventProfile * copy_from )
{

  SolarEventProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::copy( copy_from );
  /* copy solarEvent */
  if (copy_from->solarEvent) {
    copy_to->solarEvent = (struct openfmb::solarmodule::SolarEvent*)new struct openfmb::solarmodule::SolarEvent();
    (*copy_to->solarEvent).copy( &(*copy_from->solarEvent) );
  }
  else
    copy_to->solarEvent = NULL;

}

/******************************************************************
 *  openfmb::solarmodule::SolarEventProfile::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarEventProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (solarEvent != NULL) {
          offset = (*solarEvent).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventProfile::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarEventProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarEvent != NULL) {
              offset = (*solarEvent).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarEvent != NULL) {
              offset = (*solarEvent).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarEventProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::StatusIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarEventProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarEvent = (struct openfmb::solarmodule::SolarEvent*)new struct openfmb::solarmodule::SolarEvent();
                offset = (*solarEvent).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarEvent = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarEvent = (struct openfmb::solarmodule::SolarEvent*)new struct openfmb::solarmodule::SolarEvent();
                offset = (*solarEvent).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarEvent = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarEventProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::StatusIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarEventProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarEventProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("solarEvent", fieldname, 10) == 0) && 
       (fieldname[10] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarEventProfile,solarEvent);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::solarmodule::SolarEvent::get_field_def(&fieldname[11], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingValue Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarReadingValue::SolarReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingValue Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarReadingValue::SolarReadingValue( const SolarReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingValue Destructor
 ******************************************************************/
openfmb::solarmodule::SolarReadingValue::~SolarReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingValue Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarReadingValue& openfmb::solarmodule::SolarReadingValue::operator=( const openfmb::solarmodule::SolarReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarReadingValue init()
 ******************************************************************/
void openfmb::solarmodule::SolarReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingValue clear()
 ******************************************************************/
void openfmb::solarmodule::SolarReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingValue copy()
 ******************************************************************/
void openfmb::solarmodule::SolarReadingValue::copy( const SolarReadingValue * copy_from )
{

  SolarReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::solarmodule::SolarReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::solarmodule::SolarReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarStatus Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarStatus::SolarStatus()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarStatus Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarStatus::SolarStatus( const SolarStatus & other )
  : StatusValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarStatus Destructor
 ******************************************************************/
openfmb::solarmodule::SolarStatus::~SolarStatus()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarStatus Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarStatus& openfmb::solarmodule::SolarStatus::operator=( const openfmb::solarmodule::SolarStatus & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarStatus Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarStatus init()
 ******************************************************************/
void openfmb::solarmodule::SolarStatus::init()
{
  /* init PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::init();
  this->solarStatusZGEN = NULL;
}

/******************************************************************
 * openfmb::solarmodule::SolarStatus clear()
 ******************************************************************/
void openfmb::solarmodule::SolarStatus::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::clear();
  if (this->solarStatusZGEN != NULL) {
    /* clear struct: (*this->solarStatusZGEN) */
    (*this->solarStatusZGEN).clear( );
    delete this->solarStatusZGEN;
    this->solarStatusZGEN = NULL;
  }
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatus copy()
 ******************************************************************/
void openfmb::solarmodule::SolarStatus::copy( const SolarStatus * copy_from )
{

  SolarStatus * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusValue */
  openfmb::commonmodule::StatusValue::copy( copy_from );
  /* copy solarStatusZGEN */
  if (copy_from->solarStatusZGEN) {
    copy_to->solarStatusZGEN = (struct openfmb::solarmodule::SolarStatusZGEN*)new struct openfmb::solarmodule::SolarStatusZGEN();
    (*copy_to->solarStatusZGEN).copy( &(*copy_from->solarStatusZGEN) );
  }
  else
    copy_to->solarStatusZGEN = NULL;

}

/******************************************************************
 *  openfmb::solarmodule::SolarStatus::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarStatus::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (solarStatusZGEN != NULL) {
          offset = (*solarStatusZGEN).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatus::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarStatus::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarStatusZGEN != NULL) {
              offset = (*solarStatusZGEN).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarStatusZGEN != NULL) {
              offset = (*solarStatusZGEN).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatus::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarStatus::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatus::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarStatus::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarStatusZGEN = (struct openfmb::solarmodule::SolarStatusZGEN*)new struct openfmb::solarmodule::SolarStatusZGEN();
                offset = (*solarStatusZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarStatusZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarStatusZGEN = (struct openfmb::solarmodule::SolarStatusZGEN*)new struct openfmb::solarmodule::SolarStatusZGEN();
                offset = (*solarStatusZGEN).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarStatusZGEN = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatus::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarStatus::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatus get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarStatus::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("solarStatusZGEN", fieldname, 15) == 0) && 
       (fieldname[15] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarStatus,solarStatusZGEN);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::solarmodule::SolarStatusZGEN::get_field_def(&fieldname[16], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusProfile Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarStatusProfile::SolarStatusProfile()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusProfile Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarStatusProfile::SolarStatusProfile( const SolarStatusProfile & other )
  : StatusIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusProfile Destructor
 ******************************************************************/
openfmb::solarmodule::SolarStatusProfile::~SolarStatusProfile()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusProfile Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarStatusProfile& openfmb::solarmodule::SolarStatusProfile::operator=( const openfmb::solarmodule::SolarStatusProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarStatusProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarStatusProfile init()
 ******************************************************************/
void openfmb::solarmodule::SolarStatusProfile::init()
{
  /* init PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::init();
  this->solarStatus = NULL;
}

/******************************************************************
 * openfmb::solarmodule::SolarStatusProfile clear()
 ******************************************************************/
void openfmb::solarmodule::SolarStatusProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::clear();
  if (this->solarStatus != NULL) {
    /* clear struct: (*this->solarStatus) */
    (*this->solarStatus).clear( );
    delete this->solarStatus;
    this->solarStatus = NULL;
  }
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusProfile copy()
 ******************************************************************/
void openfmb::solarmodule::SolarStatusProfile::copy( const SolarStatusProfile * copy_from )
{

  SolarStatusProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::StatusIED */
  openfmb::commonmodule::StatusIED::copy( copy_from );
  /* copy solarStatus */
  if (copy_from->solarStatus) {
    copy_to->solarStatus = (struct openfmb::solarmodule::SolarStatus*)new struct openfmb::solarmodule::SolarStatus();
    (*copy_to->solarStatus).copy( &(*copy_from->solarStatus) );
  }
  else
    copy_to->solarStatus = NULL;

}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusProfile::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (solarStatus != NULL) {
          offset = (*solarStatus).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusProfile::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::StatusIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarStatus != NULL) {
              offset = (*solarStatus).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarStatus != NULL) {
              offset = (*solarStatus).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::StatusIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::StatusIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarStatus = (struct openfmb::solarmodule::SolarStatus*)new struct openfmb::solarmodule::SolarStatus();
                offset = (*solarStatus).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarStatus = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarStatus = (struct openfmb::solarmodule::SolarStatus*)new struct openfmb::solarmodule::SolarStatus();
                offset = (*solarStatus).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarStatus = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarStatusProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::StatusIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarStatusProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarStatusProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::StatusIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("solarStatus", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarStatusProfile,solarStatus);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::solarmodule::SolarStatus::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlProfile Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchControlProfile::SwitchControlProfile()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlProfile Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchControlProfile::SwitchControlProfile( const SwitchControlProfile & other )
  : ControlIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlProfile Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchControlProfile::~SwitchControlProfile()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlProfile Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchControlProfile& openfmb::switchmodule::SwitchControlProfile::operator=( const openfmb::switchmodule::SwitchControlProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchControlProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchControlProfile init()
 ******************************************************************/
void openfmb::switchmodule::SwitchControlProfile::init()
{
  /* init PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::init();
  this->targetSwitchSystemID = NULL;
  /* init struct: this->switchControl */
  this->switchControl.init( );
}

/******************************************************************
 * openfmb::switchmodule::SwitchControlProfile clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchControlProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::clear();
  /* clear string: this->targetSwitchSystemID */
  if (this->targetSwitchSystemID != NULL) {
    delete[] this->targetSwitchSystemID;
    this->targetSwitchSystemID = NULL;
  }
  /* clear struct: this->switchControl */
  this->switchControl.clear( );
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlProfile copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchControlProfile::copy( const SwitchControlProfile * copy_from )
{

  SwitchControlProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::copy( copy_from );
  /* copy targetSwitchSystemID */
  if (copy_from->targetSwitchSystemID) {
    copy_to->targetSwitchSystemID = new char[strlen(copy_from->targetSwitchSystemID) + 1];
    strcpy( copy_to->targetSwitchSystemID, copy_from->targetSwitchSystemID );
  }

  /* copy switchControl */
  copy_to->switchControl.copy( &copy_from->switchControl );

}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlProfile::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetSwitchSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetSwitchSystemID==NULL)?1:(unsigned int)((strlen(targetSwitchSystemID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetSwitchSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetSwitchSystemID==NULL)?1:(unsigned int)((strlen(targetSwitchSystemID)+1)*1);
      offset = switchControl.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlProfile::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( targetSwitchSystemID ) len += (int)strlen( targetSwitchSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSwitchSystemID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( targetSwitchSystemID ) len += (int)strlen( targetSwitchSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSwitchSystemID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( targetSwitchSystemID ) len += (int)strlen( targetSwitchSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSwitchSystemID, len);
          }
          offset = switchControl.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          { int len = 1;
          if ( targetSwitchSystemID ) len += (int)strlen( targetSwitchSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSwitchSystemID, len);
          }
          offset = switchControl.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::ControlIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( targetSwitchSystemID ) len += (int)strlen( targetSwitchSystemID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetSwitchSystemID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( targetSwitchSystemID ) len += (int)strlen( targetSwitchSystemID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetSwitchSystemID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetSwitchSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSwitchSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetSwitchSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSwitchSystemID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetSwitchSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSwitchSystemID, len, stream_len);
          }
          offset = switchControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetSwitchSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSwitchSystemID, len, stream_len);
          }
          offset = switchControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchControlProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::ControlIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetSwitchSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSwitchSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetSwitchSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSwitchSystemID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchControlProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchControlProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlIED::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("targetSwitchSystemID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::switchmodule::SwitchControlProfile,targetSwitchSystemID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::switchmodule::SwitchControlProfile,targetSwitchSystemID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("switchControl", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchControlProfile,switchControl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::switchmodule::SwitchControl::get_field_def(&fieldname[14], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventProfile Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchEventProfile::SwitchEventProfile()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventProfile Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchEventProfile::SwitchEventProfile( const SwitchEventProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventProfile Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchEventProfile::~SwitchEventProfile()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventProfile Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchEventProfile& openfmb::switchmodule::SwitchEventProfile::operator=( const openfmb::switchmodule::SwitchEventProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchEventProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchEventProfile init()
 ******************************************************************/
void openfmb::switchmodule::SwitchEventProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchEventProfile clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchEventProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  /* clear struct: this->switchEvent */
  this->switchEvent.clear( );
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventProfile copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchEventProfile::copy( const SwitchEventProfile * copy_from )
{

  SwitchEventProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy switchEvent */
  copy_to->switchEvent.copy( &copy_from->switchEvent );

}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventProfile::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = switchEvent.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventProfile::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = switchEvent.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = switchEvent.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = switchEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = switchEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchEventProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchEventProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchEventProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("switchEvent", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchEventProfile,switchEvent);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::switchmodule::SwitchEvent::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingValue Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchReadingValue::SwitchReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingValue Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchReadingValue::SwitchReadingValue( const SwitchReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingValue Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchReadingValue::~SwitchReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingValue Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchReadingValue& openfmb::switchmodule::SwitchReadingValue::operator=( const openfmb::switchmodule::SwitchReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchReadingValue init()
 ******************************************************************/
void openfmb::switchmodule::SwitchReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingValue clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingValue copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchReadingValue::copy( const SwitchReadingValue * copy_from )
{

  SwitchReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::switchmodule::SwitchReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::switchmodule::SwitchReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusProfile Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatusProfile::SwitchStatusProfile()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusProfile Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatusProfile::SwitchStatusProfile( const SwitchStatusProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusProfile Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchStatusProfile::~SwitchStatusProfile()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusProfile Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchStatusProfile& openfmb::switchmodule::SwitchStatusProfile::operator=( const openfmb::switchmodule::SwitchStatusProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchStatusProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchStatusProfile init()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatusProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchStatusProfile clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatusProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  /* clear struct: this->switchStatus */
  this->switchStatus.clear( );
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusProfile copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchStatusProfile::copy( const SwitchStatusProfile * copy_from )
{

  SwitchStatusProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy switchStatus */
  copy_to->switchStatus.copy( &copy_from->switchStatus );

}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusProfile::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = switchStatus.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusProfile::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = switchStatus.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = switchStatus.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = switchStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = switchStatus.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchStatusProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchStatusProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchStatusProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("switchStatus", fieldname, 12) == 0) && 
       (fieldname[12] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::switchmodule::SwitchStatusProfile,switchStatus);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::switchmodule::SwitchStatus::get_field_def(&fieldname[13], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlProfile Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerControlProfile::BreakerControlProfile()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlProfile Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerControlProfile::BreakerControlProfile( const BreakerControlProfile & other )
  : ControlIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlProfile Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerControlProfile::~BreakerControlProfile()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlProfile Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerControlProfile& openfmb::breakermodule::BreakerControlProfile::operator=( const openfmb::breakermodule::BreakerControlProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerControlProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerControlProfile init()
 ******************************************************************/
void openfmb::breakermodule::BreakerControlProfile::init()
{
  /* init PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::init();
  this->targetBreakerSystemID = NULL;
  /* init struct: this->breakerControl */
  this->breakerControl.init( );
}

/******************************************************************
 * openfmb::breakermodule::BreakerControlProfile clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerControlProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::clear();
  /* clear string: this->targetBreakerSystemID */
  if (this->targetBreakerSystemID != NULL) {
    delete[] this->targetBreakerSystemID;
    this->targetBreakerSystemID = NULL;
  }
  /* clear struct: this->breakerControl */
  this->breakerControl.clear( );
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlProfile copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerControlProfile::copy( const BreakerControlProfile * copy_from )
{

  BreakerControlProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::copy( copy_from );
  /* copy targetBreakerSystemID */
  if (copy_from->targetBreakerSystemID) {
    copy_to->targetBreakerSystemID = new char[strlen(copy_from->targetBreakerSystemID) + 1];
    strcpy( copy_to->targetBreakerSystemID, copy_from->targetBreakerSystemID );
  }

  /* copy breakerControl */
  copy_to->breakerControl.copy( &copy_from->breakerControl );

}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlProfile::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetBreakerSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetBreakerSystemID==NULL)?1:(unsigned int)((strlen(targetBreakerSystemID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetBreakerSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetBreakerSystemID==NULL)?1:(unsigned int)((strlen(targetBreakerSystemID)+1)*1);
      offset = breakerControl.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlProfile::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
          offset = breakerControl.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          { int len = 1;
          if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
          }
          offset = breakerControl.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::ControlIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( targetBreakerSystemID ) len += (int)strlen( targetBreakerSystemID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetBreakerSystemID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
          offset = breakerControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
          offset = breakerControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerControlProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::ControlIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetBreakerSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetBreakerSystemID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerControlProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerControlProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlIED::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("targetBreakerSystemID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::breakermodule::BreakerControlProfile,targetBreakerSystemID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::breakermodule::BreakerControlProfile,targetBreakerSystemID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("breakerControl", fieldname, 14) == 0) && 
       (fieldname[14] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerControlProfile,breakerControl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::breakermodule::BreakerControl::get_field_def(&fieldname[15], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventProfile Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerEventProfile::BreakerEventProfile()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventProfile Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerEventProfile::BreakerEventProfile( const BreakerEventProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventProfile Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerEventProfile::~BreakerEventProfile()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventProfile Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerEventProfile& openfmb::breakermodule::BreakerEventProfile::operator=( const openfmb::breakermodule::BreakerEventProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerEventProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerEventProfile init()
 ******************************************************************/
void openfmb::breakermodule::BreakerEventProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerEventProfile clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerEventProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  /* clear struct: this->breakerEvent */
  this->breakerEvent.clear( );
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventProfile copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerEventProfile::copy( const BreakerEventProfile * copy_from )
{

  BreakerEventProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy breakerEvent */
  copy_to->breakerEvent.copy( &copy_from->breakerEvent );

}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventProfile::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = breakerEvent.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventProfile::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = breakerEvent.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = breakerEvent.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = breakerEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = breakerEvent.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerEventProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerEventProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerEventProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("breakerEvent", fieldname, 12) == 0) && 
       (fieldname[12] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerEventProfile,breakerEvent);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::breakermodule::BreakerEvent::get_field_def(&fieldname[13], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingValue Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerReadingValue::BreakerReadingValue()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingValue Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerReadingValue::BreakerReadingValue( const BreakerReadingValue & other )
  : MeasurementValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingValue Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerReadingValue::~BreakerReadingValue()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingValue Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerReadingValue& openfmb::breakermodule::BreakerReadingValue::operator=( const openfmb::breakermodule::BreakerReadingValue & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerReadingValue Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerReadingValue init()
 ******************************************************************/
void openfmb::breakermodule::BreakerReadingValue::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::init();
  this->terminalID = NULL;
  this->readingMMXU = NULL;
  this->readingMMTR = NULL;
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingValue clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerReadingValue::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::clear();
  /* clear string: this->terminalID */
  if (this->terminalID != NULL) {
    delete[] this->terminalID;
    this->terminalID = NULL;
  }
  if (this->readingMMXU != NULL) {
    /* clear struct: (*this->readingMMXU) */
    (*this->readingMMXU).clear( );
    delete this->readingMMXU;
    this->readingMMXU = NULL;
  }
  if (this->readingMMTR != NULL) {
    /* clear struct: (*this->readingMMTR) */
    (*this->readingMMTR).clear( );
    delete this->readingMMTR;
    this->readingMMTR = NULL;
  }
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingValue copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerReadingValue::copy( const BreakerReadingValue * copy_from )
{

  BreakerReadingValue * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementValue */
  openfmb::commonmodule::MeasurementValue::copy( copy_from );
  /* copy terminalID */
  if (copy_from->terminalID) {
    if (copy_from->terminalID) {
      copy_to->terminalID = new char[strlen(copy_from->terminalID) + 1];
      strcpy( copy_to->terminalID, copy_from->terminalID );
    }
  }
  else
    copy_to->terminalID = NULL;

  /* copy readingMMXU */
  if (copy_from->readingMMXU) {
    copy_to->readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
    (*copy_to->readingMMXU).copy( &(*copy_from->readingMMXU) );
  }
  else
    copy_to->readingMMXU = NULL;

  /* copy readingMMTR */
  if (copy_from->readingMMTR) {
    copy_to->readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
    (*copy_to->readingMMTR).copy( &(*copy_from->readingMMTR) );
  }
  else
    copy_to->readingMMTR = NULL;

}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingValue::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingValue::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (terminalID != NULL) {
          /* terminalID */
          offset = (offset+3) & 0xfffffffc;/* align 4 */
          offset += 4;
          offset += (terminalID==NULL)?1:(unsigned int)((strlen(terminalID)+1)*1);
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMXU != NULL) {
          offset = (*readingMMXU).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (readingMMTR != NULL) {
          offset = (*readingMMTR).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingValue::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingValue::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (terminalID != NULL) {
              { int len = 1;
              if ( terminalID ) len += (int)strlen( terminalID );
              DDS_MARSH_PUT_LONG(buf, offset, len);
              DDS_MARSH_PUT_STR(buf, offset, terminalID, len);
              }
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMXU != NULL) {
              offset = (*readingMMXU).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (readingMMTR != NULL) {
              offset = (*readingMMTR).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingValue::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingValue::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingValue::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingValue::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                { int len;
                DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
                terminalID = new char[len];
                DDS_MARSH_GET_STR(buf, offset, terminalID, len, stream_len);
                }
              }
              else {
                terminalID = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMXU = (struct openfmb::commonmodule::ReadingMMXU*)new struct openfmb::commonmodule::ReadingMMXU();
                offset = (*readingMMXU).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMXU = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                readingMMTR = (struct openfmb::commonmodule::ReadingMMTR*)new struct openfmb::commonmodule::ReadingMMTR();
                offset = (*readingMMTR).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                readingMMTR = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingValue::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingValue::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingValue get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerReadingValue::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementValue::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("terminalID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::breakermodule::BreakerReadingValue,terminalID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::breakermodule::BreakerReadingValue,terminalID);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("readingMMXU", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerReadingValue,readingMMXU);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMXU::get_field_def(&fieldname[12], field_def);
  }
  if ( (strncmp("readingMMTR", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerReadingValue,readingMMTR);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ReadingMMTR::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusProfile Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatusProfile::BreakerStatusProfile()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusProfile Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatusProfile::BreakerStatusProfile( const BreakerStatusProfile & other )
  : EventIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusProfile Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerStatusProfile::~BreakerStatusProfile()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusProfile Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerStatusProfile& openfmb::breakermodule::BreakerStatusProfile::operator=( const openfmb::breakermodule::BreakerStatusProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerStatusProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerStatusProfile init()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatusProfile::init()
{
  /* init PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::init();
  this->breakerStatus = NULL;
}

/******************************************************************
 * openfmb::breakermodule::BreakerStatusProfile clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatusProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::clear();
  if (this->breakerStatus != NULL) {
    /* clear struct: (*this->breakerStatus) */
    (*this->breakerStatus).clear( );
    delete this->breakerStatus;
    this->breakerStatus = NULL;
  }
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusProfile copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerStatusProfile::copy( const BreakerStatusProfile * copy_from )
{

  BreakerStatusProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::EventIED */
  openfmb::commonmodule::EventIED::copy( copy_from );
  /* copy breakerStatus */
  if (copy_from->breakerStatus) {
    copy_to->breakerStatus = (struct openfmb::breakermodule::BreakerStatus*)new struct openfmb::breakermodule::BreakerStatus();
    (*copy_to->breakerStatus).copy( &(*copy_from->breakerStatus) );
  }
  else
    copy_to->breakerStatus = NULL;

}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusProfile::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (breakerStatus != NULL) {
          offset = (*breakerStatus).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusProfile::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::EventIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (breakerStatus != NULL) {
              offset = (*breakerStatus).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (breakerStatus != NULL) {
              offset = (*breakerStatus).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::EventIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::EventIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                breakerStatus = (struct openfmb::breakermodule::BreakerStatus*)new struct openfmb::breakermodule::BreakerStatus();
                offset = (*breakerStatus).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                breakerStatus = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                breakerStatus = (struct openfmb::breakermodule::BreakerStatus*)new struct openfmb::breakermodule::BreakerStatus();
                offset = (*breakerStatus).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                breakerStatus = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerStatusProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::EventIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerStatusProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerStatusProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::EventIED::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("breakerStatus", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::breakermodule::BreakerStatusProfile,breakerStatus);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::breakermodule::BreakerStatus::get_field_def(&fieldname[14], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::ControlFSCC Default Constructor
 ******************************************************************/
openfmb::commonmodule::ControlFSCC::ControlFSCC()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::ControlFSCC Copy Constructor
 ******************************************************************/
openfmb::commonmodule::ControlFSCC::ControlFSCC( const ControlFSCC & other )
  : LogicalNodeForControl()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::ControlFSCC Destructor
 ******************************************************************/
openfmb::commonmodule::ControlFSCC::~ControlFSCC()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::ControlFSCC Assignment Operator
 ******************************************************************/
openfmb::commonmodule::ControlFSCC& openfmb::commonmodule::ControlFSCC::operator=( const openfmb::commonmodule::ControlFSCC & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::ControlFSCC Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::ControlFSCC init()
 ******************************************************************/
void openfmb::commonmodule::ControlFSCC::init()
{
  /* init PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::init();
  this->WRtg = NULL;
  this->VARtg = NULL;
  this->controlScheduleFSCH = NULL;
}

/******************************************************************
 * openfmb::commonmodule::ControlFSCC clear()
 ******************************************************************/
void openfmb::commonmodule::ControlFSCC::clear()
{
  /* clear PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::clear();
  if (this->WRtg != NULL) {
    /* clear struct: (*this->WRtg) */
    (*this->WRtg).clear( );
    delete this->WRtg;
    this->WRtg = NULL;
  }
  if (this->VARtg != NULL) {
    /* clear struct: (*this->VARtg) */
    (*this->VARtg).clear( );
    delete this->VARtg;
    this->VARtg = NULL;
  }
  if (this->controlScheduleFSCH != NULL) {
    /* clear struct: (*this->controlScheduleFSCH) */
    (*this->controlScheduleFSCH).clear( );
    delete this->controlScheduleFSCH;
    this->controlScheduleFSCH = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::ControlFSCC copy()
 ******************************************************************/
void openfmb::commonmodule::ControlFSCC::copy( const ControlFSCC * copy_from )
{

  ControlFSCC * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::LogicalNodeForControl */
  openfmb::commonmodule::LogicalNodeForControl::copy( copy_from );
  /* copy WRtg */
  if (copy_from->WRtg) {
    copy_to->WRtg = (struct openfmb::commonmodule::ASG*)new struct openfmb::commonmodule::ASG();
    (*copy_to->WRtg).copy( &(*copy_from->WRtg) );
  }
  else
    copy_to->WRtg = NULL;

  /* copy VARtg */
  if (copy_from->VARtg) {
    copy_to->VARtg = (struct openfmb::commonmodule::ASG*)new struct openfmb::commonmodule::ASG();
    (*copy_to->VARtg).copy( &(*copy_from->VARtg) );
  }
  else
    copy_to->VARtg = NULL;

  /* copy controlScheduleFSCH */
  if (copy_from->controlScheduleFSCH) {
    copy_to->controlScheduleFSCH = (struct openfmb::commonmodule::ControlScheduleFSCH*)new struct openfmb::commonmodule::ControlScheduleFSCH();
    (*copy_to->controlScheduleFSCH).copy( &(*copy_from->controlScheduleFSCH) );
  }
  else
    copy_to->controlScheduleFSCH = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::ControlFSCC::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::ControlFSCC::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (WRtg != NULL) {
          offset = (*WRtg).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (VARtg != NULL) {
          offset = (*VARtg).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (controlScheduleFSCH != NULL) {
          offset = (*controlScheduleFSCH).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlFSCC::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlFSCC::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::LogicalNodeForControl::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (WRtg != NULL) {
              offset = (*WRtg).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (VARtg != NULL) {
              offset = (*VARtg).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (controlScheduleFSCH != NULL) {
              offset = (*controlScheduleFSCH).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (WRtg != NULL) {
              offset = (*WRtg).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 6;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (VARtg != NULL) {
              offset = (*VARtg).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 7;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (controlScheduleFSCH != NULL) {
              offset = (*controlScheduleFSCH).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlFSCC::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlFSCC::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlFSCC::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::ControlFSCC::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::LogicalNodeForControl::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                WRtg = (struct openfmb::commonmodule::ASG*)new struct openfmb::commonmodule::ASG();
                offset = (*WRtg).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                WRtg = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                VARtg = (struct openfmb::commonmodule::ASG*)new struct openfmb::commonmodule::ASG();
                offset = (*VARtg).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                VARtg = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                controlScheduleFSCH = (struct openfmb::commonmodule::ControlScheduleFSCH*)new struct openfmb::commonmodule::ControlScheduleFSCH();
                offset = (*controlScheduleFSCH).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                controlScheduleFSCH = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                WRtg = (struct openfmb::commonmodule::ASG*)new struct openfmb::commonmodule::ASG();
                offset = (*WRtg).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                WRtg = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 6) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                VARtg = (struct openfmb::commonmodule::ASG*)new struct openfmb::commonmodule::ASG();
                offset = (*VARtg).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                VARtg = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 7) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                controlScheduleFSCH = (struct openfmb::commonmodule::ControlScheduleFSCH*)new struct openfmb::commonmodule::ControlScheduleFSCH();
                offset = (*controlScheduleFSCH).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                controlScheduleFSCH = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlFSCC::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::ControlFSCC::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::ControlFSCC get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::ControlFSCC::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::LogicalNodeForControl::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("WRtg", fieldname, 4) == 0) && 
       (fieldname[4] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ControlFSCC,WRtg);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ASG::get_field_def(&fieldname[5], field_def);
  }
  if ( (strncmp("VARtg", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ControlFSCC,VARtg);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ASG::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("controlScheduleFSCH", fieldname, 19) == 0) && 
       (fieldname[19] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::ControlFSCC,controlScheduleFSCH);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ControlScheduleFSCH::get_field_def(&fieldname[20], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::commonmodule::GenerationControlFSCC Default Constructor
 ******************************************************************/
openfmb::commonmodule::GenerationControlFSCC::GenerationControlFSCC()
{
  init();
}

/******************************************************************
 * openfmb::commonmodule::GenerationControlFSCC Copy Constructor
 ******************************************************************/
openfmb::commonmodule::GenerationControlFSCC::GenerationControlFSCC( const GenerationControlFSCC & other )
  : ControlFSCC()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::commonmodule::GenerationControlFSCC Destructor
 ******************************************************************/
openfmb::commonmodule::GenerationControlFSCC::~GenerationControlFSCC()
{
  clear();
}

/******************************************************************
 * openfmb::commonmodule::GenerationControlFSCC Assignment Operator
 ******************************************************************/
openfmb::commonmodule::GenerationControlFSCC& openfmb::commonmodule::GenerationControlFSCC::operator=( const openfmb::commonmodule::GenerationControlFSCC & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::commonmodule::::GenerationControlFSCC Ops
 *****************************************************************/


/******************************************************************
 * openfmb::commonmodule::GenerationControlFSCC init()
 ******************************************************************/
void openfmb::commonmodule::GenerationControlFSCC::init()
{
  /* init PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::init();
  this->GnCtl = NULL;
}

/******************************************************************
 * openfmb::commonmodule::GenerationControlFSCC clear()
 ******************************************************************/
void openfmb::commonmodule::GenerationControlFSCC::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::clear();
  if (this->GnCtl != NULL) {
    /* clear struct: (*this->GnCtl) */
    (*this->GnCtl).clear( );
    delete this->GnCtl;
    this->GnCtl = NULL;
  }
}

/******************************************************************
 *  openfmb::commonmodule::GenerationControlFSCC copy()
 ******************************************************************/
void openfmb::commonmodule::GenerationControlFSCC::copy( const GenerationControlFSCC * copy_from )
{

  GenerationControlFSCC * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::copy( copy_from );
  /* copy GnCtl */
  if (copy_from->GnCtl) {
    copy_to->GnCtl = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
    (*copy_to->GnCtl).copy( &(*copy_from->GnCtl) );
  }
  else
    copy_to->GnCtl = NULL;

}

/******************************************************************
 *  openfmb::commonmodule::GenerationControlFSCC::get_marshal_size()
 ******************************************************************/
int openfmb::commonmodule::GenerationControlFSCC::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (GnCtl != NULL) {
          offset = (*GnCtl).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationControlFSCC::marshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::GenerationControlFSCC::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlFSCC::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnCtl != NULL) {
              offset = (*GnCtl).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 8;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (GnCtl != NULL) {
              offset = (*GnCtl).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationControlFSCC::marshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::GenerationControlFSCC::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationControlFSCC::unmarshal_cdr()
 ******************************************************************/
int openfmb::commonmodule::GenerationControlFSCC::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnCtl = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*GnCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 8) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                GnCtl = (struct openfmb::commonmodule::ControlDPC*)new struct openfmb::commonmodule::ControlDPC();
                offset = (*GnCtl).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                GnCtl = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationControlFSCC::unmarshal_key_hash()
 ******************************************************************/
int openfmb::commonmodule::GenerationControlFSCC::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::commonmodule::GenerationControlFSCC get_field_def()
 ******************************************************************/
unsigned char
openfmb::commonmodule::GenerationControlFSCC::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlFSCC::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("GnCtl", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::commonmodule::GenerationControlFSCC,GnCtl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::ControlDPC::get_field_def(&fieldname[6], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::EssControlFSCC Default Constructor
 ******************************************************************/
openfmb::essmodule::EssControlFSCC::EssControlFSCC()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::EssControlFSCC Copy Constructor
 ******************************************************************/
openfmb::essmodule::EssControlFSCC::EssControlFSCC( const EssControlFSCC & other )
  : ControlFSCC()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::EssControlFSCC Destructor
 ******************************************************************/
openfmb::essmodule::EssControlFSCC::~EssControlFSCC()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::EssControlFSCC Assignment Operator
 ******************************************************************/
openfmb::essmodule::EssControlFSCC& openfmb::essmodule::EssControlFSCC::operator=( const openfmb::essmodule::EssControlFSCC & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::EssControlFSCC Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::EssControlFSCC init()
 ******************************************************************/
void openfmb::essmodule::EssControlFSCC::init()
{
  /* init PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::init();
  /* init struct: this->ESSControlMod */
  this->ESSControlMod.init( );
}

/******************************************************************
 * openfmb::essmodule::EssControlFSCC clear()
 ******************************************************************/
void openfmb::essmodule::EssControlFSCC::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::clear();
  /* clear struct: this->ESSControlMod */
  this->ESSControlMod.clear( );
}

/******************************************************************
 *  openfmb::essmodule::EssControlFSCC copy()
 ******************************************************************/
void openfmb::essmodule::EssControlFSCC::copy( const EssControlFSCC * copy_from )
{

  EssControlFSCC * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::copy( copy_from );
  /* copy ESSControlMod */
  copy_to->ESSControlMod.copy( &copy_from->ESSControlMod );

}

/******************************************************************
 *  openfmb::essmodule::EssControlFSCC::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::EssControlFSCC::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
      offset = ESSControlMod.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssControlFSCC::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::EssControlFSCC::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlFSCC::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = ESSControlMod.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = ESSControlMod.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssControlFSCC::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::EssControlFSCC::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssControlFSCC::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::EssControlFSCC::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = ESSControlMod.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = ESSControlMod.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssControlFSCC::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::EssControlFSCC::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::EssControlFSCC get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::EssControlFSCC::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlFSCC::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("ESSControlMod", fieldname, 13) == 0) && 
       (fieldname[13] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::EssControlFSCC,ESSControlMod);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::essmodule::ENC_ESSControlKind::get_field_def(&fieldname[14], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSReadingProfile Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSReadingProfile::ESSReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSReadingProfile Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSReadingProfile::ESSReadingProfile( const ESSReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSReadingProfile Destructor
 ******************************************************************/
openfmb::essmodule::ESSReadingProfile::~ESSReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSReadingProfile Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSReadingProfile& openfmb::essmodule::ESSReadingProfile::operator=( const openfmb::essmodule::ESSReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSReadingProfile init()
 ******************************************************************/
void openfmb::essmodule::ESSReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::essmodule::ESSReadingProfile clear()
 ******************************************************************/
void openfmb::essmodule::ESSReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->essReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->essReadingValue.size(); i_0++)
      {
        /* clear struct: this->essReadingValue[i_0] */
        this->essReadingValue[i_0].clear( );
      }
    this->essReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingProfile copy()
 ******************************************************************/
void openfmb::essmodule::ESSReadingProfile::copy( const ESSReadingProfile * copy_from )
{

  ESSReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy essReadingValue */
  copy_to->essReadingValue.resize(copy_from->essReadingValue.size());
  if ( copy_from->essReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->essReadingValue.size(); i_1++)
        {
          copy_to->essReadingValue[i_1].copy( &copy_from->essReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::essmodule::ESSReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* essReadingValue*/
      /* essReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < essReadingValue.size(); ii1++ ) {
           offset = essReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* essReadingValue */
          {
            unsigned int sl = (unsigned int)essReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < essReadingValue.size(); i1++)
            {
              offset = essReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* essReadingValue */
        }
      else
        {
          /* essReadingValue */
          {
            unsigned int sl = (unsigned int)essReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < essReadingValue.size(); i1++)
            {
              offset = essReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* essReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            essReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < essReadingValue.capacity(); ii1++)
            {
              offset = essReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* essReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            essReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < essReadingValue.capacity(); ii1++)
            {
              offset = essReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* essReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSControl Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSControl::ESSControl()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSControl Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSControl::ESSControl( const ESSControl & other )
  : ControlValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSControl Destructor
 ******************************************************************/
openfmb::essmodule::ESSControl::~ESSControl()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSControl Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSControl& openfmb::essmodule::ESSControl::operator=( const openfmb::essmodule::ESSControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSControl init()
 ******************************************************************/
void openfmb::essmodule::ESSControl::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::init();
  this->check = NULL;
}

/******************************************************************
 * openfmb::essmodule::ESSControl clear()
 ******************************************************************/
void openfmb::essmodule::ESSControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::clear();
  if (this->check != NULL) {
    /* clear struct: (*this->check) */
    (*this->check).clear( );
    delete this->check;
    this->check = NULL;
  }
  /* clear struct: this->essControlFSCC */
  this->essControlFSCC.clear( );
}

/******************************************************************
 *  openfmb::essmodule::ESSControl copy()
 ******************************************************************/
void openfmb::essmodule::ESSControl::copy( const ESSControl * copy_from )
{

  ESSControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::copy( copy_from );
  /* copy check */
  if (copy_from->check) {
    copy_to->check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
    (*copy_to->check).copy( &(*copy_from->check) );
  }
  else
    copy_to->check = NULL;

  /* copy essControlFSCC */
  copy_to->essControlFSCC.copy( &copy_from->essControlFSCC );

}

/******************************************************************
 *  openfmb::essmodule::ESSControl::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (check != NULL) {
          offset = (*check).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = essControlFSCC.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControl::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          offset = essControlFSCC.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          offset = essControlFSCC.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControl::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = essControlFSCC.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = essControlFSCC.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("check", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSControl,check);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CheckConditions::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("essControlFSCC", fieldname, 14) == 0) && 
       (fieldname[14] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSControl,essControlFSCC);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::essmodule::EssControlFSCC::get_field_def(&fieldname[15], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::essmodule::ESSControlProfile Default Constructor
 ******************************************************************/
openfmb::essmodule::ESSControlProfile::ESSControlProfile()
{
  init();
}

/******************************************************************
 * openfmb::essmodule::ESSControlProfile Copy Constructor
 ******************************************************************/
openfmb::essmodule::ESSControlProfile::ESSControlProfile( const ESSControlProfile & other )
  : ControlIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::essmodule::ESSControlProfile Destructor
 ******************************************************************/
openfmb::essmodule::ESSControlProfile::~ESSControlProfile()
{
  clear();
}

/******************************************************************
 * openfmb::essmodule::ESSControlProfile Assignment Operator
 ******************************************************************/
openfmb::essmodule::ESSControlProfile& openfmb::essmodule::ESSControlProfile::operator=( const openfmb::essmodule::ESSControlProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::essmodule::::ESSControlProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::essmodule::ESSControlProfile init()
 ******************************************************************/
void openfmb::essmodule::ESSControlProfile::init()
{
  /* init PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::init();
  this->targetESSSystemID = NULL;
  /* init struct: this->essControl */
  this->essControl.init( );
}

/******************************************************************
 * openfmb::essmodule::ESSControlProfile clear()
 ******************************************************************/
void openfmb::essmodule::ESSControlProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::clear();
  /* clear string: this->targetESSSystemID */
  if (this->targetESSSystemID != NULL) {
    delete[] this->targetESSSystemID;
    this->targetESSSystemID = NULL;
  }
  /* clear struct: this->essControl */
  this->essControl.clear( );
}

/******************************************************************
 *  openfmb::essmodule::ESSControlProfile copy()
 ******************************************************************/
void openfmb::essmodule::ESSControlProfile::copy( const ESSControlProfile * copy_from )
{

  ESSControlProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::copy( copy_from );
  /* copy targetESSSystemID */
  if (copy_from->targetESSSystemID) {
    copy_to->targetESSSystemID = new char[strlen(copy_from->targetESSSystemID) + 1];
    strcpy( copy_to->targetESSSystemID, copy_from->targetESSSystemID );
  }

  /* copy essControl */
  copy_to->essControl.copy( &copy_from->essControl );

}

/******************************************************************
 *  openfmb::essmodule::ESSControlProfile::get_marshal_size()
 ******************************************************************/
int openfmb::essmodule::ESSControlProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetESSSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetESSSystemID==NULL)?1:(unsigned int)((strlen(targetESSSystemID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetESSSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetESSSystemID==NULL)?1:(unsigned int)((strlen(targetESSSystemID)+1)*1);
      offset = essControl.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControlProfile::marshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSControlProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( targetESSSystemID ) len += (int)strlen( targetESSSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetESSSystemID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( targetESSSystemID ) len += (int)strlen( targetESSSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetESSSystemID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( targetESSSystemID ) len += (int)strlen( targetESSSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetESSSystemID, len);
          }
          offset = essControl.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          { int len = 1;
          if ( targetESSSystemID ) len += (int)strlen( targetESSSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetESSSystemID, len);
          }
          offset = essControl.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControlProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSControlProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::ControlIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( targetESSSystemID ) len += (int)strlen( targetESSSystemID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetESSSystemID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( targetESSSystemID ) len += (int)strlen( targetESSSystemID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetESSSystemID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControlProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::essmodule::ESSControlProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetESSSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetESSSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetESSSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetESSSystemID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetESSSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetESSSystemID, len, stream_len);
          }
          offset = essControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetESSSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetESSSystemID, len, stream_len);
          }
          offset = essControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControlProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::essmodule::ESSControlProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::ControlIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetESSSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetESSSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetESSSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetESSSystemID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::essmodule::ESSControlProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::essmodule::ESSControlProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlIED::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("targetESSSystemID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::essmodule::ESSControlProfile,targetESSSystemID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::essmodule::ESSControlProfile,targetESSSystemID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("essControl", fieldname, 10) == 0) && 
       (fieldname[10] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::essmodule::ESSControlProfile,essControl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::essmodule::ESSControl::get_field_def(&fieldname[11], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationControl Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationControl::GenerationControl()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationControl Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationControl::GenerationControl( const GenerationControl & other )
  : ControlValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationControl Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationControl::~GenerationControl()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationControl Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationControl& openfmb::generationmodule::GenerationControl::operator=( const openfmb::generationmodule::GenerationControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationControl init()
 ******************************************************************/
void openfmb::generationmodule::GenerationControl::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::init();
  this->check = NULL;
  /* init struct: this->generationControlFSCC */
  this->generationControlFSCC.init( );
}

/******************************************************************
 * openfmb::generationmodule::GenerationControl clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::clear();
  if (this->check != NULL) {
    /* clear struct: (*this->check) */
    (*this->check).clear( );
    delete this->check;
    this->check = NULL;
  }
  /* clear struct: this->generationControlFSCC */
  this->generationControlFSCC.clear( );
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControl copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationControl::copy( const GenerationControl * copy_from )
{

  GenerationControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::copy( copy_from );
  /* copy check */
  if (copy_from->check) {
    copy_to->check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
    (*copy_to->check).copy( &(*copy_from->check) );
  }
  else
    copy_to->check = NULL;

  /* copy generationControlFSCC */
  copy_to->generationControlFSCC.copy( &copy_from->generationControlFSCC );

}

/******************************************************************
 *  openfmb::generationmodule::GenerationControl::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (check != NULL) {
          offset = (*check).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = generationControlFSCC.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControl::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          offset = generationControlFSCC.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          offset = generationControlFSCC.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControl::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = generationControlFSCC.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = generationControlFSCC.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("check", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationControl,check);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CheckConditions::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("generationControlFSCC", fieldname, 21) == 0) && 
       (fieldname[21] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationControl,generationControlFSCC);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::GenerationControlFSCC::get_field_def(&fieldname[22], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlProfile Default Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationControlProfile::GenerationControlProfile()
{
  init();
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlProfile Copy Constructor
 ******************************************************************/
openfmb::generationmodule::GenerationControlProfile::GenerationControlProfile( const GenerationControlProfile & other )
  : ControlIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlProfile Destructor
 ******************************************************************/
openfmb::generationmodule::GenerationControlProfile::~GenerationControlProfile()
{
  clear();
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlProfile Assignment Operator
 ******************************************************************/
openfmb::generationmodule::GenerationControlProfile& openfmb::generationmodule::GenerationControlProfile::operator=( const openfmb::generationmodule::GenerationControlProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::generationmodule::::GenerationControlProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::generationmodule::GenerationControlProfile init()
 ******************************************************************/
void openfmb::generationmodule::GenerationControlProfile::init()
{
  /* init PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::init();
  this->targetGenerationSystemID = NULL;
  /* init struct: this->generationControl */
  this->generationControl.init( );
}

/******************************************************************
 * openfmb::generationmodule::GenerationControlProfile clear()
 ******************************************************************/
void openfmb::generationmodule::GenerationControlProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::clear();
  /* clear string: this->targetGenerationSystemID */
  if (this->targetGenerationSystemID != NULL) {
    delete[] this->targetGenerationSystemID;
    this->targetGenerationSystemID = NULL;
  }
  /* clear struct: this->generationControl */
  this->generationControl.clear( );
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlProfile copy()
 ******************************************************************/
void openfmb::generationmodule::GenerationControlProfile::copy( const GenerationControlProfile * copy_from )
{

  GenerationControlProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::copy( copy_from );
  /* copy targetGenerationSystemID */
  if (copy_from->targetGenerationSystemID) {
    copy_to->targetGenerationSystemID = new char[strlen(copy_from->targetGenerationSystemID) + 1];
    strcpy( copy_to->targetGenerationSystemID, copy_from->targetGenerationSystemID );
  }

  /* copy generationControl */
  copy_to->generationControl.copy( &copy_from->generationControl );

}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlProfile::get_marshal_size()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetGenerationSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetGenerationSystemID==NULL)?1:(unsigned int)((strlen(targetGenerationSystemID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetGenerationSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetGenerationSystemID==NULL)?1:(unsigned int)((strlen(targetGenerationSystemID)+1)*1);
      offset = generationControl.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlProfile::marshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( targetGenerationSystemID ) len += (int)strlen( targetGenerationSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetGenerationSystemID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( targetGenerationSystemID ) len += (int)strlen( targetGenerationSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetGenerationSystemID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( targetGenerationSystemID ) len += (int)strlen( targetGenerationSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetGenerationSystemID, len);
          }
          offset = generationControl.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          { int len = 1;
          if ( targetGenerationSystemID ) len += (int)strlen( targetGenerationSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetGenerationSystemID, len);
          }
          offset = generationControl.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::ControlIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( targetGenerationSystemID ) len += (int)strlen( targetGenerationSystemID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetGenerationSystemID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( targetGenerationSystemID ) len += (int)strlen( targetGenerationSystemID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetGenerationSystemID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetGenerationSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetGenerationSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetGenerationSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetGenerationSystemID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetGenerationSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetGenerationSystemID, len, stream_len);
          }
          offset = generationControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetGenerationSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetGenerationSystemID, len, stream_len);
          }
          offset = generationControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::generationmodule::GenerationControlProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::ControlIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetGenerationSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetGenerationSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetGenerationSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetGenerationSystemID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::generationmodule::GenerationControlProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::generationmodule::GenerationControlProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlIED::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("targetGenerationSystemID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::generationmodule::GenerationControlProfile,targetGenerationSystemID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::generationmodule::GenerationControlProfile,targetGenerationSystemID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("generationControl", fieldname, 17) == 0) && 
       (fieldname[17] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::generationmodule::GenerationControlProfile,generationControl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::generationmodule::GenerationControl::get_field_def(&fieldname[18], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadControlFSCC Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadControlFSCC::LoadControlFSCC()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadControlFSCC Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadControlFSCC::LoadControlFSCC( const LoadControlFSCC & other )
  : ControlFSCC()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadControlFSCC Destructor
 ******************************************************************/
openfmb::loadmodule::LoadControlFSCC::~LoadControlFSCC()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadControlFSCC Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadControlFSCC& openfmb::loadmodule::LoadControlFSCC::operator=( const openfmb::loadmodule::LoadControlFSCC & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadControlFSCC Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadControlFSCC init()
 ******************************************************************/
void openfmb::loadmodule::LoadControlFSCC::init()
{
  /* init PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::init();
  this->__dummy_prevent_empty_class_LoadControlFSCC = 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadControlFSCC clear()
 ******************************************************************/
void openfmb::loadmodule::LoadControlFSCC::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::clear();
  /* clear basic type: this->__dummy_prevent_empty_class_LoadControlFSCC NOOP */
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlFSCC copy()
 ******************************************************************/
void openfmb::loadmodule::LoadControlFSCC::copy( const LoadControlFSCC * copy_from )
{

  LoadControlFSCC * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::copy( copy_from );
  /* copy __dummy_prevent_empty_class_LoadControlFSCC */
  copy_to->__dummy_prevent_empty_class_LoadControlFSCC = copy_from->__dummy_prevent_empty_class_LoadControlFSCC;

}

/******************************************************************
 *  openfmb::loadmodule::LoadControlFSCC::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadControlFSCC::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
      /* __dummy_prevent_empty_class_LoadControlFSCC */
      offset += 1;
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlFSCC::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadControlFSCC::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlFSCC::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlFSCC);
        }
      else
        {
          DDS_MARSH_PUT_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlFSCC);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlFSCC::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadControlFSCC::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlFSCC::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadControlFSCC::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlFSCC, stream_len);
        }
       else
        {
          DDS_MARSH_GET_BYTE(buf, offset, __dummy_prevent_empty_class_LoadControlFSCC, stream_len);
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlFSCC::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadControlFSCC::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlFSCC get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadControlFSCC::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlFSCC::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("__dummy_prevent_empty_class_LoadControlFSCC", fieldname)==0) {
    field_def->kind       = 9;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::loadmodule::LoadControlFSCC,__dummy_prevent_empty_class_LoadControlFSCC);
    } else
      field_def->offset  += s_offsetof(struct openfmb::loadmodule::LoadControlFSCC,__dummy_prevent_empty_class_LoadControlFSCC);
    field_def->key        = 0;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingProfile Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadReadingProfile::LoadReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingProfile Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadReadingProfile::LoadReadingProfile( const LoadReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingProfile Destructor
 ******************************************************************/
openfmb::loadmodule::LoadReadingProfile::~LoadReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingProfile Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadReadingProfile& openfmb::loadmodule::LoadReadingProfile::operator=( const openfmb::loadmodule::LoadReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadReadingProfile init()
 ******************************************************************/
void openfmb::loadmodule::LoadReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::loadmodule::LoadReadingProfile clear()
 ******************************************************************/
void openfmb::loadmodule::LoadReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->loadReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->loadReadingValue.size(); i_0++)
      {
        /* clear struct: this->loadReadingValue[i_0] */
        this->loadReadingValue[i_0].clear( );
      }
    this->loadReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingProfile copy()
 ******************************************************************/
void openfmb::loadmodule::LoadReadingProfile::copy( const LoadReadingProfile * copy_from )
{

  LoadReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy loadReadingValue */
  copy_to->loadReadingValue.resize(copy_from->loadReadingValue.size());
  if ( copy_from->loadReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->loadReadingValue.size(); i_1++)
        {
          copy_to->loadReadingValue[i_1].copy( &copy_from->loadReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* loadReadingValue*/
      /* loadReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < loadReadingValue.size(); ii1++ ) {
           offset = loadReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* loadReadingValue */
          {
            unsigned int sl = (unsigned int)loadReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < loadReadingValue.size(); i1++)
            {
              offset = loadReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* loadReadingValue */
        }
      else
        {
          /* loadReadingValue */
          {
            unsigned int sl = (unsigned int)loadReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < loadReadingValue.size(); i1++)
            {
              offset = loadReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* loadReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            loadReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < loadReadingValue.capacity(); ii1++)
            {
              offset = loadReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* loadReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            loadReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < loadReadingValue.capacity(); ii1++)
            {
              offset = loadReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* loadReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingProfile Default Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingProfile::RecloserReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingProfile Copy Constructor
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingProfile::RecloserReadingProfile( const RecloserReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingProfile Destructor
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingProfile::~RecloserReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingProfile Assignment Operator
 ******************************************************************/
openfmb::reclosermodule::RecloserReadingProfile& openfmb::reclosermodule::RecloserReadingProfile::operator=( const openfmb::reclosermodule::RecloserReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::reclosermodule::::RecloserReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::reclosermodule::RecloserReadingProfile init()
 ******************************************************************/
void openfmb::reclosermodule::RecloserReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::reclosermodule::RecloserReadingProfile clear()
 ******************************************************************/
void openfmb::reclosermodule::RecloserReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->recloserReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->recloserReadingValue.size(); i_0++)
      {
        /* clear struct: this->recloserReadingValue[i_0] */
        this->recloserReadingValue[i_0].clear( );
      }
    this->recloserReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingProfile copy()
 ******************************************************************/
void openfmb::reclosermodule::RecloserReadingProfile::copy( const RecloserReadingProfile * copy_from )
{

  RecloserReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy recloserReadingValue */
  copy_to->recloserReadingValue.resize(copy_from->recloserReadingValue.size());
  if ( copy_from->recloserReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->recloserReadingValue.size(); i_1++)
        {
          copy_to->recloserReadingValue[i_1].copy( &copy_from->recloserReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* recloserReadingValue*/
      /* recloserReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < recloserReadingValue.size(); ii1++ ) {
           offset = recloserReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* recloserReadingValue */
          {
            unsigned int sl = (unsigned int)recloserReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < recloserReadingValue.size(); i1++)
            {
              offset = recloserReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* recloserReadingValue */
        }
      else
        {
          /* recloserReadingValue */
          {
            unsigned int sl = (unsigned int)recloserReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < recloserReadingValue.size(); i1++)
            {
              offset = recloserReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* recloserReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            recloserReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < recloserReadingValue.capacity(); ii1++)
            {
              offset = recloserReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* recloserReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            recloserReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < recloserReadingValue.capacity(); ii1++)
            {
              offset = recloserReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* recloserReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::reclosermodule::RecloserReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::reclosermodule::RecloserReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::reclosermodule::RecloserReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingProfile Default Constructor
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingProfile::RegulatorReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingProfile Copy Constructor
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingProfile::RegulatorReadingProfile( const RegulatorReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingProfile Destructor
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingProfile::~RegulatorReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingProfile Assignment Operator
 ******************************************************************/
openfmb::regulatormodule::RegulatorReadingProfile& openfmb::regulatormodule::RegulatorReadingProfile::operator=( const openfmb::regulatormodule::RegulatorReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::regulatormodule::::RegulatorReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingProfile init()
 ******************************************************************/
void openfmb::regulatormodule::RegulatorReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::regulatormodule::RegulatorReadingProfile clear()
 ******************************************************************/
void openfmb::regulatormodule::RegulatorReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->regulatorReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->regulatorReadingValue.size(); i_0++)
      {
        /* clear struct: this->regulatorReadingValue[i_0] */
        this->regulatorReadingValue[i_0].clear( );
      }
    this->regulatorReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingProfile copy()
 ******************************************************************/
void openfmb::regulatormodule::RegulatorReadingProfile::copy( const RegulatorReadingProfile * copy_from )
{

  RegulatorReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy regulatorReadingValue */
  copy_to->regulatorReadingValue.resize(copy_from->regulatorReadingValue.size());
  if ( copy_from->regulatorReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->regulatorReadingValue.size(); i_1++)
        {
          copy_to->regulatorReadingValue[i_1].copy( &copy_from->regulatorReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* regulatorReadingValue*/
      /* regulatorReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < regulatorReadingValue.size(); ii1++ ) {
           offset = regulatorReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* regulatorReadingValue */
          {
            unsigned int sl = (unsigned int)regulatorReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < regulatorReadingValue.size(); i1++)
            {
              offset = regulatorReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* regulatorReadingValue */
        }
      else
        {
          /* regulatorReadingValue */
          {
            unsigned int sl = (unsigned int)regulatorReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < regulatorReadingValue.size(); i1++)
            {
              offset = regulatorReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* regulatorReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            regulatorReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < regulatorReadingValue.capacity(); ii1++)
            {
              offset = regulatorReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* regulatorReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            regulatorReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < regulatorReadingValue.capacity(); ii1++)
            {
              offset = regulatorReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* regulatorReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::regulatormodule::RegulatorReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::regulatormodule::RegulatorReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::regulatormodule::RegulatorReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingProfile Default Constructor
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingProfile::ResourceReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingProfile Copy Constructor
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingProfile::ResourceReadingProfile( const ResourceReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingProfile Destructor
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingProfile::~ResourceReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingProfile Assignment Operator
 ******************************************************************/
openfmb::resourcemodule::ResourceReadingProfile& openfmb::resourcemodule::ResourceReadingProfile::operator=( const openfmb::resourcemodule::ResourceReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::resourcemodule::::ResourceReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::resourcemodule::ResourceReadingProfile init()
 ******************************************************************/
void openfmb::resourcemodule::ResourceReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::resourcemodule::ResourceReadingProfile clear()
 ******************************************************************/
void openfmb::resourcemodule::ResourceReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->resourceReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->resourceReadingValue.size(); i_0++)
      {
        /* clear struct: this->resourceReadingValue[i_0] */
        this->resourceReadingValue[i_0].clear( );
      }
    this->resourceReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingProfile copy()
 ******************************************************************/
void openfmb::resourcemodule::ResourceReadingProfile::copy( const ResourceReadingProfile * copy_from )
{

  ResourceReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy resourceReadingValue */
  copy_to->resourceReadingValue.resize(copy_from->resourceReadingValue.size());
  if ( copy_from->resourceReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->resourceReadingValue.size(); i_1++)
        {
          copy_to->resourceReadingValue[i_1].copy( &copy_from->resourceReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* resourceReadingValue*/
      /* resourceReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < resourceReadingValue.size(); ii1++ ) {
           offset = resourceReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* resourceReadingValue */
          {
            unsigned int sl = (unsigned int)resourceReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < resourceReadingValue.size(); i1++)
            {
              offset = resourceReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* resourceReadingValue */
        }
      else
        {
          /* resourceReadingValue */
          {
            unsigned int sl = (unsigned int)resourceReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < resourceReadingValue.size(); i1++)
            {
              offset = resourceReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* resourceReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            resourceReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < resourceReadingValue.capacity(); ii1++)
            {
              offset = resourceReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* resourceReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            resourceReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < resourceReadingValue.capacity(); ii1++)
            {
              offset = resourceReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* resourceReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::resourcemodule::ResourceReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::resourcemodule::ResourceReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::resourcemodule::ResourceReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarControlFSCC Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarControlFSCC::SolarControlFSCC()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarControlFSCC Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarControlFSCC::SolarControlFSCC( const SolarControlFSCC & other )
  : ControlFSCC()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarControlFSCC Destructor
 ******************************************************************/
openfmb::solarmodule::SolarControlFSCC::~SolarControlFSCC()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarControlFSCC Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarControlFSCC& openfmb::solarmodule::SolarControlFSCC::operator=( const openfmb::solarmodule::SolarControlFSCC & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarControlFSCC Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarControlFSCC init()
 ******************************************************************/
void openfmb::solarmodule::SolarControlFSCC::init()
{
  /* init PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::init();
  /* init struct: this->SolarControlMod */
  this->SolarControlMod.init( );
}

/******************************************************************
 * openfmb::solarmodule::SolarControlFSCC clear()
 ******************************************************************/
void openfmb::solarmodule::SolarControlFSCC::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::clear();
  /* clear struct: this->SolarControlMod */
  this->SolarControlMod.clear( );
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlFSCC copy()
 ******************************************************************/
void openfmb::solarmodule::SolarControlFSCC::copy( const SolarControlFSCC * copy_from )
{

  SolarControlFSCC * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlFSCC */
  openfmb::commonmodule::ControlFSCC::copy( copy_from );
  /* copy SolarControlMod */
  copy_to->SolarControlMod.copy( &copy_from->SolarControlMod );

}

/******************************************************************
 *  openfmb::solarmodule::SolarControlFSCC::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarControlFSCC::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::get_marshal_size(offset, just_keys);
      offset = SolarControlMod.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlFSCC::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarControlFSCC::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlFSCC::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          offset = SolarControlMod.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          offset = SolarControlMod.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlFSCC::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarControlFSCC::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlFSCC::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarControlFSCC::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlFSCC::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          offset = SolarControlMod.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          offset = SolarControlMod.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlFSCC::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarControlFSCC::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlFSCC get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarControlFSCC::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlFSCC::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("SolarControlMod", fieldname, 15) == 0) && 
       (fieldname[15] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarControlFSCC,SolarControlMod);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::commonmodule::ENC_SolarControlKind::get_field_def(&fieldname[16], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingProfile Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarReadingProfile::SolarReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingProfile Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarReadingProfile::SolarReadingProfile( const SolarReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingProfile Destructor
 ******************************************************************/
openfmb::solarmodule::SolarReadingProfile::~SolarReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingProfile Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarReadingProfile& openfmb::solarmodule::SolarReadingProfile::operator=( const openfmb::solarmodule::SolarReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarReadingProfile init()
 ******************************************************************/
void openfmb::solarmodule::SolarReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::solarmodule::SolarReadingProfile clear()
 ******************************************************************/
void openfmb::solarmodule::SolarReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->solarReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->solarReadingValue.size(); i_0++)
      {
        /* clear struct: this->solarReadingValue[i_0] */
        this->solarReadingValue[i_0].clear( );
      }
    this->solarReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingProfile copy()
 ******************************************************************/
void openfmb::solarmodule::SolarReadingProfile::copy( const SolarReadingProfile * copy_from )
{

  SolarReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy solarReadingValue */
  copy_to->solarReadingValue.resize(copy_from->solarReadingValue.size());
  if ( copy_from->solarReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->solarReadingValue.size(); i_1++)
        {
          copy_to->solarReadingValue[i_1].copy( &copy_from->solarReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* solarReadingValue*/
      /* solarReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < solarReadingValue.size(); ii1++ ) {
           offset = solarReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* solarReadingValue */
          {
            unsigned int sl = (unsigned int)solarReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < solarReadingValue.size(); i1++)
            {
              offset = solarReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* solarReadingValue */
        }
      else
        {
          /* solarReadingValue */
          {
            unsigned int sl = (unsigned int)solarReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < solarReadingValue.size(); i1++)
            {
              offset = solarReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* solarReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            solarReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < solarReadingValue.capacity(); ii1++)
            {
              offset = solarReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* solarReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            solarReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < solarReadingValue.capacity(); ii1++)
            {
              offset = solarReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* solarReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingProfile Default Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchReadingProfile::SwitchReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingProfile Copy Constructor
 ******************************************************************/
openfmb::switchmodule::SwitchReadingProfile::SwitchReadingProfile( const SwitchReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingProfile Destructor
 ******************************************************************/
openfmb::switchmodule::SwitchReadingProfile::~SwitchReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingProfile Assignment Operator
 ******************************************************************/
openfmb::switchmodule::SwitchReadingProfile& openfmb::switchmodule::SwitchReadingProfile::operator=( const openfmb::switchmodule::SwitchReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::switchmodule::::SwitchReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::switchmodule::SwitchReadingProfile init()
 ******************************************************************/
void openfmb::switchmodule::SwitchReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::switchmodule::SwitchReadingProfile clear()
 ******************************************************************/
void openfmb::switchmodule::SwitchReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->switchReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->switchReadingValue.size(); i_0++)
      {
        /* clear struct: this->switchReadingValue[i_0] */
        this->switchReadingValue[i_0].clear( );
      }
    this->switchReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingProfile copy()
 ******************************************************************/
void openfmb::switchmodule::SwitchReadingProfile::copy( const SwitchReadingProfile * copy_from )
{

  SwitchReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy switchReadingValue */
  copy_to->switchReadingValue.resize(copy_from->switchReadingValue.size());
  if ( copy_from->switchReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->switchReadingValue.size(); i_1++)
        {
          copy_to->switchReadingValue[i_1].copy( &copy_from->switchReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* switchReadingValue*/
      /* switchReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < switchReadingValue.size(); ii1++ ) {
           offset = switchReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* switchReadingValue */
          {
            unsigned int sl = (unsigned int)switchReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < switchReadingValue.size(); i1++)
            {
              offset = switchReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* switchReadingValue */
        }
      else
        {
          /* switchReadingValue */
          {
            unsigned int sl = (unsigned int)switchReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < switchReadingValue.size(); i1++)
            {
              offset = switchReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* switchReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            switchReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < switchReadingValue.capacity(); ii1++)
            {
              offset = switchReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* switchReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            switchReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < switchReadingValue.capacity(); ii1++)
            {
              offset = switchReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* switchReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::switchmodule::SwitchReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::switchmodule::SwitchReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::switchmodule::SwitchReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingProfile Default Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerReadingProfile::BreakerReadingProfile()
{
  init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingProfile Copy Constructor
 ******************************************************************/
openfmb::breakermodule::BreakerReadingProfile::BreakerReadingProfile( const BreakerReadingProfile & other )
  : MeasurementIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingProfile Destructor
 ******************************************************************/
openfmb::breakermodule::BreakerReadingProfile::~BreakerReadingProfile()
{
  clear();
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingProfile Assignment Operator
 ******************************************************************/
openfmb::breakermodule::BreakerReadingProfile& openfmb::breakermodule::BreakerReadingProfile::operator=( const openfmb::breakermodule::BreakerReadingProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::breakermodule::::BreakerReadingProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::breakermodule::BreakerReadingProfile init()
 ******************************************************************/
void openfmb::breakermodule::BreakerReadingProfile::init()
{
  /* init PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::init();
}

/******************************************************************
 * openfmb::breakermodule::BreakerReadingProfile clear()
 ******************************************************************/
void openfmb::breakermodule::BreakerReadingProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::clear();
  /* clear sequence: this->breakerReadingValue */
  {
    unsigned int i_0;
    for (i_0 = 0; i_0 < this->breakerReadingValue.size(); i_0++)
      {
        /* clear struct: this->breakerReadingValue[i_0] */
        this->breakerReadingValue[i_0].clear( );
      }
    this->breakerReadingValue.clear();
  }
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingProfile copy()
 ******************************************************************/
void openfmb::breakermodule::BreakerReadingProfile::copy( const BreakerReadingProfile * copy_from )
{

  BreakerReadingProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::MeasurementIED */
  openfmb::commonmodule::MeasurementIED::copy( copy_from );
  /* copy breakerReadingValue */
  copy_to->breakerReadingValue.resize(copy_from->breakerReadingValue.size());
  if ( copy_from->breakerReadingValue.size() )
    {
      unsigned int i_1;
      for (i_1 = 0; i_1 < copy_from->breakerReadingValue.size(); i_1++)
        {
          copy_to->breakerReadingValue[i_1].copy( &copy_from->breakerReadingValue[i_1] );
        }
    }

}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingProfile::get_marshal_size()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::get_marshal_size(offset, just_keys);
      /* breakerReadingValue*/
      /* breakerReadingValue.length */
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset += 4;
      {
         unsigned int ii1;
         for (ii1 = 0; ii1 < breakerReadingValue.size(); ii1++ ) {
           offset = breakerReadingValue[ii1].get_marshal_size( offset, 0 );
         }
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingProfile::marshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::MeasurementIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          /* breakerReadingValue */
          {
            unsigned int sl = (unsigned int)breakerReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < breakerReadingValue.size(); i1++)
            {
              offset = breakerReadingValue[i1].marshal_cdr( buf, offset, stream_len, 1, 0 );
            } 
          }  /* breakerReadingValue */
        }
      else
        {
          /* breakerReadingValue */
          {
            unsigned int sl = (unsigned int)breakerReadingValue.size();
            DDS_MARSH_PUT_LONG(buf, offset, sl);
          }
           {          unsigned int    i1;
          for (i1=0; i1 < breakerReadingValue.size(); i1++)
            {
              offset = breakerReadingValue[i1].marshal_cdr( buf, offset, stream_len, 0, 0 );
            } 
          }  /* breakerReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::MeasurementIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
    }
  else
    {
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, sl, stream_len);
            breakerReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < breakerReadingValue.capacity(); ii1++)
            {
              offset = breakerReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* breakerReadingValue */
        }
       else
        {
          {
            unsigned int sl;
            DDS_MARSH_GET_LONG(buf, offset, sl, stream_len);
            breakerReadingValue.resize(sl);
          }
           {          unsigned int    ii1;
          for (ii1=0; ii1 < breakerReadingValue.capacity(); ii1++)
            {
              offset = breakerReadingValue[ii1].unmarshal_cdr( buf, offset, stream_len, swap, 0 );
              if (offset<0) return offset;
            } 
          }  /* breakerReadingValue */
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::breakermodule::BreakerReadingProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::MeasurementIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
  return offset;
}

/******************************************************************
 *  openfmb::breakermodule::BreakerReadingProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::breakermodule::BreakerReadingProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::MeasurementIED::get_field_def(fieldname, field_def)) return 1;
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadControl Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadControl::LoadControl()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadControl Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadControl::LoadControl( const LoadControl & other )
  : ControlValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadControl Destructor
 ******************************************************************/
openfmb::loadmodule::LoadControl::~LoadControl()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadControl Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadControl& openfmb::loadmodule::LoadControl::operator=( const openfmb::loadmodule::LoadControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadControl init()
 ******************************************************************/
void openfmb::loadmodule::LoadControl::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::init();
  this->check = NULL;
}

/******************************************************************
 * openfmb::loadmodule::LoadControl clear()
 ******************************************************************/
void openfmb::loadmodule::LoadControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::clear();
  if (this->check != NULL) {
    /* clear struct: (*this->check) */
    (*this->check).clear( );
    delete this->check;
    this->check = NULL;
  }
  /* clear struct: this->loadControlFSCC */
  this->loadControlFSCC.clear( );
}

/******************************************************************
 *  openfmb::loadmodule::LoadControl copy()
 ******************************************************************/
void openfmb::loadmodule::LoadControl::copy( const LoadControl * copy_from )
{

  LoadControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::copy( copy_from );
  /* copy check */
  if (copy_from->check) {
    copy_to->check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
    (*copy_to->check).copy( &(*copy_from->check) );
  }
  else
    copy_to->check = NULL;

  /* copy loadControlFSCC */
  copy_to->loadControlFSCC.copy( &copy_from->loadControlFSCC );

}

/******************************************************************
 *  openfmb::loadmodule::LoadControl::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (check != NULL) {
          offset = (*check).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = loadControlFSCC.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControl::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          offset = loadControlFSCC.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          offset = loadControlFSCC.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControl::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = loadControlFSCC.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          offset = loadControlFSCC.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("check", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadControl,check);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CheckConditions::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("loadControlFSCC", fieldname, 15) == 0) && 
       (fieldname[15] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadControl,loadControlFSCC);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::loadmodule::LoadControlFSCC::get_field_def(&fieldname[16], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::loadmodule::LoadControlProfile Default Constructor
 ******************************************************************/
openfmb::loadmodule::LoadControlProfile::LoadControlProfile()
{
  init();
}

/******************************************************************
 * openfmb::loadmodule::LoadControlProfile Copy Constructor
 ******************************************************************/
openfmb::loadmodule::LoadControlProfile::LoadControlProfile( const LoadControlProfile & other )
  : ControlIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::loadmodule::LoadControlProfile Destructor
 ******************************************************************/
openfmb::loadmodule::LoadControlProfile::~LoadControlProfile()
{
  clear();
}

/******************************************************************
 * openfmb::loadmodule::LoadControlProfile Assignment Operator
 ******************************************************************/
openfmb::loadmodule::LoadControlProfile& openfmb::loadmodule::LoadControlProfile::operator=( const openfmb::loadmodule::LoadControlProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::loadmodule::::LoadControlProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::loadmodule::LoadControlProfile init()
 ******************************************************************/
void openfmb::loadmodule::LoadControlProfile::init()
{
  /* init PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::init();
  this->targetLoadSystemID = NULL;
  /* init struct: this->loadControl */
  this->loadControl.init( );
}

/******************************************************************
 * openfmb::loadmodule::LoadControlProfile clear()
 ******************************************************************/
void openfmb::loadmodule::LoadControlProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::clear();
  /* clear string: this->targetLoadSystemID */
  if (this->targetLoadSystemID != NULL) {
    delete[] this->targetLoadSystemID;
    this->targetLoadSystemID = NULL;
  }
  /* clear struct: this->loadControl */
  this->loadControl.clear( );
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlProfile copy()
 ******************************************************************/
void openfmb::loadmodule::LoadControlProfile::copy( const LoadControlProfile * copy_from )
{

  LoadControlProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::copy( copy_from );
  /* copy targetLoadSystemID */
  if (copy_from->targetLoadSystemID) {
    copy_to->targetLoadSystemID = new char[strlen(copy_from->targetLoadSystemID) + 1];
    strcpy( copy_to->targetLoadSystemID, copy_from->targetLoadSystemID );
  }

  /* copy loadControl */
  copy_to->loadControl.copy( &copy_from->loadControl );

}

/******************************************************************
 *  openfmb::loadmodule::LoadControlProfile::get_marshal_size()
 ******************************************************************/
int openfmb::loadmodule::LoadControlProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetLoadSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetLoadSystemID==NULL)?1:(unsigned int)((strlen(targetLoadSystemID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetLoadSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetLoadSystemID==NULL)?1:(unsigned int)((strlen(targetLoadSystemID)+1)*1);
      offset = loadControl.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlProfile::marshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadControlProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( targetLoadSystemID ) len += (int)strlen( targetLoadSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetLoadSystemID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( targetLoadSystemID ) len += (int)strlen( targetLoadSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetLoadSystemID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( targetLoadSystemID ) len += (int)strlen( targetLoadSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetLoadSystemID, len);
          }
          offset = loadControl.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          { int len = 1;
          if ( targetLoadSystemID ) len += (int)strlen( targetLoadSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetLoadSystemID, len);
          }
          offset = loadControl.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadControlProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::ControlIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( targetLoadSystemID ) len += (int)strlen( targetLoadSystemID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetLoadSystemID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( targetLoadSystemID ) len += (int)strlen( targetLoadSystemID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetLoadSystemID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::loadmodule::LoadControlProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetLoadSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetLoadSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetLoadSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetLoadSystemID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetLoadSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetLoadSystemID, len, stream_len);
          }
          offset = loadControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetLoadSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetLoadSystemID, len, stream_len);
          }
          offset = loadControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::loadmodule::LoadControlProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::ControlIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetLoadSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetLoadSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetLoadSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetLoadSystemID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::loadmodule::LoadControlProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::loadmodule::LoadControlProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlIED::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("targetLoadSystemID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::loadmodule::LoadControlProfile,targetLoadSystemID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::loadmodule::LoadControlProfile,targetLoadSystemID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("loadControl", fieldname, 11) == 0) && 
       (fieldname[11] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::loadmodule::LoadControlProfile,loadControl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::loadmodule::LoadControl::get_field_def(&fieldname[12], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarControl Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarControl::SolarControl()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarControl Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarControl::SolarControl( const SolarControl & other )
  : ControlValue()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarControl Destructor
 ******************************************************************/
openfmb::solarmodule::SolarControl::~SolarControl()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarControl Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarControl& openfmb::solarmodule::SolarControl::operator=( const openfmb::solarmodule::SolarControl & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarControl Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarControl init()
 ******************************************************************/
void openfmb::solarmodule::SolarControl::init()
{
  /* init PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::init();
  this->check = NULL;
  this->solarControlFSCC = NULL;
}

/******************************************************************
 * openfmb::solarmodule::SolarControl clear()
 ******************************************************************/
void openfmb::solarmodule::SolarControl::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::clear();
  if (this->check != NULL) {
    /* clear struct: (*this->check) */
    (*this->check).clear( );
    delete this->check;
    this->check = NULL;
  }
  if (this->solarControlFSCC != NULL) {
    /* clear struct: (*this->solarControlFSCC) */
    (*this->solarControlFSCC).clear( );
    delete this->solarControlFSCC;
    this->solarControlFSCC = NULL;
  }
}

/******************************************************************
 *  openfmb::solarmodule::SolarControl copy()
 ******************************************************************/
void openfmb::solarmodule::SolarControl::copy( const SolarControl * copy_from )
{

  SolarControl * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlValue */
  openfmb::commonmodule::ControlValue::copy( copy_from );
  /* copy check */
  if (copy_from->check) {
    copy_to->check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
    (*copy_to->check).copy( &(*copy_from->check) );
  }
  else
    copy_to->check = NULL;

  /* copy solarControlFSCC */
  if (copy_from->solarControlFSCC) {
    copy_to->solarControlFSCC = (struct openfmb::solarmodule::SolarControlFSCC*)new struct openfmb::solarmodule::SolarControlFSCC();
    (*copy_to->solarControlFSCC).copy( &(*copy_from->solarControlFSCC) );
  }
  else
    copy_to->solarControlFSCC = NULL;

}

/******************************************************************
 *  openfmb::solarmodule::SolarControl::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarControl::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::get_marshal_size(offset, just_keys);
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (check != NULL) {
          offset = (*check).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
      offset = (offset+3) & 0xfffffffc; /* align 4*/
      offset += 12; /* Extended PID Header */
      {
        int toffset = offset;
        offset = 0;
        if (solarControlFSCC != NULL) {
          offset = (*solarControlFSCC).get_marshal_size( offset, 0 );
        }
        offset += toffset;
      };
      offset = (offset+3) & 0xfffffffc;/* align 4*/
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControl::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarControl::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlValue::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
        }
      else
        {
        }
    }
  else
    {
      if (swap)
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT_AND_REORDER(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarControlFSCC != NULL) {
              offset = (*solarControlFSCC).marshal_cdr( buf, offset, stream_len, 1, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG_AND_REORDER(buf, pidlen_offset, datalen);
          }
        }
      else
        {
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 4;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (check != NULL) {
              offset = (*check).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
          {
            int32_t pidlen_offset;
            int32_t datalen;
            unsigned short pid;
            unsigned short pid_len;
            uint32_t ext_pid;
            uint32_t ext_pid_len;
            unsigned char *tbuf;
            int32_t        toffset;
            pid = 0x3f01;
            _ALIGN_4_FILL(buf, offset);
            DDS_MARSH_PUT_SHORT(buf, offset, pid);
            pid_len = 8;
            DDS_MARSH_PUT_SHORT(buf, offset, pid_len);
            ext_pid = 5;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid);
            pidlen_offset = offset;
            ext_pid_len = 0;
            DDS_MARSH_PUT_LONG(buf, offset, ext_pid_len);
            datalen = offset;
            /* PLHDR resets alignment context */
            tbuf    = buf;
            buf     = &buf[offset];
            toffset = offset;
            offset  = 0;
            
            if (solarControlFSCC != NULL) {
              offset = (*solarControlFSCC).marshal_cdr( buf, offset, stream_len, 0, 0 );
            }
            buf     = tbuf;
            offset += toffset;
            _ALIGN_4_FILL(buf, offset);
            datalen = offset - datalen;
            DDS_MARSH_PUT_LONG(buf, pidlen_offset, datalen);
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControl::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarControl::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControl::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarControl::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
        }
       else
        {
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlValue::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT_AND_REORDER(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarControlFSCC = (struct openfmb::solarmodule::SolarControlFSCC*)new struct openfmb::solarmodule::SolarControlFSCC();
                offset = (*solarControlFSCC).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarControlFSCC = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
       else
        {
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 4) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                check = (struct openfmb::commonmodule::CheckConditions*)new struct openfmb::commonmodule::CheckConditions();
                offset = (*check).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                check = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
          {
            unsigned short pid;
            unsigned short pid_len;
            uint32_t       ext_pid;
            uint32_t       ext_pid_len;
            uint32_t       member_id;
            unsigned char  impl_extension;
            uint32_t       must_understand;
            _ALIGN_4(offset);
            DDS_MARSH_GET_SHORT(buf, offset, pid, stream_len);
            DDS_MARSH_GET_SHORT(buf, offset, pid_len, stream_len);
            CDX_UNUSED(impl_extension);
            CDX_UNUSED(must_understand);
            impl_extension  = (pid & 0x8000)?1:0;
            must_understand = (pid & 0x4000)?1:0;
            pid = (pid & 0x3fff);
            if (pid == 0x3F01) { /* EXTENDED */
              DDS_MARSH_GET_LONG(buf, offset, ext_pid, stream_len);
              DDS_MARSH_GET_LONG(buf, offset, ext_pid_len, stream_len);
              member_id = ext_pid & 0x0FFFFFFF;
            }
            else {
              member_id   = pid & 0x3FFF;
              ext_pid_len = pid_len;
            }
            if (member_id == 5) {
              unsigned char *tbuf    = buf;
              int            toffset = offset;
              buf    = &buf[offset];
              offset = 0;
              stream_len -= toffset;
              if (ext_pid_len > 0) {
                solarControlFSCC = (struct openfmb::solarmodule::SolarControlFSCC*)new struct openfmb::solarmodule::SolarControlFSCC();
                offset = (*solarControlFSCC).unmarshal_cdr( buf, offset, stream_len, swap, 0 );
                if (offset<0) return offset;
              }
              else {
                solarControlFSCC = NULL;
              }
              buf     = tbuf;
              offset += toffset;
              stream_len += toffset;
            }
            else {
              if (must_understand)
                return DDS_MARSH_UNK_MEMBER_ID;
              else
                offset += ext_pid_len;
            }
          }
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControl::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarControl::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(buf);
  CDX_UNUSED(offset);
  CDX_UNUSED(stream_len);
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControl get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarControl::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlValue::get_field_def(fieldname, field_def)) return 1;
  if ( (strncmp("check", fieldname, 5) == 0) && 
       (fieldname[5] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarControl,check);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::commonmodule::CheckConditions::get_field_def(&fieldname[6], field_def);
  }
  if ( (strncmp("solarControlFSCC", fieldname, 16) == 0) && 
       (fieldname[16] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarControl,solarControlFSCC);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    if (!field_def->user) {
      field_def->user       = CoreDX_DDS_malloc(sizeof(CoreDX_FieldDef_OffsetTable));
      if (field_def->user) INIT_SEQ(*(CoreDX_FieldDef_OffsetTable*)field_def->user);
    }
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _field_offset = 0;
      seq_add(_offsetTable, &_field_offset);
    }
    return openfmb::solarmodule::SolarControlFSCC::get_field_def(&fieldname[17], field_def);
  }
  return 0;
}

/******************************************************************
 * openfmb::solarmodule::SolarControlProfile Default Constructor
 ******************************************************************/
openfmb::solarmodule::SolarControlProfile::SolarControlProfile()
{
  init();
}

/******************************************************************
 * openfmb::solarmodule::SolarControlProfile Copy Constructor
 ******************************************************************/
openfmb::solarmodule::SolarControlProfile::SolarControlProfile( const SolarControlProfile & other )
  : ControlIED()
{
  init();
  copy( &other );
}

/******************************************************************
 * openfmb::solarmodule::SolarControlProfile Destructor
 ******************************************************************/
openfmb::solarmodule::SolarControlProfile::~SolarControlProfile()
{
  clear();
}

/******************************************************************
 * openfmb::solarmodule::SolarControlProfile Assignment Operator
 ******************************************************************/
openfmb::solarmodule::SolarControlProfile& openfmb::solarmodule::SolarControlProfile::operator=( const openfmb::solarmodule::SolarControlProfile & other )
{
  if (this == &other)
      return *this;
  /* Free any allocated memory */
  clear();

  /* Perform the copy */

  copy( &other );
  return *this;
}

/******************************************************************
 * openfmb::solarmodule::::SolarControlProfile Ops
 *****************************************************************/


/******************************************************************
 * openfmb::solarmodule::SolarControlProfile init()
 ******************************************************************/
void openfmb::solarmodule::SolarControlProfile::init()
{
  /* init PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::init();
  this->targetSolarSystemID = NULL;
  /* init struct: this->solarControl */
  this->solarControl.init( );
}

/******************************************************************
 * openfmb::solarmodule::SolarControlProfile clear()
 ******************************************************************/
void openfmb::solarmodule::SolarControlProfile::clear()
{
  /* clear PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::clear();
  /* clear string: this->targetSolarSystemID */
  if (this->targetSolarSystemID != NULL) {
    delete[] this->targetSolarSystemID;
    this->targetSolarSystemID = NULL;
  }
  /* clear struct: this->solarControl */
  this->solarControl.clear( );
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlProfile copy()
 ******************************************************************/
void openfmb::solarmodule::SolarControlProfile::copy( const SolarControlProfile * copy_from )
{

  SolarControlProfile * copy_to = this;

  if ( ! copy_from ) return;


  /* copy PARENT: openfmb::commonmodule::ControlIED */
  openfmb::commonmodule::ControlIED::copy( copy_from );
  /* copy targetSolarSystemID */
  if (copy_from->targetSolarSystemID) {
    copy_to->targetSolarSystemID = new char[strlen(copy_from->targetSolarSystemID) + 1];
    strcpy( copy_to->targetSolarSystemID, copy_from->targetSolarSystemID );
  }

  /* copy solarControl */
  copy_to->solarControl.copy( &copy_from->solarControl );

}

/******************************************************************
 *  openfmb::solarmodule::SolarControlProfile::get_marshal_size()
 ******************************************************************/
int openfmb::solarmodule::SolarControlProfile::get_marshal_size(int     offset,
                           int     just_keys) const
{
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetSolarSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetSolarSystemID==NULL)?1:(unsigned int)((strlen(targetSolarSystemID)+1)*1);
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::get_marshal_size(offset, just_keys);
      /* targetSolarSystemID */
      offset = (offset+3) & 0xfffffffc;/* align 4 */
      offset += 4;
      offset += (targetSolarSystemID==NULL)?1:(unsigned int)((strlen(targetSolarSystemID)+1)*1);
      offset = solarControl.get_marshal_size( offset, 0 );
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlProfile::marshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarControlProfile::marshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys) const 
{
  CDX_UNUSED(stream_len);
  offset = openfmb::commonmodule::ControlIED::marshal_cdr(buf, offset, stream_len, swap, just_keys);
  if (just_keys)
    {
      if (swap)
        {
          { int len = 1;
          if ( targetSolarSystemID ) len += (int)strlen( targetSolarSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSolarSystemID, len);
          }
        }
      else
        {
          { int len = 1;
          if ( targetSolarSystemID ) len += (int)strlen( targetSolarSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSolarSystemID, len);
          }
        }
    }
  else
    {
      if (swap)
        {
          { int len = 1;
          if ( targetSolarSystemID ) len += (int)strlen( targetSolarSystemID );
          DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSolarSystemID, len);
          }
          offset = solarControl.marshal_cdr( buf, offset, stream_len, 1, 0 );
        }
      else
        {
          { int len = 1;
          if ( targetSolarSystemID ) len += (int)strlen( targetSolarSystemID );
          DDS_MARSH_PUT_LONG(buf, offset, len);
          DDS_MARSH_PUT_STR(buf, offset, targetSolarSystemID, len);
          }
          offset = solarControl.marshal_cdr( buf, offset, stream_len, 0, 0 );
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlProfile::marshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarControlProfile::marshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len) const
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
offset = openfmb::commonmodule::ControlIED::marshal_key_hash(buf, offset, stream_len);
  if (swap)
    {
      { int len = 1;
      if ( targetSolarSystemID ) len += (int)strlen( targetSolarSystemID );
      DDS_MARSH_PUT_LONG_AND_REORDER(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetSolarSystemID, len);
      }
    }
  else
    {
      { int len = 1;
      if ( targetSolarSystemID ) len += (int)strlen( targetSolarSystemID );
      DDS_MARSH_PUT_LONG(buf, offset, len);
      DDS_MARSH_PUT_STR(buf, offset, targetSolarSystemID, len);
      }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlProfile::unmarshal_cdr()
 ******************************************************************/
int openfmb::solarmodule::SolarControlProfile::unmarshal_cdr( unsigned char * buf,
                   int             offset,
                   int             stream_len,
                   unsigned char   swap,
                   int             just_keys)
{
  CDX_UNUSED(stream_len);
  this->init( );
  if (just_keys)
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetSolarSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSolarSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetSolarSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSolarSystemID, len, stream_len);
          }
        }
    }
  else
    {
      offset = openfmb::commonmodule::ControlIED::unmarshal_cdr(buf, offset, stream_len, swap, just_keys);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetSolarSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSolarSystemID, len, stream_len);
          }
          offset = solarControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetSolarSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSolarSystemID, len, stream_len);
          }
          offset = solarControl.unmarshal_cdr( buf, offset, stream_len, swap, 0 );
          if (offset<0) return offset;
        }
    }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlProfile::unmarshal_key_hash()
 ******************************************************************/
int openfmb::solarmodule::SolarControlProfile::unmarshal_key_hash( unsigned char * buf,
                   int             offset,
                   int             stream_len)
{
  CDX_UNUSED(stream_len);
  unsigned char swap;
  DDS_MARSH_MY_ENDIAN( swap );
      offset = openfmb::commonmodule::ControlIED::unmarshal_key_hash(buf, offset, stream_len);
       if (offset<0) return offset;
      if (swap)
        {
          { int len;
          DDS_MARSH_GET_LONG_AND_REORDER(buf, offset, len, stream_len);
          targetSolarSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSolarSystemID, len, stream_len);
          }
        }
       else
        {
          { int len;
          DDS_MARSH_GET_LONG(buf, offset, len, stream_len);
          targetSolarSystemID = new char[len];
          DDS_MARSH_GET_STR(buf, offset, targetSolarSystemID, len, stream_len);
          }
        }
  return offset;
}

/******************************************************************
 *  openfmb::solarmodule::SolarControlProfile get_field_def()
 ******************************************************************/
unsigned char
openfmb::solarmodule::SolarControlProfile::get_field_def( const char        * fieldname,
                       CoreDX_FieldDef_t * field_def)
{
    if (openfmb::commonmodule::ControlIED::get_field_def(fieldname, field_def)) return 1;
  if (strcmp("targetSolarSystemID", fieldname)==0) {
    field_def->kind       = 13;
    field_def->elem_kind  = 0;
    field_def->elem_count = 0;
    if (field_def->user) {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += s_offsetof(struct openfmb::solarmodule::SolarControlProfile,targetSolarSystemID);
    } else
      field_def->offset  += s_offsetof(struct openfmb::solarmodule::SolarControlProfile,targetSolarSystemID);
    field_def->key        = 1;
    field_def->access     = CoreDX_fielddef_access;
    field_def->clear      = CoreDX_fielddef_clear;
    return 1;
  }
  if ( (strncmp("solarControl", fieldname, 12) == 0) && 
       (fieldname[12] == '.') ) {
    uint32_t _field_offset = s_offsetof(struct openfmb::solarmodule::SolarControlProfile,solarControl);
    if (!field_def->user) 
      field_def->offset += _field_offset;
    else {
      CoreDX_FieldDef_OffsetTable * _offsetTable = (CoreDX_FieldDef_OffsetTable*)field_def->user;
      _offsetTable->_buffer[_offsetTable->_length-1] += _field_offset;
    }
    return openfmb::solarmodule::SolarControl::get_field_def(&fieldname[13], field_def);
  }
  return 0;
}

