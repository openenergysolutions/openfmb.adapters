/********************************************
 * Type specific TypeSupport header file.   *
 * Autogenerated by CoreDx DDL compiler.    *
 * Do no edit - edits may be overwritten.   *
 ********************************************/

#ifndef _OPENFMB_TYPESUPPORT_HH
#define _OPENFMB_TYPESUPPORT_HH

#include <dds/dds.hh>
#include <dds/dds_typesupport.hh>
#include "OpenFMB.hh"
#include "OpenFMBDataReader.hh"
#include "OpenFMBDataWriter.hh"

#ifdef _MSC_VER
#pragma warning(disable:4996)
#pragma warning(disable:4100)
#endif

using namespace DDS;
/* START SCOPE: UML_Extension */

namespace UML_Extension {


}  /* namespace UML_Extension */
/* END SCOPE: UML_Extension */
/* START SCOPE: openfmb */

namespace openfmb {

/* START SCOPE: breakermodule */

namespace breakermodule {


}  /* namespace breakermodule */
/* END SCOPE: breakermodule */
/* START SCOPE: commonmodule */

namespace commonmodule {


}  /* namespace commonmodule */
/* END SCOPE: commonmodule */
/* START SCOPE: essmodule */

namespace essmodule {


}  /* namespace essmodule */
/* END SCOPE: essmodule */
/* START SCOPE: generationmodule */

namespace generationmodule {


}  /* namespace generationmodule */
/* END SCOPE: generationmodule */
/* START SCOPE: interconnectionmodule */

namespace interconnectionmodule {


}  /* namespace interconnectionmodule */
/* END SCOPE: interconnectionmodule */
/* START SCOPE: loadmodule */

namespace loadmodule {


}  /* namespace loadmodule */
/* END SCOPE: loadmodule */
/* START SCOPE: optimizermodule */

namespace optimizermodule {


}  /* namespace optimizermodule */
/* END SCOPE: optimizermodule */
/* START SCOPE: reclosermodule */

namespace reclosermodule {


}  /* namespace reclosermodule */
/* END SCOPE: reclosermodule */
/* START SCOPE: regulatormodule */

namespace regulatormodule {


}  /* namespace regulatormodule */
/* END SCOPE: regulatormodule */
/* START SCOPE: resourcemodule */

namespace resourcemodule {


}  /* namespace resourcemodule */
/* END SCOPE: resourcemodule */
/* START SCOPE: solarmodule */

namespace solarmodule {


}  /* namespace solarmodule */
/* END SCOPE: solarmodule */
/* START SCOPE: switchmodule */

namespace switchmodule {


}  /* namespace switchmodule */
/* END SCOPE: switchmodule */

}  /* namespace openfmb */
/* END SCOPE: openfmb */
/* START SCOPE: openfmb */

namespace openfmb {

/* START SCOPE: commonmodule */

namespace commonmodule {


/******************************************************************
 *   openfmb::commonmodule::BCR TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT BCRTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  BCRTypeSupport();
  ~BCRTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static BCRTypeSupport * narrow( TypeSupport * ts) { return (BCRTypeSupport *)ts; }
  BCRTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  BCRDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  BCRDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::commonmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  BCRDataReader *  alloc_datareader( );
  BCRDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  BCRTypeSupport( const BCRTypeSupport *other );
  BCRTypeSupport& operator=( const BCRTypeSupport &other );

};


}  /* namespace commonmodule */
/* END SCOPE: commonmodule */
/* START SCOPE: essmodule */

namespace essmodule {


/******************************************************************
 *   openfmb::essmodule::ENC_ESSControlKind TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ENC_ESSControlKindTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ENC_ESSControlKindTypeSupport();
  ~ENC_ESSControlKindTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ENC_ESSControlKindTypeSupport * narrow( TypeSupport * ts) { return (ENC_ESSControlKindTypeSupport *)ts; }
  ENC_ESSControlKindTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ENC_ESSControlKindDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ENC_ESSControlKindDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ENC_ESSControlKindDataReader *  alloc_datareader( );
  ENC_ESSControlKindDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ENC_ESSControlKindTypeSupport( const ENC_ESSControlKindTypeSupport *other );
  ENC_ESSControlKindTypeSupport& operator=( const ENC_ESSControlKindTypeSupport &other );

};


}  /* namespace essmodule */
/* END SCOPE: essmodule */
/* START SCOPE: generationmodule */

namespace generationmodule {


/******************************************************************
 *   openfmb::generationmodule::GenerationControlScheduleProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT GenerationControlScheduleProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  GenerationControlScheduleProfileTypeSupport();
  ~GenerationControlScheduleProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static GenerationControlScheduleProfileTypeSupport * narrow( TypeSupport * ts) { return (GenerationControlScheduleProfileTypeSupport *)ts; }
  GenerationControlScheduleProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  GenerationControlScheduleProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  GenerationControlScheduleProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::generationmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  GenerationControlScheduleProfileDataReader *  alloc_datareader( );
  GenerationControlScheduleProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  GenerationControlScheduleProfileTypeSupport( const GenerationControlScheduleProfileTypeSupport *other );
  GenerationControlScheduleProfileTypeSupport& operator=( const GenerationControlScheduleProfileTypeSupport &other );

};


}  /* namespace generationmodule */
/* END SCOPE: generationmodule */
/* START SCOPE: interconnectionmodule */

namespace interconnectionmodule {


/******************************************************************
 *   openfmb::interconnectionmodule::PlannedInterconnectionScheduleProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT PlannedInterconnectionScheduleProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  PlannedInterconnectionScheduleProfileTypeSupport();
  ~PlannedInterconnectionScheduleProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static PlannedInterconnectionScheduleProfileTypeSupport * narrow( TypeSupport * ts) { return (PlannedInterconnectionScheduleProfileTypeSupport *)ts; }
  PlannedInterconnectionScheduleProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  PlannedInterconnectionScheduleProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  PlannedInterconnectionScheduleProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::interconnectionmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  PlannedInterconnectionScheduleProfileDataReader *  alloc_datareader( );
  PlannedInterconnectionScheduleProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  PlannedInterconnectionScheduleProfileTypeSupport( const PlannedInterconnectionScheduleProfileTypeSupport *other );
  PlannedInterconnectionScheduleProfileTypeSupport& operator=( const PlannedInterconnectionScheduleProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::interconnectionmodule::RequestedInterconnectionScheduleProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RequestedInterconnectionScheduleProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RequestedInterconnectionScheduleProfileTypeSupport();
  ~RequestedInterconnectionScheduleProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RequestedInterconnectionScheduleProfileTypeSupport * narrow( TypeSupport * ts) { return (RequestedInterconnectionScheduleProfileTypeSupport *)ts; }
  RequestedInterconnectionScheduleProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RequestedInterconnectionScheduleProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RequestedInterconnectionScheduleProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::interconnectionmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RequestedInterconnectionScheduleProfileDataReader *  alloc_datareader( );
  RequestedInterconnectionScheduleProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RequestedInterconnectionScheduleProfileTypeSupport( const RequestedInterconnectionScheduleProfileTypeSupport *other );
  RequestedInterconnectionScheduleProfileTypeSupport& operator=( const RequestedInterconnectionScheduleProfileTypeSupport &other );

};


}  /* namespace interconnectionmodule */
/* END SCOPE: interconnectionmodule */
/* START SCOPE: loadmodule */

namespace loadmodule {


}  /* namespace loadmodule */
/* END SCOPE: loadmodule */
/* START SCOPE: optimizermodule */

namespace optimizermodule {


/******************************************************************
 *   openfmb::optimizermodule::RequestedOptimizerScheduleProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RequestedOptimizerScheduleProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RequestedOptimizerScheduleProfileTypeSupport();
  ~RequestedOptimizerScheduleProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RequestedOptimizerScheduleProfileTypeSupport * narrow( TypeSupport * ts) { return (RequestedOptimizerScheduleProfileTypeSupport *)ts; }
  RequestedOptimizerScheduleProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RequestedOptimizerScheduleProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RequestedOptimizerScheduleProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::optimizermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RequestedOptimizerScheduleProfileDataReader *  alloc_datareader( );
  RequestedOptimizerScheduleProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RequestedOptimizerScheduleProfileTypeSupport( const RequestedOptimizerScheduleProfileTypeSupport *other );
  RequestedOptimizerScheduleProfileTypeSupport& operator=( const RequestedOptimizerScheduleProfileTypeSupport &other );

};


}  /* namespace optimizermodule */
/* END SCOPE: optimizermodule */
/* START SCOPE: reclosermodule */

namespace reclosermodule {


}  /* namespace reclosermodule */
/* END SCOPE: reclosermodule */
/* START SCOPE: switchmodule */

namespace switchmodule {


/******************************************************************
 *   openfmb::switchmodule::SwitchControlXSWI TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SwitchControlXSWITypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SwitchControlXSWITypeSupport();
  ~SwitchControlXSWITypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SwitchControlXSWITypeSupport * narrow( TypeSupport * ts) { return (SwitchControlXSWITypeSupport *)ts; }
  SwitchControlXSWITypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SwitchControlXSWIDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SwitchControlXSWIDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::switchmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SwitchControlXSWIDataReader *  alloc_datareader( );
  SwitchControlXSWIDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SwitchControlXSWITypeSupport( const SwitchControlXSWITypeSupport *other );
  SwitchControlXSWITypeSupport& operator=( const SwitchControlXSWITypeSupport &other );

};


}  /* namespace switchmodule */
/* END SCOPE: switchmodule */

}  /* namespace openfmb */
/* END SCOPE: openfmb */
/* START SCOPE: openfmb */

namespace openfmb {

/* START SCOPE: breakermodule */

namespace breakermodule {


}  /* namespace breakermodule */
/* END SCOPE: breakermodule */
/* START SCOPE: commonmodule */

namespace commonmodule {


}  /* namespace commonmodule */
/* END SCOPE: commonmodule */
/* START SCOPE: essmodule */

namespace essmodule {


/******************************************************************
 *   openfmb::essmodule::EssEventZBAT TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT EssEventZBATTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  EssEventZBATTypeSupport();
  ~EssEventZBATTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static EssEventZBATTypeSupport * narrow( TypeSupport * ts) { return (EssEventZBATTypeSupport *)ts; }
  EssEventZBATTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  EssEventZBATDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  EssEventZBATDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  EssEventZBATDataReader *  alloc_datareader( );
  EssEventZBATDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  EssEventZBATTypeSupport( const EssEventZBATTypeSupport *other );
  EssEventZBATTypeSupport& operator=( const EssEventZBATTypeSupport &other );

};


/******************************************************************
 *   openfmb::essmodule::EssStatusZBAT TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT EssStatusZBATTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  EssStatusZBATTypeSupport();
  ~EssStatusZBATTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static EssStatusZBATTypeSupport * narrow( TypeSupport * ts) { return (EssStatusZBATTypeSupport *)ts; }
  EssStatusZBATTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  EssStatusZBATDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  EssStatusZBATDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  EssStatusZBATDataReader *  alloc_datareader( );
  EssStatusZBATDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  EssStatusZBATTypeSupport( const EssStatusZBATTypeSupport *other );
  EssStatusZBATTypeSupport& operator=( const EssStatusZBATTypeSupport &other );

};


}  /* namespace essmodule */
/* END SCOPE: essmodule */
/* START SCOPE: generationmodule */

namespace generationmodule {


/******************************************************************
 *   openfmb::generationmodule::GenerationStatusProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT GenerationStatusProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  GenerationStatusProfileTypeSupport();
  ~GenerationStatusProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static GenerationStatusProfileTypeSupport * narrow( TypeSupport * ts) { return (GenerationStatusProfileTypeSupport *)ts; }
  GenerationStatusProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  GenerationStatusProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  GenerationStatusProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::generationmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  GenerationStatusProfileDataReader *  alloc_datareader( );
  GenerationStatusProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  GenerationStatusProfileTypeSupport( const GenerationStatusProfileTypeSupport *other );
  GenerationStatusProfileTypeSupport& operator=( const GenerationStatusProfileTypeSupport &other );

};


}  /* namespace generationmodule */
/* END SCOPE: generationmodule */
/* START SCOPE: loadmodule */

namespace loadmodule {


/******************************************************************
 *   openfmb::loadmodule::LoadStatusProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT LoadStatusProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  LoadStatusProfileTypeSupport();
  ~LoadStatusProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static LoadStatusProfileTypeSupport * narrow( TypeSupport * ts) { return (LoadStatusProfileTypeSupport *)ts; }
  LoadStatusProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  LoadStatusProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  LoadStatusProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::loadmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  LoadStatusProfileDataReader *  alloc_datareader( );
  LoadStatusProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  LoadStatusProfileTypeSupport( const LoadStatusProfileTypeSupport *other );
  LoadStatusProfileTypeSupport& operator=( const LoadStatusProfileTypeSupport &other );

};


}  /* namespace loadmodule */
/* END SCOPE: loadmodule */
/* START SCOPE: optimizermodule */

namespace optimizermodule {


/******************************************************************
 *   openfmb::optimizermodule::PlannedOptimizerScheduleProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT PlannedOptimizerScheduleProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  PlannedOptimizerScheduleProfileTypeSupport();
  ~PlannedOptimizerScheduleProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static PlannedOptimizerScheduleProfileTypeSupport * narrow( TypeSupport * ts) { return (PlannedOptimizerScheduleProfileTypeSupport *)ts; }
  PlannedOptimizerScheduleProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  PlannedOptimizerScheduleProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  PlannedOptimizerScheduleProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::optimizermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  PlannedOptimizerScheduleProfileDataReader *  alloc_datareader( );
  PlannedOptimizerScheduleProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  PlannedOptimizerScheduleProfileTypeSupport( const PlannedOptimizerScheduleProfileTypeSupport *other );
  PlannedOptimizerScheduleProfileTypeSupport& operator=( const PlannedOptimizerScheduleProfileTypeSupport &other );

};


}  /* namespace optimizermodule */
/* END SCOPE: optimizermodule */
/* START SCOPE: reclosermodule */

namespace reclosermodule {


}  /* namespace reclosermodule */
/* END SCOPE: reclosermodule */
/* START SCOPE: solarmodule */

namespace solarmodule {


/******************************************************************
 *   openfmb::solarmodule::SolarEventZGEN TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarEventZGENTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarEventZGENTypeSupport();
  ~SolarEventZGENTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarEventZGENTypeSupport * narrow( TypeSupport * ts) { return (SolarEventZGENTypeSupport *)ts; }
  SolarEventZGENTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarEventZGENDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarEventZGENDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarEventZGENDataReader *  alloc_datareader( );
  SolarEventZGENDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarEventZGENTypeSupport( const SolarEventZGENTypeSupport *other );
  SolarEventZGENTypeSupport& operator=( const SolarEventZGENTypeSupport &other );

};


/******************************************************************
 *   openfmb::solarmodule::SolarStatusZGEN TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarStatusZGENTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarStatusZGENTypeSupport();
  ~SolarStatusZGENTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarStatusZGENTypeSupport * narrow( TypeSupport * ts) { return (SolarStatusZGENTypeSupport *)ts; }
  SolarStatusZGENTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarStatusZGENDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarStatusZGENDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarStatusZGENDataReader *  alloc_datareader( );
  SolarStatusZGENDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarStatusZGENTypeSupport( const SolarStatusZGENTypeSupport *other );
  SolarStatusZGENTypeSupport& operator=( const SolarStatusZGENTypeSupport &other );

};


}  /* namespace solarmodule */
/* END SCOPE: solarmodule */
/* START SCOPE: switchmodule */

namespace switchmodule {


}  /* namespace switchmodule */
/* END SCOPE: switchmodule */

}  /* namespace openfmb */
/* END SCOPE: openfmb */
/* START SCOPE: openfmb */

namespace openfmb {

/* START SCOPE: breakermodule */

namespace breakermodule {


}  /* namespace breakermodule */
/* END SCOPE: breakermodule */
/* START SCOPE: commonmodule */

namespace commonmodule {


}  /* namespace commonmodule */
/* END SCOPE: commonmodule */
/* START SCOPE: essmodule */

namespace essmodule {


/******************************************************************
 *   openfmb::essmodule::ESSEventProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ESSEventProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ESSEventProfileTypeSupport();
  ~ESSEventProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ESSEventProfileTypeSupport * narrow( TypeSupport * ts) { return (ESSEventProfileTypeSupport *)ts; }
  ESSEventProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ESSEventProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ESSEventProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ESSEventProfileDataReader *  alloc_datareader( );
  ESSEventProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ESSEventProfileTypeSupport( const ESSEventProfileTypeSupport *other );
  ESSEventProfileTypeSupport& operator=( const ESSEventProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::essmodule::ESSReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ESSReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ESSReadingValueTypeSupport();
  ~ESSReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ESSReadingValueTypeSupport * narrow( TypeSupport * ts) { return (ESSReadingValueTypeSupport *)ts; }
  ESSReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ESSReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ESSReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ESSReadingValueDataReader *  alloc_datareader( );
  ESSReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ESSReadingValueTypeSupport( const ESSReadingValueTypeSupport *other );
  ESSReadingValueTypeSupport& operator=( const ESSReadingValueTypeSupport &other );

};


/******************************************************************
 *   openfmb::essmodule::ESSStatusProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ESSStatusProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ESSStatusProfileTypeSupport();
  ~ESSStatusProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ESSStatusProfileTypeSupport * narrow( TypeSupport * ts) { return (ESSStatusProfileTypeSupport *)ts; }
  ESSStatusProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ESSStatusProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ESSStatusProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ESSStatusProfileDataReader *  alloc_datareader( );
  ESSStatusProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ESSStatusProfileTypeSupport( const ESSStatusProfileTypeSupport *other );
  ESSStatusProfileTypeSupport& operator=( const ESSStatusProfileTypeSupport &other );

};


}  /* namespace essmodule */
/* END SCOPE: essmodule */
/* START SCOPE: generationmodule */

namespace generationmodule {


/******************************************************************
 *   openfmb::generationmodule::GenerationReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT GenerationReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  GenerationReadingValueTypeSupport();
  ~GenerationReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static GenerationReadingValueTypeSupport * narrow( TypeSupport * ts) { return (GenerationReadingValueTypeSupport *)ts; }
  GenerationReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  GenerationReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  GenerationReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::generationmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  GenerationReadingValueDataReader *  alloc_datareader( );
  GenerationReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  GenerationReadingValueTypeSupport( const GenerationReadingValueTypeSupport *other );
  GenerationReadingValueTypeSupport& operator=( const GenerationReadingValueTypeSupport &other );

};


/******************************************************************
 *   openfmb::generationmodule::GenerationReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT GenerationReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  GenerationReadingProfileTypeSupport();
  ~GenerationReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static GenerationReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (GenerationReadingProfileTypeSupport *)ts; }
  GenerationReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  GenerationReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  GenerationReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::generationmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  GenerationReadingProfileDataReader *  alloc_datareader( );
  GenerationReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  GenerationReadingProfileTypeSupport( const GenerationReadingProfileTypeSupport *other );
  GenerationReadingProfileTypeSupport& operator=( const GenerationReadingProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::generationmodule::GenerationEventProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT GenerationEventProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  GenerationEventProfileTypeSupport();
  ~GenerationEventProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static GenerationEventProfileTypeSupport * narrow( TypeSupport * ts) { return (GenerationEventProfileTypeSupport *)ts; }
  GenerationEventProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  GenerationEventProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  GenerationEventProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::generationmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  GenerationEventProfileDataReader *  alloc_datareader( );
  GenerationEventProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  GenerationEventProfileTypeSupport( const GenerationEventProfileTypeSupport *other );
  GenerationEventProfileTypeSupport& operator=( const GenerationEventProfileTypeSupport &other );

};


}  /* namespace generationmodule */
/* END SCOPE: generationmodule */
/* START SCOPE: loadmodule */

namespace loadmodule {


/******************************************************************
 *   openfmb::loadmodule::LoadEventProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT LoadEventProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  LoadEventProfileTypeSupport();
  ~LoadEventProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static LoadEventProfileTypeSupport * narrow( TypeSupport * ts) { return (LoadEventProfileTypeSupport *)ts; }
  LoadEventProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  LoadEventProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  LoadEventProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::loadmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  LoadEventProfileDataReader *  alloc_datareader( );
  LoadEventProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  LoadEventProfileTypeSupport( const LoadEventProfileTypeSupport *other );
  LoadEventProfileTypeSupport& operator=( const LoadEventProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::loadmodule::LoadReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT LoadReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  LoadReadingValueTypeSupport();
  ~LoadReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static LoadReadingValueTypeSupport * narrow( TypeSupport * ts) { return (LoadReadingValueTypeSupport *)ts; }
  LoadReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  LoadReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  LoadReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::loadmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  LoadReadingValueDataReader *  alloc_datareader( );
  LoadReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  LoadReadingValueTypeSupport( const LoadReadingValueTypeSupport *other );
  LoadReadingValueTypeSupport& operator=( const LoadReadingValueTypeSupport &other );

};


}  /* namespace loadmodule */
/* END SCOPE: loadmodule */
/* START SCOPE: reclosermodule */

namespace reclosermodule {


/******************************************************************
 *   openfmb::reclosermodule::RecloserControlProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RecloserControlProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RecloserControlProfileTypeSupport();
  ~RecloserControlProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RecloserControlProfileTypeSupport * narrow( TypeSupport * ts) { return (RecloserControlProfileTypeSupport *)ts; }
  RecloserControlProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RecloserControlProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RecloserControlProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::reclosermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RecloserControlProfileDataReader *  alloc_datareader( );
  RecloserControlProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RecloserControlProfileTypeSupport( const RecloserControlProfileTypeSupport *other );
  RecloserControlProfileTypeSupport& operator=( const RecloserControlProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::reclosermodule::RecloserEventProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RecloserEventProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RecloserEventProfileTypeSupport();
  ~RecloserEventProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RecloserEventProfileTypeSupport * narrow( TypeSupport * ts) { return (RecloserEventProfileTypeSupport *)ts; }
  RecloserEventProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RecloserEventProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RecloserEventProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::reclosermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RecloserEventProfileDataReader *  alloc_datareader( );
  RecloserEventProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RecloserEventProfileTypeSupport( const RecloserEventProfileTypeSupport *other );
  RecloserEventProfileTypeSupport& operator=( const RecloserEventProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::reclosermodule::RecloserReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RecloserReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RecloserReadingValueTypeSupport();
  ~RecloserReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RecloserReadingValueTypeSupport * narrow( TypeSupport * ts) { return (RecloserReadingValueTypeSupport *)ts; }
  RecloserReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RecloserReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RecloserReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::reclosermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RecloserReadingValueDataReader *  alloc_datareader( );
  RecloserReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RecloserReadingValueTypeSupport( const RecloserReadingValueTypeSupport *other );
  RecloserReadingValueTypeSupport& operator=( const RecloserReadingValueTypeSupport &other );

};


/******************************************************************
 *   openfmb::reclosermodule::RecloserStatusProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RecloserStatusProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RecloserStatusProfileTypeSupport();
  ~RecloserStatusProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RecloserStatusProfileTypeSupport * narrow( TypeSupport * ts) { return (RecloserStatusProfileTypeSupport *)ts; }
  RecloserStatusProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RecloserStatusProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RecloserStatusProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::reclosermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RecloserStatusProfileDataReader *  alloc_datareader( );
  RecloserStatusProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RecloserStatusProfileTypeSupport( const RecloserStatusProfileTypeSupport *other );
  RecloserStatusProfileTypeSupport& operator=( const RecloserStatusProfileTypeSupport &other );

};


}  /* namespace reclosermodule */
/* END SCOPE: reclosermodule */
/* START SCOPE: regulatormodule */

namespace regulatormodule {


/******************************************************************
 *   openfmb::regulatormodule::RegulatorReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RegulatorReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RegulatorReadingValueTypeSupport();
  ~RegulatorReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RegulatorReadingValueTypeSupport * narrow( TypeSupport * ts) { return (RegulatorReadingValueTypeSupport *)ts; }
  RegulatorReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RegulatorReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RegulatorReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::regulatormodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RegulatorReadingValueDataReader *  alloc_datareader( );
  RegulatorReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RegulatorReadingValueTypeSupport( const RegulatorReadingValueTypeSupport *other );
  RegulatorReadingValueTypeSupport& operator=( const RegulatorReadingValueTypeSupport &other );

};


}  /* namespace regulatormodule */
/* END SCOPE: regulatormodule */
/* START SCOPE: resourcemodule */

namespace resourcemodule {


/******************************************************************
 *   openfmb::resourcemodule::ResourceReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ResourceReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ResourceReadingValueTypeSupport();
  ~ResourceReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ResourceReadingValueTypeSupport * narrow( TypeSupport * ts) { return (ResourceReadingValueTypeSupport *)ts; }
  ResourceReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ResourceReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ResourceReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::resourcemodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ResourceReadingValueDataReader *  alloc_datareader( );
  ResourceReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ResourceReadingValueTypeSupport( const ResourceReadingValueTypeSupport *other );
  ResourceReadingValueTypeSupport& operator=( const ResourceReadingValueTypeSupport &other );

};


}  /* namespace resourcemodule */
/* END SCOPE: resourcemodule */
/* START SCOPE: solarmodule */

namespace solarmodule {


/******************************************************************
 *   openfmb::solarmodule::SolarEventProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarEventProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarEventProfileTypeSupport();
  ~SolarEventProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarEventProfileTypeSupport * narrow( TypeSupport * ts) { return (SolarEventProfileTypeSupport *)ts; }
  SolarEventProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarEventProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarEventProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarEventProfileDataReader *  alloc_datareader( );
  SolarEventProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarEventProfileTypeSupport( const SolarEventProfileTypeSupport *other );
  SolarEventProfileTypeSupport& operator=( const SolarEventProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::solarmodule::SolarReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarReadingValueTypeSupport();
  ~SolarReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarReadingValueTypeSupport * narrow( TypeSupport * ts) { return (SolarReadingValueTypeSupport *)ts; }
  SolarReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarReadingValueDataReader *  alloc_datareader( );
  SolarReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarReadingValueTypeSupport( const SolarReadingValueTypeSupport *other );
  SolarReadingValueTypeSupport& operator=( const SolarReadingValueTypeSupport &other );

};


/******************************************************************
 *   openfmb::solarmodule::SolarStatusProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarStatusProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarStatusProfileTypeSupport();
  ~SolarStatusProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarStatusProfileTypeSupport * narrow( TypeSupport * ts) { return (SolarStatusProfileTypeSupport *)ts; }
  SolarStatusProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarStatusProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarStatusProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarStatusProfileDataReader *  alloc_datareader( );
  SolarStatusProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarStatusProfileTypeSupport( const SolarStatusProfileTypeSupport *other );
  SolarStatusProfileTypeSupport& operator=( const SolarStatusProfileTypeSupport &other );

};


}  /* namespace solarmodule */
/* END SCOPE: solarmodule */
/* START SCOPE: switchmodule */

namespace switchmodule {


/******************************************************************
 *   openfmb::switchmodule::SwitchControlProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SwitchControlProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SwitchControlProfileTypeSupport();
  ~SwitchControlProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SwitchControlProfileTypeSupport * narrow( TypeSupport * ts) { return (SwitchControlProfileTypeSupport *)ts; }
  SwitchControlProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SwitchControlProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SwitchControlProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::switchmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SwitchControlProfileDataReader *  alloc_datareader( );
  SwitchControlProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SwitchControlProfileTypeSupport( const SwitchControlProfileTypeSupport *other );
  SwitchControlProfileTypeSupport& operator=( const SwitchControlProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::switchmodule::SwitchEventProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SwitchEventProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SwitchEventProfileTypeSupport();
  ~SwitchEventProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SwitchEventProfileTypeSupport * narrow( TypeSupport * ts) { return (SwitchEventProfileTypeSupport *)ts; }
  SwitchEventProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SwitchEventProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SwitchEventProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::switchmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SwitchEventProfileDataReader *  alloc_datareader( );
  SwitchEventProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SwitchEventProfileTypeSupport( const SwitchEventProfileTypeSupport *other );
  SwitchEventProfileTypeSupport& operator=( const SwitchEventProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::switchmodule::SwitchReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SwitchReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SwitchReadingValueTypeSupport();
  ~SwitchReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SwitchReadingValueTypeSupport * narrow( TypeSupport * ts) { return (SwitchReadingValueTypeSupport *)ts; }
  SwitchReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SwitchReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SwitchReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::switchmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SwitchReadingValueDataReader *  alloc_datareader( );
  SwitchReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SwitchReadingValueTypeSupport( const SwitchReadingValueTypeSupport *other );
  SwitchReadingValueTypeSupport& operator=( const SwitchReadingValueTypeSupport &other );

};


/******************************************************************
 *   openfmb::switchmodule::SwitchStatusProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SwitchStatusProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SwitchStatusProfileTypeSupport();
  ~SwitchStatusProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SwitchStatusProfileTypeSupport * narrow( TypeSupport * ts) { return (SwitchStatusProfileTypeSupport *)ts; }
  SwitchStatusProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SwitchStatusProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SwitchStatusProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::switchmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SwitchStatusProfileDataReader *  alloc_datareader( );
  SwitchStatusProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SwitchStatusProfileTypeSupport( const SwitchStatusProfileTypeSupport *other );
  SwitchStatusProfileTypeSupport& operator=( const SwitchStatusProfileTypeSupport &other );

};


}  /* namespace switchmodule */
/* END SCOPE: switchmodule */

}  /* namespace openfmb */
/* END SCOPE: openfmb */
/* START SCOPE: openfmb */

namespace openfmb {

/* START SCOPE: breakermodule */

namespace breakermodule {


/******************************************************************
 *   openfmb::breakermodule::BreakerControlProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT BreakerControlProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  BreakerControlProfileTypeSupport();
  ~BreakerControlProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static BreakerControlProfileTypeSupport * narrow( TypeSupport * ts) { return (BreakerControlProfileTypeSupport *)ts; }
  BreakerControlProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  BreakerControlProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  BreakerControlProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::breakermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  BreakerControlProfileDataReader *  alloc_datareader( );
  BreakerControlProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  BreakerControlProfileTypeSupport( const BreakerControlProfileTypeSupport *other );
  BreakerControlProfileTypeSupport& operator=( const BreakerControlProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::breakermodule::BreakerEventProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT BreakerEventProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  BreakerEventProfileTypeSupport();
  ~BreakerEventProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static BreakerEventProfileTypeSupport * narrow( TypeSupport * ts) { return (BreakerEventProfileTypeSupport *)ts; }
  BreakerEventProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  BreakerEventProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  BreakerEventProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::breakermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  BreakerEventProfileDataReader *  alloc_datareader( );
  BreakerEventProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  BreakerEventProfileTypeSupport( const BreakerEventProfileTypeSupport *other );
  BreakerEventProfileTypeSupport& operator=( const BreakerEventProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::breakermodule::BreakerReadingValue TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT BreakerReadingValueTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  BreakerReadingValueTypeSupport();
  ~BreakerReadingValueTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static BreakerReadingValueTypeSupport * narrow( TypeSupport * ts) { return (BreakerReadingValueTypeSupport *)ts; }
  BreakerReadingValueTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  BreakerReadingValueDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  BreakerReadingValueDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::breakermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  BreakerReadingValueDataReader *  alloc_datareader( );
  BreakerReadingValueDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  BreakerReadingValueTypeSupport( const BreakerReadingValueTypeSupport *other );
  BreakerReadingValueTypeSupport& operator=( const BreakerReadingValueTypeSupport &other );

};


/******************************************************************
 *   openfmb::breakermodule::BreakerStatusProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT BreakerStatusProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  BreakerStatusProfileTypeSupport();
  ~BreakerStatusProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static BreakerStatusProfileTypeSupport * narrow( TypeSupport * ts) { return (BreakerStatusProfileTypeSupport *)ts; }
  BreakerStatusProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  BreakerStatusProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  BreakerStatusProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::breakermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  BreakerStatusProfileDataReader *  alloc_datareader( );
  BreakerStatusProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  BreakerStatusProfileTypeSupport( const BreakerStatusProfileTypeSupport *other );
  BreakerStatusProfileTypeSupport& operator=( const BreakerStatusProfileTypeSupport &other );

};


}  /* namespace breakermodule */
/* END SCOPE: breakermodule */
/* START SCOPE: commonmodule */

namespace commonmodule {


}  /* namespace commonmodule */
/* END SCOPE: commonmodule */
/* START SCOPE: essmodule */

namespace essmodule {


/******************************************************************
 *   openfmb::essmodule::EssControlFSCC TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT EssControlFSCCTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  EssControlFSCCTypeSupport();
  ~EssControlFSCCTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static EssControlFSCCTypeSupport * narrow( TypeSupport * ts) { return (EssControlFSCCTypeSupport *)ts; }
  EssControlFSCCTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  EssControlFSCCDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  EssControlFSCCDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  EssControlFSCCDataReader *  alloc_datareader( );
  EssControlFSCCDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  EssControlFSCCTypeSupport( const EssControlFSCCTypeSupport *other );
  EssControlFSCCTypeSupport& operator=( const EssControlFSCCTypeSupport &other );

};


/******************************************************************
 *   openfmb::essmodule::ESSReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ESSReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ESSReadingProfileTypeSupport();
  ~ESSReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ESSReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (ESSReadingProfileTypeSupport *)ts; }
  ESSReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ESSReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ESSReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ESSReadingProfileDataReader *  alloc_datareader( );
  ESSReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ESSReadingProfileTypeSupport( const ESSReadingProfileTypeSupport *other );
  ESSReadingProfileTypeSupport& operator=( const ESSReadingProfileTypeSupport &other );

};


/******************************************************************
 *   openfmb::essmodule::ESSControl TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ESSControlTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ESSControlTypeSupport();
  ~ESSControlTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ESSControlTypeSupport * narrow( TypeSupport * ts) { return (ESSControlTypeSupport *)ts; }
  ESSControlTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ESSControlDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ESSControlDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ESSControlDataReader *  alloc_datareader( );
  ESSControlDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ESSControlTypeSupport( const ESSControlTypeSupport *other );
  ESSControlTypeSupport& operator=( const ESSControlTypeSupport &other );

};


/******************************************************************
 *   openfmb::essmodule::ESSControlProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ESSControlProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ESSControlProfileTypeSupport();
  ~ESSControlProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ESSControlProfileTypeSupport * narrow( TypeSupport * ts) { return (ESSControlProfileTypeSupport *)ts; }
  ESSControlProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ESSControlProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ESSControlProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::essmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ESSControlProfileDataReader *  alloc_datareader( );
  ESSControlProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ESSControlProfileTypeSupport( const ESSControlProfileTypeSupport *other );
  ESSControlProfileTypeSupport& operator=( const ESSControlProfileTypeSupport &other );

};


}  /* namespace essmodule */
/* END SCOPE: essmodule */
/* START SCOPE: generationmodule */

namespace generationmodule {


/******************************************************************
 *   openfmb::generationmodule::GenerationControlProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT GenerationControlProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  GenerationControlProfileTypeSupport();
  ~GenerationControlProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static GenerationControlProfileTypeSupport * narrow( TypeSupport * ts) { return (GenerationControlProfileTypeSupport *)ts; }
  GenerationControlProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  GenerationControlProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  GenerationControlProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::generationmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  GenerationControlProfileDataReader *  alloc_datareader( );
  GenerationControlProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  GenerationControlProfileTypeSupport( const GenerationControlProfileTypeSupport *other );
  GenerationControlProfileTypeSupport& operator=( const GenerationControlProfileTypeSupport &other );

};


}  /* namespace generationmodule */
/* END SCOPE: generationmodule */
/* START SCOPE: loadmodule */

namespace loadmodule {


/******************************************************************
 *   openfmb::loadmodule::LoadControlFSCC TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT LoadControlFSCCTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  LoadControlFSCCTypeSupport();
  ~LoadControlFSCCTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static LoadControlFSCCTypeSupport * narrow( TypeSupport * ts) { return (LoadControlFSCCTypeSupport *)ts; }
  LoadControlFSCCTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  LoadControlFSCCDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  LoadControlFSCCDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::loadmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  LoadControlFSCCDataReader *  alloc_datareader( );
  LoadControlFSCCDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  LoadControlFSCCTypeSupport( const LoadControlFSCCTypeSupport *other );
  LoadControlFSCCTypeSupport& operator=( const LoadControlFSCCTypeSupport &other );

};


/******************************************************************
 *   openfmb::loadmodule::LoadReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT LoadReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  LoadReadingProfileTypeSupport();
  ~LoadReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static LoadReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (LoadReadingProfileTypeSupport *)ts; }
  LoadReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  LoadReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  LoadReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::loadmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  LoadReadingProfileDataReader *  alloc_datareader( );
  LoadReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  LoadReadingProfileTypeSupport( const LoadReadingProfileTypeSupport *other );
  LoadReadingProfileTypeSupport& operator=( const LoadReadingProfileTypeSupport &other );

};


}  /* namespace loadmodule */
/* END SCOPE: loadmodule */
/* START SCOPE: reclosermodule */

namespace reclosermodule {


/******************************************************************
 *   openfmb::reclosermodule::RecloserReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RecloserReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RecloserReadingProfileTypeSupport();
  ~RecloserReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RecloserReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (RecloserReadingProfileTypeSupport *)ts; }
  RecloserReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RecloserReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RecloserReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::reclosermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RecloserReadingProfileDataReader *  alloc_datareader( );
  RecloserReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RecloserReadingProfileTypeSupport( const RecloserReadingProfileTypeSupport *other );
  RecloserReadingProfileTypeSupport& operator=( const RecloserReadingProfileTypeSupport &other );

};


}  /* namespace reclosermodule */
/* END SCOPE: reclosermodule */
/* START SCOPE: regulatormodule */

namespace regulatormodule {


/******************************************************************
 *   openfmb::regulatormodule::RegulatorReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT RegulatorReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  RegulatorReadingProfileTypeSupport();
  ~RegulatorReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static RegulatorReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (RegulatorReadingProfileTypeSupport *)ts; }
  RegulatorReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  RegulatorReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  RegulatorReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::regulatormodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  RegulatorReadingProfileDataReader *  alloc_datareader( );
  RegulatorReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  RegulatorReadingProfileTypeSupport( const RegulatorReadingProfileTypeSupport *other );
  RegulatorReadingProfileTypeSupport& operator=( const RegulatorReadingProfileTypeSupport &other );

};


}  /* namespace regulatormodule */
/* END SCOPE: regulatormodule */
/* START SCOPE: resourcemodule */

namespace resourcemodule {


/******************************************************************
 *   openfmb::resourcemodule::ResourceReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT ResourceReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  ResourceReadingProfileTypeSupport();
  ~ResourceReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static ResourceReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (ResourceReadingProfileTypeSupport *)ts; }
  ResourceReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  ResourceReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  ResourceReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::resourcemodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  ResourceReadingProfileDataReader *  alloc_datareader( );
  ResourceReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  ResourceReadingProfileTypeSupport( const ResourceReadingProfileTypeSupport *other );
  ResourceReadingProfileTypeSupport& operator=( const ResourceReadingProfileTypeSupport &other );

};


}  /* namespace resourcemodule */
/* END SCOPE: resourcemodule */
/* START SCOPE: solarmodule */

namespace solarmodule {


/******************************************************************
 *   openfmb::solarmodule::SolarControlFSCC TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarControlFSCCTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarControlFSCCTypeSupport();
  ~SolarControlFSCCTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarControlFSCCTypeSupport * narrow( TypeSupport * ts) { return (SolarControlFSCCTypeSupport *)ts; }
  SolarControlFSCCTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarControlFSCCDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarControlFSCCDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarControlFSCCDataReader *  alloc_datareader( );
  SolarControlFSCCDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarControlFSCCTypeSupport( const SolarControlFSCCTypeSupport *other );
  SolarControlFSCCTypeSupport& operator=( const SolarControlFSCCTypeSupport &other );

};


/******************************************************************
 *   openfmb::solarmodule::SolarReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarReadingProfileTypeSupport();
  ~SolarReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (SolarReadingProfileTypeSupport *)ts; }
  SolarReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarReadingProfileDataReader *  alloc_datareader( );
  SolarReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarReadingProfileTypeSupport( const SolarReadingProfileTypeSupport *other );
  SolarReadingProfileTypeSupport& operator=( const SolarReadingProfileTypeSupport &other );

};


}  /* namespace solarmodule */
/* END SCOPE: solarmodule */
/* START SCOPE: switchmodule */

namespace switchmodule {


/******************************************************************
 *   openfmb::switchmodule::SwitchReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SwitchReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SwitchReadingProfileTypeSupport();
  ~SwitchReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SwitchReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (SwitchReadingProfileTypeSupport *)ts; }
  SwitchReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SwitchReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SwitchReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::switchmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SwitchReadingProfileDataReader *  alloc_datareader( );
  SwitchReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SwitchReadingProfileTypeSupport( const SwitchReadingProfileTypeSupport *other );
  SwitchReadingProfileTypeSupport& operator=( const SwitchReadingProfileTypeSupport &other );

};


}  /* namespace switchmodule */
/* END SCOPE: switchmodule */

}  /* namespace openfmb */
/* END SCOPE: openfmb */
/* START SCOPE: openfmb */

namespace openfmb {

/* START SCOPE: breakermodule */

namespace breakermodule {


/******************************************************************
 *   openfmb::breakermodule::BreakerReadingProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT BreakerReadingProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  BreakerReadingProfileTypeSupport();
  ~BreakerReadingProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static BreakerReadingProfileTypeSupport * narrow( TypeSupport * ts) { return (BreakerReadingProfileTypeSupport *)ts; }
  BreakerReadingProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  BreakerReadingProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  BreakerReadingProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::breakermodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  BreakerReadingProfileDataReader *  alloc_datareader( );
  BreakerReadingProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  BreakerReadingProfileTypeSupport( const BreakerReadingProfileTypeSupport *other );
  BreakerReadingProfileTypeSupport& operator=( const BreakerReadingProfileTypeSupport &other );

};


}  /* namespace breakermodule */
/* END SCOPE: breakermodule */
/* START SCOPE: loadmodule */

namespace loadmodule {


/******************************************************************
 *   openfmb::loadmodule::LoadControlProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT LoadControlProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  LoadControlProfileTypeSupport();
  ~LoadControlProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static LoadControlProfileTypeSupport * narrow( TypeSupport * ts) { return (LoadControlProfileTypeSupport *)ts; }
  LoadControlProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  LoadControlProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  LoadControlProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::loadmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  LoadControlProfileDataReader *  alloc_datareader( );
  LoadControlProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  LoadControlProfileTypeSupport( const LoadControlProfileTypeSupport *other );
  LoadControlProfileTypeSupport& operator=( const LoadControlProfileTypeSupport &other );

};


}  /* namespace loadmodule */
/* END SCOPE: loadmodule */
/* START SCOPE: solarmodule */

namespace solarmodule {


/******************************************************************
 *   openfmb::solarmodule::SolarControlProfile TypeSupport Class
 ******************************************************************/

class COREDX_TS_CLASS_EXPORT SolarControlProfileTypeSupport : public TypeSupport
{
public:

  /* Constructor / Destructor */

  SolarControlProfileTypeSupport();
  ~SolarControlProfileTypeSupport() {};

  /* TypeSupport methods */

  static ReturnCode_t  register_type( DomainParticipant *  participant,
                                      const char *         type_name );

  static  const char *  get_type_name( );
  virtual const char *  get_fully_qualified_type_name( );

  static SolarControlProfileTypeSupport * narrow( TypeSupport * ts) { return (SolarControlProfileTypeSupport *)ts; }
  SolarControlProfileTypeSupport        * narrow( )                 { return this; }

  /* Other supporting methods */

  SolarControlProfileDataReader *  create_datareader( DDS::Subscriber          * subscriber,
                                       DDS::TopicDescription    * a_topic,
                                       const DDS::DataReaderQos & qos,
                                       DDS::DataReaderListener  * a_listener,
                                       DDS::StatusMask            mask );
  SolarControlProfileDataWriter *  create_datawriter( DDS::Publisher           * publisher,
                                       DDS::Topic               * a_topic,
                                       const DDS::DataWriterQos & qos,
                                       DDS::DataWriterListener  * a_listener,
                                       DDS::StatusMask            mask);

// ns: openfmb::solarmodule:: 
protected:
  struct _TypeSupport  _ts;
  struct _TypeSupport *get_typesupport() { return &_ts;}
  SolarControlProfileDataReader *  alloc_datareader( );
  SolarControlProfileDataWriter *  alloc_datawriter( );

private:
  /* Copy Constructor, Assignment Operator - not valid      */
  SolarControlProfileTypeSupport( const SolarControlProfileTypeSupport *other );
  SolarControlProfileTypeSupport& operator=( const SolarControlProfileTypeSupport &other );

};


}  /* namespace solarmodule */
/* END SCOPE: solarmodule */

}  /* namespace openfmb */
/* END SCOPE: openfmb */
#endif

